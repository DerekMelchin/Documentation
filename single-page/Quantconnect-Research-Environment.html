<h1>QuantConnect Documentation - Research Environment</h1>
<h4>Created on 06/08/2023</h4>
Copyright QuantConnect 2023

<p style="page-break-after: always;">&nbsp;</p>
<h3>Table of Content</h3>
<nav>
<ul>
<li><a href="#1" class="toc-h1" target="_parent">1 Key Concepts</a></li>
<li><a href="#1.1" class="toc-h2" target="_parent">1.1 Getting Started</a></li>
<li><a href="#1.2" class="toc-h2" target="_parent">1.2 Research Engine</a></li>
<li><a href="#2" class="toc-h1" target="_parent">2 Initialization</a></li>
<li><a href="#3" class="toc-h1" target="_parent">3 Datasets</a></li>
<li><a href="#3.1" class="toc-h2" target="_parent">3.1 Key Concepts</a></li>
<li><a href="#3.2" class="toc-h2" target="_parent">3.2 US Equity</a></li>
<li><a href="#3.3" class="toc-h2" target="_parent">3.3 Equity Fundamental Data</a></li>
<li><a href="#3.4" class="toc-h2" target="_parent">3.4 Equity Options</a></li>
<li><a href="#3.5" class="toc-h2" target="_parent">3.5 Crypto</a></li>
<li><a href="#3.6" class="toc-h2" target="_parent">3.6 Crypto Futures</a></li>
<li><a href="#3.7" class="toc-h2" target="_parent">3.7 Futures</a></li>
<li><a href="#3.8" class="toc-h2" target="_parent">3.8 Futures Options</a></li>
<li><a href="#3.9" class="toc-h2" target="_parent">3.9 Forex</a></li>
<li><a href="#3.10" class="toc-h2" target="_parent">3.10 CFD</a></li>
<li><a href="#3.11" class="toc-h2" target="_parent">3.11 Indices</a></li>
<li><a href="#3.12" class="toc-h2" target="_parent">3.12 Index Options</a></li>
<li><a href="#3.13" class="toc-h2" target="_parent">3.13 Alternative Data</a></li>
<li><a href="#3.14" class="toc-h2" target="_parent">3.14 Custom Data</a></li>
<li><a href="#4" class="toc-h1" target="_parent">4 Charting</a></li>
<li><a href="#4.1" class="toc-h2" target="_parent">4.1 Bokeh</a></li>
<li><a href="#4.2" class="toc-h2" target="_parent">4.2 Matplotlib</a></li>
<li><a href="#4.3" class="toc-h2" target="_parent">4.3 Plotly</a></li>
<li><a href="#4.4" class="toc-h2" target="_parent">4.4 Seaborn</a></li>
<li><a href="#4.5" class="toc-h2" target="_parent">4.5 Plotly NET</a></li>
<li><a href="#5" class="toc-h1" target="_parent">5 Indicators</a></li>
<li><a href="#5.1" class="toc-h2" target="_parent">5.1 Data Point Indicators</a></li>
<li><a href="#5.2" class="toc-h2" target="_parent">5.2 Bar Indicators</a></li>
<li><a href="#5.3" class="toc-h2" target="_parent">5.3 Trade Bar Indicators</a></li>
<li><a href="#5.4" class="toc-h2" target="_parent">5.4 Combining Indicators</a></li>
<li><a href="#5.5" class="toc-h2" target="_parent">5.5 Custom Indicators</a></li>
<li><a href="#5.6" class="toc-h2" target="_parent">5.6 Custom Resolutions</a></li>
<li><a href="#6" class="toc-h1" target="_parent">6 Object Store</a></li>
<li><a href="#7" class="toc-h1" target="_parent">7 Machine Learning</a></li>
<li><a href="#7.1" class="toc-h2" target="_parent">7.1 Key Concepts</a></li>
<li><a href="#7.2" class="toc-h2" target="_parent">7.2 Keras</a></li>
<li><a href="#7.3" class="toc-h2" target="_parent">7.3 TensorFlow</a></li>
<li><a href="#7.4" class="toc-h2" target="_parent">7.4 Scikit-Learn</a></li>
<li><a href="#7.5" class="toc-h2" target="_parent">7.5 Hmmlearn</a></li>
<li><a href="#7.6" class="toc-h2" target="_parent">7.6 Gplearn</a></li>
<li><a href="#7.7" class="toc-h2" target="_parent">7.7 PyTorch</a></li>
<li><a href="#7.8" class="toc-h2" target="_parent">7.8 Stable Baselines</a></li>
<li><a href="#7.9" class="toc-h2" target="_parent">7.9 Tslearn</a></li>
<li><a href="#7.10" class="toc-h2" target="_parent">7.10 XGBoost</a></li>
<li><a href="#7.11" class="toc-h2" target="_parent">7.11 Aesera</a></li>
<li><a href="#8" class="toc-h1" target="_parent">8 Debugging</a></li>
<li><a href="#9" class="toc-h1" target="_parent">9 Meta Analysis</a></li>
<li><a href="#9.1" class="toc-h2" target="_parent">9.1 Key Concepts</a></li>
<li><a href="#9.2" class="toc-h2" target="_parent">9.2 Backtest Analysis</a></li>
<li><a href="#9.3" class="toc-h2" target="_parent">9.3 Optimization Analysis</a></li>
<li><a href="#9.4" class="toc-h2" target="_parent">9.4 Live Analysis</a></li>
<li><a href="#10" class="toc-h1" target="_parent">10 Applying Research</a></li>
<li><a href="#10.1" class="toc-h2" target="_parent">10.1 Key Concepts</a></li>
<li><a href="#10.2" class="toc-h2" target="_parent">10.2 Mean Reversion</a></li>
<li><a href="#10.3" class="toc-h2" target="_parent">10.3 Random Forest Regression</a></li>
<li><a href="#10.4" class="toc-h2" target="_parent">10.4 Uncorrelated Assets</a></li>
<li><a href="#10.5" class="toc-h2" target="_parent">10.5 Kalman Filters and Stat Arb</a></li>
<li><a href="#10.6" class="toc-h2" target="_parent">10.6 PCA and Pairs Trading</a></li>
<li><a href="#10.7" class="toc-h2" target="_parent">10.7 Hidden Markov Models</a></li>
<li><a href="#10.8" class="toc-h2" target="_parent">10.8 Long Short-Term Memory</a></li>
<li><a href="#10.9" class="toc-h2" target="_parent">10.9 Airline Buybacks</a></li>
<li><a href="#10.10" class="toc-h2" target="_parent">10.10 Sparse Optimization</a></li>
</ul>
</nav>
<p style="page-break-after: always;">&nbsp;</p>
<section id="1"><h3>1 Key Concepts</h3></section>

<section id="1.1"><h3>1.1 Getting Started</h3></section>

<img alt="Running a jupyter notebook cell" class="docs-image" src="https://cdn.quantconnect.com/i/tu/run-research-cell-py-1.gif"/>

<h3>Introduction</h3>
<p>
 The Research Environment is a
 <a href="https://jupyter-notebook.readthedocs.io/en/stable/notebook.html" rel="nofollow" target="_blank">
  Jupyter notebook
 </a>
 -based, interactive commandline environment where you can access our data through the
 <code>
  QuantBook
 </code>
 class. The environment supports both Python and C#. If you use Python, you can import code from the code files in your project into the Research Environment to aid development.
</p>
<p>
 Before you run backtests, we recommend testing your hypothesis in the Research Environment. It's easier to perform data analysis and
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
  produce plots in the Research Environment
 </a>
 than in a backtest.
</p>
<p>
 Before backtesting or live trading with machine learning models, you may find it beneficial to train them in the Research Environment, save them in the ObjectStore, and then load them from the ObjectStore into the backtesting and live trading environment
</p>
<p>
 In the Research Environment, you can also use the QuantConnect API to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/meta-analysis/backtest-analysis">
  import your backtest results
 </a>
 for further analysis.
</p>

<h3>Example</h3>
<p class="python">
 The following snippet demonstrates how to use the Research Environment to plot the price and Bollinger Bands of the S&amp;P 500 index ETF, SPY:
</p>
<p class="csharp">
 The following snippet demonstrates how to use the Research Environment to print the price of the S&amp;P 500 index ETF, SPY:
</p>
<div class="section-example-container">
 <pre class="csharp">// Load the required assembly files and data types
#load "../Initialize.csx"
#load "../QuantConnect.csx"
using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Algorithm;
using QuantConnect.Research;

// Create a QuantBook
var qb = new QuantBook();

// Create a security subscription
var symbol = qb.AddEquity("SPY").Symbol;

// Request some historical data
var history = qb.History(symbol, 70, Resolution.Daily);

foreach (var tradeBar in history)
{
    Console.WriteLine($"{tradeBar.EndTime} :: {tradeBar.ToString()}");
}</pre>
 <pre class="python"># Create a QuantBook
qb = QuantBook()

# Create a security subscription
spy = qb.AddEquity("SPY")

# Request some historical data
history = qb.History(qb.Securities.Keys, 360, Resolution.Daily)

# Calculate the Bollinger Bands
bbdf = qb.Indicator(BollingerBands(30, 2), spy.Symbol, 360, Resolution.Daily)

# Plot the data
bbdf.drop('standarddeviation', 1).plot()</pre>
 <img alt="Bollinger Bands plotting in research environment" class="python docs-image" src="https://www.dropbox.com/s/6c3h1ndt3oo0ioc/notebook%203.PNG?dl=1" title=""/>
 <img alt="Historical minute data of SPY" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/reserach-keyconcept-csharp.png" title=""/>
</div>

<h3>Open Notebooks</h3>
<p>
 Each new project you create contains a notebook file by default. Follow these steps to open the notebook:
</p>
<ol>
 <li>
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
   Open the project
  </a>
  .
 </li>
 <li>
  In the right navigation menu, click the
  <img alt="Local lab explorer icon" class="inline-icon" src="https://cdn.quantconnect.com/i/tu/local-lab-explorer-icon.jpg"/>
  <span class="icon-name">
   Explorer
  </span>
  icon.
 </li>
 <li>
  In the Explorer panel, expand the
  <span class="button-name">
   Workspace (Workspace)
  </span>
  section.
 </li>
 <li>
  Click the
  <span class="csharp public-file-name">
   Research.ipynb
  </span>
  <span class="python public-file-name">
   research.ipynb
  </span>
  file.
 </li>
</ol>

<h3>Run Notebook Cells</h3>
<p>
 Notebooks are a collection of cells where you can execute code snippets or write MarkDown.
</p>
<img alt="Python jupyter notebook interface" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/notebook-cells-py.jpg"/>
<img alt="C# jupyter notebook interface" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/notebook-cells-c.jpg"/>
<p>
 The following describes some helpful keyboard shortcuts to speed up your research:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Keyboard Shortcut
   </th>
   <th>
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <span class="key-combinations">
     Shift+Enter
    </span>
   </td>
   <td>
    Run the selected cell.
   </td>
  </tr>
  <tr>
   <td>
    <span class="key-combinations">
     a
    </span>
   </td>
   <td>
    Insert a cell above the selected cell.
   </td>
  </tr>
  <tr>
   <td>
    <span class="key-combinations">
     b
    </span>
   </td>
   <td>
    Insert a cell below the selected cell.
   </td>
  </tr>
  <tr>
   <td>
    <span class="key-combinations">
     x
    </span>
   </td>
   <td>
    Cut the selected cell.
   </td>
  </tr>
  <tr>
   <td>
    <span class="key-combinations">
     v
    </span>
   </td>
   <td>
    Paste the copied or cut cell.
   </td>
  </tr>
  <tr>
   <td>
    <span class="key-combinations">
     z
    </span>
   </td>
   <td>
    Undo cell actions.
   </td>
  </tr>
 </tbody>
</table>

<h3>Stop Nodes</h3>
<p>
 You need
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/organizations/members#08-Permissions">
  stop node permissions
 </a>
 to stop research nodes in the cloud.
</p>
<p>
 Follow these steps to stop a research node:
</p>
<ol>
 <li>
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
   Open the project
  </a>
  .
 </li>
 <li>
  In the right navigation menu, click the
  <img alt="Resources icon" class="inline-icon" src="https://cdn.quantconnect.com/i/tu/resources-icon.png"/>
  <span class="icon-name">
   Resources
  </span>
  icon.
 </li>
 <li>
  Click the
  <span class="button-name">
   stop
  </span>
  button next to the research node you want to stop.
 </li>
</ol>

<h3>Add Notebooks</h3>
<p>
 Follow these steps to add notebook files to a project:
</p>
<ol>
 <li>
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
   Open the project
  </a>
  .
 </li>
 <li>
  In the right navigation menu, click the
  <img alt="Local lab explorer icon" class="inline-icon" src="https://cdn.quantconnect.com/i/tu/local-lab-explorer-icon.jpg"/>
  <span class="icon-name">
   Explorer
  </span>
  icon.
 </li>
 <li>
  In the Explorer panel, expand the
  <span class="button-name">
   Workspace (Workspace)
  </span>
  section.
 </li>
 <li>
  Click the
  <img alt="Add new file icon" class="inline-icon" src="https://cdn.quantconnect.com/i/tu/new-file-icon.png"/>
  <span class="icon-name">
   New File
  </span>
  icon.
 </li>
 <li>
  Enter
  <span class="public-file-name">
   <span class="placeholder-text">
    fileName
   </span>
   .ipynb
  </span>
  .
 </li>
 <li>
  Press
  <span class="key-combinations">
   Enter
  </span>
  .
 </li>
</ol>
<img alt="Adding a research notebook in Python development environment" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/add-notebook-py.gif"/>
<img alt="Adding a research notebook in C# development environment" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/add-notebook-c.gif"/>

<h3>Rename Notebooks</h3>
<p>
 Follow these steps to rename a notebook in a project:
</p>
<ol>
 <li>
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
   Open the project
  </a>
  .
 </li>
 <li>
  In the right navigation menu, click the
  <img class="inline-icon" src="https://cdn.quantconnect.com/i/tu/local-lab-explorer-icon.jpg"/>
  <span class="icon-name">
   Explorer
  </span>
  icon.
 </li>
 <li>
  In the Explorer panel, right-click the notebook you want to rename and then click
  <span class="menu-name">
   Rename
  </span>
  .
 </li>
 <li>
  Enter the new name and then press
  <span class="button-name">
   Enter
  </span>
  .
 </li>
</ol>

<h3>Delete Notebooks</h3>
<p>
 Follow these steps to delete a notebook in a project:
</p>
<ol>
 <li>
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
   Open the project
  </a>
  .
 </li>
 <li>
  In the right navigation menu, click the
  <img class="inline-icon" src="https://cdn.quantconnect.com/i/tu/local-lab-explorer-icon.jpg"/>
  <span class="icon-name">
   Explorer
  </span>
  icon.
 </li>
 <li>
  In the Explorer panel, right-click the notebook you want to delete and then click
  <span class="menu-name">
   Delete Permanently
  </span>
  .
 </li>
 <li>
  Click
  <span class="button-name">
   Delete
  </span>
  .
 </li>
</ol>

<h3>Learn Jupyter</h3>
<p>
 The following table lists some helpful resources to learn Jupyter:
</p>
<table class="table qc-table">
 <thead>
  <tr>
   <th>
    Type
   </th>
   <th>
    Name
   </th>
   <th>
    Producer
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <i class="fa fa-file-text">
    </i>
    Text
   </td>
   <td>
    <a href="https://www.tutorialspoint.com/jupyter/index.htm" rel="nofollow" target="_BLANK">
     Jupyter Tutorial
    </a>
   </td>
   <td>
    tutorialspoint
   </td>
  </tr>
  <tr>
   <td>
    <i class="fa fa-file-text">
    </i>
    Text
   </td>
   <td>
    <a href="https://www.datacamp.com/tutorial/tutorial-jupyter-notebook" rel="nofollow" target="_BLANK">
     Jupyter Notebook Tutorial: The Definitive Guide
    </a>
   </td>
   <td>
    DataCamp
   </td>
  </tr>
  <tr>
   <td>
    <i class="fa fa-file-text">
    </i>
    Text
   </td>
   <td>
    <a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-dataframe/" rel="nofollow" target="_BLANK">
     An Introduction to DataFrame
    </a>
   </td>
   <td>
    Microsoft Developer Blogs
   </td>
  </tr>
 </tbody>
</table>

<p style="page-break-after: always;">&nbsp;</p>
<section id="1.2"><h3>1.2 Research Engine</h3></section>

<h3>Introduction</h3>
<p>
 The Research Environment is a
 <a href="https://jupyter-notebook.readthedocs.io/en/stable/notebook.html" rel="nofollow" target="_blank">
  Jupyter notebook
 </a>
 -based, interactive commandline environment where you can access our data through the
 <code>
  QuantBook
 </code>
 class. The environment supports both Python and C#. If you use Python, you can import code from the code files in your project into the Research Environment to aid development.
</p>
<p>
 Before you run backtests, we recommend testing your hypothesis in the Research Environment. It's easier to perform data analysis and
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
  produce plots in the Research Environment
 </a>
 than in a backtest.
</p>
<p>
 Before backtesting or live trading with machine learning models, you may find it beneficial to train them in the Research Environment, save them in the ObjectStore, and then load them from the ObjectStore into the backtesting and live trading environment
</p>
<p>
 In the Research Environment, you can also use the QuantConnect API to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/meta-analysis/backtest-analysis">
  import your backtest results
 </a>
 for further analysis.
</p>

<h3>Batch vs Stream Analysis</h3>
<p>
 The backtesting environment is an event-based simulation of the market. Backtests aim to provide an accurate representation of whether a strategy would have performed well in the past, but they are generally slow and aren't the most efficient way to test the foundational ideas behind strategies. You should only use backtests to verify an idea after you have already tested it with statistical analysis.
</p>
<p>
 The Research Environment lets you build a strategy by starting with a central hypothesis about the market. For example, you might hypothesize that an increase in sunshine hours will increase the production of oranges, which will lead to an increase in the supply of oranges and a decrease in the price of Orange Juice Futures. You can attempt to confirm this working hypothesis by analyzing weather data, production of oranges data, and the price of Orange Juice futures. If the hypothesis is confirmed with a degree of statistical significance, you can be confident in the hypothesis and translate it into an algorithm you can backtest.
</p>

<h3>Jupyter Notebooks</h3>
<p>
 Jupyter notebooks support interactive data science and scientific computing across various programming languages. We carry on that philosophy by providing an environment for you to perform exploratory research and brainstorm new ideas for algorithms.  A Jupyter notebook installed in QuantConnect allows you to directly explore the massive amounts of data that is available in the Dataset Market and analyze it with python or C# commands. We call this exploratory notebook environment the Research Environment.
</p>
<h4>
 Open Notebooks
</h4>
<p>
 To open a notebook, open one of the
 <span class="public-file-name">
  .ipynb
 </span>
 files in your
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/files#05-Open-Files">
  cloud projects
 </a>
 or see
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/lean-cli/research#02-Running-Local-Research-Environment">
  Running Local Research Environment
 </a>
 .
</p>
<h4>
 Execute Code
</h4>
<p>
 The notebook allows you to run code in a safe and disposable environment. It's composed of independent cells where you can write, edit, and execute code. The notebooks support Python, C#, and Markdown code.
 <br/>
</p>
<img alt="Jupyter notebook environment" class="docs-image" src="https://www.dropbox.com/s/9yrkap9m7upqzy1/notebook%201.PNG?dl=1" title=""/>
<h4>
 Keyboard Shortcuts
</h4>
<p>
 The following table describes some useful keyboard shortcuts:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Shortcut
   </th>
   <th>
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <span class="key-combinations">
     Shift+Enter
    </span>
   </td>
   <td>
    Run the selected cell
   </td>
  </tr>
  <tr>
   <td>
    <span class="key-combinations">
     a
    </span>
   </td>
   <td>
    Insert a cell above the selected cell
   </td>
  </tr>
  <tr>
   <td>
    <span class="key-combinations">
     b
    </span>
   </td>
   <td>
    Insert a cell below the selected cell
   </td>
  </tr>
  <tr>
   <td>
    <span class="key-combinations">
     x
    </span>
   </td>
   <td>
    Cut the selected cell
   </td>
  </tr>
  <tr>
   <td>
    <span class="key-combinations">
     v
    </span>
   </td>
   <td>
    Paste the copied or cut cell
   </td>
  </tr>
  <tr>
   <td>
    <span class="key-combinations">
     z
    </span>
   </td>
   <td>
    Undo cell actions
   </td>
  </tr>
 </tbody>
</table>
<h4>
 Terminate Research Sessions
</h4>
<p>
 If you use the Research Environment in QuantConnect Cloud, to terminate a research session, stop the research node in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/ide#07-Manage-Nodes">
  Resources panel
 </a>
 . If you use the local Research Environment, see
 <a href="https://jupyterlab.readthedocs.io/en/stable/user/running.html" rel="nofollow" target="_blank">
  Managing Kernels and Terminals
 </a>
 in the JupyterLab documentation.
</p>

<h3>Your Research and LEAN</h3>
<p>
 To analyze data in a research notebook, create an instance of the
 <code>
  QuantBook
 </code>
 class.
 <code>
  QuantBook
 </code>
 is a wrapper on
 <code>
  QCAlgorithm
 </code>
 , which means
 <code>
  QuantBook
 </code>
 allows you to access all the methods available to
 <code>
  QCAlgorithm
 </code>
 and some additional methods. The following table describes the helper methods of the
 <code>
  QuantBook
 </code>
 class that aren't available in the
 <code>
  QCAlgorithm
 </code>
 class:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Method
   </th>
   <th>
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-fundamental-data">
     GetFundamental
    </a>
   </td>
   <td>
    Get fundamental data for some Symbol(s).
   </td>
  </tr>
  <tr class="python">
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/futures">
     GetFutureHistory
    </a>
   </td>
   <td>
    Get the expiration, open interest, and price data of the contracts in a Futures chain.
   </td>
  </tr>
  <tr class="python">
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-options">
     GetOptionHistory
    </a>
   </td>
   <td>
    Get the strike, expiration, open interest, option right, and price data of the contracts in an Options chain.
   </td>
  </tr>
  <tr>
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/indicators">
     Indicator
    </a>
   </td>
   <td>
    Get the values of an indicator for an asset over time.
   </td>
  </tr>
 </tbody>
</table>
<!-- Adjust this table when https://github.com/QuantConnect/Lean/issues/6489 is merged -->
<p>
 QuantBook gives you access to the vast amounts of data in the Dataset Market. Similar to backtesting, you can access that data using history 
calls. You can also create indicators, consolidate data, and access 
charting features. However, keep in mind that event-driven features 
available in backtesting, like universe selection and OnData events, are
 not available in research. After you analyze a dataset in the Research Environment, you can easily transfer the logic to the backtesting environment. For example, consider the following code in the Research Environment:
</p>
<div class="section-example-container">
 <pre class="csharp">// Initialize QuantBook
var qb = new QuantBook();

// Subscribe to SPY data with QuantBook
var symbol = qb.AddEquity("SPY").Symbol;

// Make history call with QuantBook
var history = qb.History(symbol, TimeSpan.FromDays(10), Resolution.Daily);</pre>
 <pre class="python"># Initialize QuantBook
qb = QuantBook()

# Subscribe to SPY data with QuantBook
symbol = qb.AddEquity("SPY").Symbol

# Make history call with QuantBook
history = qb.History(symbol, timedelta(days=10), Resolution.Daily)
</pre>
</div>
<p>
 To use the preceding code in a backtest, replace
 <code class="python">
  QuantBook()
 </code>
 <code class="csharp">
  new QuantBook()
 </code>
 with
 <code class="python">
  self
 </code>
 <code class="csharp">
  this
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">public override void Initialize()
{
    // Set qb to instance of QCAlgorithm
    var qb = this;
    
    // Subscribe to SPY data with QCAlgorithm
    var symbol = qb.AddEquity("SPY").Symbol;
    
    // Make history call with QCAlgorithm
    var history = qb.History(symbol, TimeSpan.FromDays(10), Resolution.Daily);
}</pre>
 <pre class="python">def Initialize(self) -&gt; None:

    # Set qb to instance of QCAlgorithm
    qb = self
    
    # Subscribe to SPY data with QCAlgorithm
    symbol = qb.AddEquity("SPY").Symbol
    
    # Make history call with QCAlgorithm
    history = qb.History(symbol, timedelta(days=10), Resolution.Daily)
</pre>
</div>

<h3>Import Project Code</h3>
<p class="csharp">
 To import code from your code files to your Research Environment session, use Python.
</p>
<p class="python">
 One of the drawbacks of using the Research Environment you may encounter is the need to rewrite code you've already written in a file in the backtesting environment. Instead of rewriting the code, you can import the methods from the backtesting environment into the Research Environment to reduce development time. For example, say you have the following
 <span class="public-file-name">
  helpers.py
 </span>
 file in your project:
</p>
<div class="python">
 <div class="section-example-container">
  <pre class="python">def Add(a, b): 
   return a+b
</pre>
 </div>
</div>
<p class="python">
 To import the preceding method into your research notebook, use the
 <code>
  import
 </code>
 statement.
</p>
<div class="python">
 <div class="section-example-container">
  <pre class="python">from helpers import Add

# reuse method from helpers.py
Add(3, 4)</pre>
 </div>
</div>
<p class="python">
 If you adjust the file that you import, restart the Research Environment session to import the latest version of the file. To restart the Research Environment,
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/key-concepts/getting-started#05-Stop-Nodes">
  stop the research node
 </a>
 and then
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/key-concepts/getting-started#03-Open-Notebooks">
  open the notebook
 </a>
 again.
</p>

<p style="page-break-after: always;">&nbsp;</p>
<section id="2"><h3>2 Initialization</h3></section>

<h3>Introduction</h3>
<p>
 Before you request and manipulate historical data in the Research Environment, you should set the notebook dates, add data subscriptions, and set the time zone.
</p>

<h3>Set Dates</h3>
<p>
 The start date of your
 <code>
  QuantBook
 </code>
 determines the latest date of data you get from
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/key-concepts">
  history requests
 </a>
 . By default, the start date is the current day. To change the start date, call the
 <code>
  SetStartDate
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">qb.SetStartDate(2022, 1, 1);</pre>
 <pre class="python">qb.SetStartDate(2022, 1, 1)</pre>
</div>
<p>
 The end date of your
 <code>
  QuantBook
 </code>
 should be greater than the end date. By default, the start date is the current day. To change the end date, call the
 <code>
  SetEndDate
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">qb.SetEndDate(2022, 8, 15);</pre>
 <pre class="python">qb.SetEndDate(2022, 8, 15)</pre>
</div>

<h3>Add Data</h3>
<p>
 You can subscribe to asset, fundamental, alternative, and custom data. The
 <a href="https://www.quantconnect.com/datasets">
  Dataset Market
 </a>
 provides 400TB of data that you can easily import into your notebooks.
</p>
<h4>
 Asset Data
</h4>
<p>
 To subscribe to asset data, call one of the asset subscription methods like
 <code>
  AddEquity
 </code>
 or
 <code>
  AddForex
 </code>
 . Each asset class has its own method to create subscriptions. For more information about how to create subscriptions for each asset class, see the
 <span class="page-section-name">
  Create Subscriptions
 </span>
 section of an asset class in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/key-concepts">
  Datasets
 </a>
 chapter.
</p>
<div class="section-example-container">
 <pre class="csharp">qb.AddEquity("AAPL"); // Add Apple 1 minute bars (minute by default)
qb.AddForex("EURUSD", Resolution.Second); // Add EURUSD 1 second bars
</pre>
 <pre class="python">qb.AddEquity("SPY")  # Add Apple 1 minute bars (minute by default)
qb.AddForex("EURUSD", Resolution.Second) # Add EURUSD 1 second bars
</pre>
</div>
<h4>
 Alternative Data
</h4>
<p>
 To add alternative datasets to your notebooks, call the
 <code>
  AddData
 </code>
 method.  For a full example, see
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/alternative-data">
  Alternative Data
 </a>
 .
</p>
<h4>
 Custom Data
</h4>
<p>
 To add custom data to your notebooks, call the
 <code>
  AddData
 </code>
 method. For more information about custom data, see
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/custom-data">
  Custom Data
 </a>
 .
</p>
<h4>
 Limitations
</h4>
<p>
 There is no official limit to how much data you can add to your notebooks, but there are practical resource limitations. Each security subscription requires about 5MB of RAM, so larger machines let you request more data. For more information about our cloud nodes, see
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/organizations/resources#03-Research-Nodes">
  Research Nodes
 </a>
 .
</p>

<h3>Set Time Zone</h3>
<p>
 The notebook time zone determines which time zone the
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 objects are in when you make a
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/key-concepts">
  history request
 </a>
 based on a defined period of time.
 <span class="python">
  When your history request returns a
  <code>
   DataFrame
  </code>
  , the timestamps in the
  <code>
   DataFrame
  </code>
  are based on the
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/time-modeling/time-zones#05-Data-Time-Zone">
   data time zone
  </a>
  .
 </span>
 When your history request returns a
 <code>
  TradeBars
 </code>
 ,
 <code>
  QuoteBars
 </code>
 ,
 <code>
  Ticks
 </code>
 , or
 <code>
  Slice
 </code>
 object, the
 <code>
  Time
 </code>
 properties of these objects are based on the notebook time zone, but the
 <code>
  EndTime
 </code>
 properties of the individual
 <code>
  TradeBar
 </code>
 ,
 <code>
  QuoteBar
 </code>
 , and
 <code>
  Tick
 </code>
 objects are based on the data time zone.
</p>
<p>
 The default time zone is Eastern Time (ET), which is UTC-4 in summer and UTC-5 in winter. To set a different time zone, call the
 <code>
  SetTimeZone
 </code>
 method. This method accepts either a string following the
 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" rel="nofollow" target="_blank">
  IANA Time Zone database
 </a>
 convention or a
 <a href="https://nodatime.org/" rel="nofollow" target="_blank">
  NodaTime
 </a>
 .DateTimeZone object. If you pass a string, the method converts it to a
 <code>
  NodaTime.DateTimeZone
 </code>
 object. The
 <code>
  TimeZones
 </code>
 class provides the following helper attributes to create
 <code>
  NodaTime.DateTimeZone
 </code>
 objects:
</p>
<div data-tree="QuantConnect.TimeZones">
</div>
<div class="section-example-container">
 <pre class="csharp">SetTimeZone("Europe/London");
qb.SetTimeZone(NodaTime.DateTimeZone.Utc);
qb.SetTimeZone(TimeZones.Chicago);
</pre>
 <pre class="python">qb.SetTimeZone("Europe/London")
qb.SetTimeZone(TimeZones.Chicago)
</pre>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3"><h3>3 Datasets</h3></section>

<section id="3.1"><h3>3.1 Key Concepts</h3></section>

<h3>Introduction</h3>
<p>
 You can access most of the data from the Dataset Market in the Research Environment. The data includes Equity, Crypto, Forex, and derivative data going back as far as 1998. Similar to backtesting, to access the data, create a security subscription and then make a history request.
</p>

<h3>Key History Concepts</h3>
<p>
 The historical data API has many different options to give you the greatest flexibility in how to apply it to your algorithm.
</p>
<h4>
 Time Period Options
</h4>
<p>
 You can request historical data based on a trailing number of bars, a trailing period of time, or a defined period of time. If you request data in a defined period of time, the
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 objects you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<h4>
 Return Formats
</h4>
<p>
 Each asset class supports slightly different data formats. When you make a history request, consider what data returns. Depending on how you request the data, history requests return a specific data type. For example, if you don't provide
 <code>
  Symbol
 </code>
 objects, you get
 <code>
  Slice
 </code>
 objects that contain all of the assets you created subscriptions for in the notebook.
</p>
<p class="python">
 The most popular return type is a
 <code>
  DataFrame
 </code>
 . If you request a
 <code>
  DataFrame
 </code>
 , LEAN unpacks the data from
 <code>
  Slice
 </code>
 objects to populate the
 <code>
  DataFrame
 </code>
 . If you intend to use the data in the
 <code>
  DataFrame
 </code>
 to create
 <code>
  TradeBar
 </code>
 or
 <code>
  QuoteBar
 </code>
 objects, request that the history request returns the data type you need. Otherwise, LEAN will waste computational resources populating the
 <code>
  DataFrame
 </code>
 .
</p>
<h4>
 Time Index
</h4>
<p>
 <span class="python">
  When your history request returns a
  <code>
   DataFrame
  </code>
  , the timestamps in the
  <code>
   DataFrame
  </code>
  are based on the
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/time-modeling/time-zones#05-Data-Time-Zone">
   data time zone
  </a>
  .
 </span>
 When your history request returns a
 <code>
  TradeBars
 </code>
 ,
 <code>
  QuoteBars
 </code>
 ,
 <code>
  Ticks
 </code>
 , or
 <code>
  Slice
 </code>
 object, the
 <code>
  Time
 </code>
 properties of these objects are based on the notebook time zone, but the
 <code>
  EndTime
 </code>
 properties of the individual
 <code>
  TradeBar
 </code>
 ,
 <code>
  QuoteBar
 </code>
 , and
 <code>
  Tick
 </code>
 objects are based on the
 <span class="python">
  data time zone
 </span>
 <span class="csharp">
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/time-modeling/time-zones#05-Data-Time-Zone">
   data time zone
  </a>
 </span>
 . The
 <code>
  EndTime
 </code>
 is the end of the sampling period and when the data is actually available. For daily US Equity data, this results in data points appearing on Saturday and skipping Monday.
</p>

<h3>Request Data</h3>
<p>
 The simplest form of history request is for a known set of
 <code>
  Symbol
 </code>
 objects.
        History requests return slightly different data depending on the overload you call. The data that returns is in ascending order from oldest to newest.
</p>
<h4>
 Single Symbol History Requests
</h4>
<p>
 To request history for a single asset, pass the asset
 <code>
  Symbol
 </code>
 to the
 <code>
  History
 </code>
 method. The return type of the method call depends on the history request
 <code class="python">
  [Type]
 </code>
 <code class="csharp">
  &lt;Type&gt;
 </code>
 . The following table describes the return type of each request
 <code class="python">
  [Type]
 </code>
 <code class="csharp">
  &lt;Type&gt;
 </code>
 :
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Request Type
   </th>
   <th>
    Return Data Type
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    No argument
   </td>
   <td>
    <code class="python">
     DataFrame
    </code>
    <code class="csharp">
     List&lt;TradeBar&gt;
    </code>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     TradeBar
    </code>
   </td>
   <td>
    <code class="python">
     List[TradeBars]
    </code>
    <code class="csharp">
     List&lt;TradeBar&gt;
    </code>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     QuoteBar
    </code>
   </td>
   <td>
    <code class="python">
     List[QuoteBars]
    </code>
    <code class="csharp">
     List&lt;QuoteBar&gt;
    </code>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Tick
    </code>
   </td>
   <td>
    <code class="python">
     List[Ticks]
    </code>
    <code class="csharp">
     List&lt;Tick&gt;
    </code>
   </td>
  </tr>
  <tr>
   <td>
    <code class="placeholder-text">
     alternativeDataClass
    </code>
    <br/>
    (ex:
    <code>
     CBOE
    </code>
    )
   </td>
   <td>
    <span class="python">
     <code>
      List[
      <span class="placeholder-text">
       alternativeDataClass
      </span>
      ]
     </code>
     <br/>
     (ex:
     <code>
      List[CBOE]
     </code>
     )
    </span>
    <span class="csharp">
     <code>
      List&lt;
      <span class="placeholder-text">
       alternativeDataClass
      </span>
      &gt;
     </code>
     <br/>
     (ex:
     <code>
      List&lt;CBOE&gt;
     </code>
     )
    </span>
   </td>
  </tr>
 </tbody>
</table>
<p class="python">
 Each row of the DataFrame represents the prices at a point in time. Each column of the DataFrame is a property of that price data (for example, open, high, low, and close (OHLC)). If you request a DataFrame object and pass
 <code>
  TradeBar
 </code>
 as the first argument, the DataFrame that returns only contains the OHLC and volume columns. If you request a DataFrame object and pass
 <code>
  QuoteBar
 </code>
 as the first argument, the DataFrame that returns contains the OHLC of the bid and ask and it contains OHLC columns, which are the respective means of the bid and ask OHLC values. If you request a DataFrame and don't pass
 <code>
  TradeBar
 </code>
 or
 <code>
  QuoteBar
 </code>
 as the first arugment, the DataFrame that returns contains columns for all of the data that's available for the given resolution.
</p>
<div class="section-example-container">
 <pre class="python"><b># EXAMPLE 1: Requesting By Bar Count: 5 bars at the security resolution:</b>
vix_symbol = qb.AddData(CBOE, "VIX", Resolution.Daily).Symbol
cboe_data = qb.History[CBOE](vix_symbol, 5)

btc_symbol = qb.AddCrypto("BTCUSD", Resolution.Minute).Symbol
trade_bars = qb.History[TradeBar](btc_symbol, 5)
quote_bars = qb.History[QuoteBar](btc_symbol, 5)
trade_bars_df = qb.History(TradeBar, btc_symbol, 5)
quote_bars_df = qb.History(QuoteBar, btc_symbol, 5)
df = qb.History(btc_symbol, 5)   # Includes trade and quote data
<img alt="Historical minute data dataframe of BTCUSD" class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/i/tu/history-request-single-symbol-1.png"/>
</pre>
 <pre class="csharp"><b>// EXAMPLE 1: Requesting By Bar Count: 5 bars at the security resolution:</b>
var vixSymbol = qb.AddData&lt;CBOE&gt;("VIX", Resolution.Daily).Symbol;
var cboeData = qb.History&lt;CBOE&gt;(vixSymbol, 5);

var btcSymbol = qb.AddCrypto("BTCUSD", Resolution.Minute).Symbol;
var tradeBars = qb.History&lt;TradeBar&gt;(btcSymbol, 5);
var quoteBars = qb.History&lt;QuoteBar&gt;(btcSymbol, 5);
var tradeBars2 = qb.History(btcSymbol, 5);</pre>
 <pre class="python"><b># EXAMPLE 2: Requesting By Bar Count: 5 bars with a specific resolution:</b>
trade_bars = qb.History[TradeBar](btc_symbol, 5, Resolution.Daily)
quote_bars = qb.History[QuoteBar](btc_symbol, 5, Resolution.Minute)
trade_bars_df = qb.History(TradeBar, btc_symbol, 5, Resolution.Minute)
quote_bars_df = qb.History(QuoteBar, btc_symbol, 5, Resolution.Minute)
df = qb.History(btc_symbol, 5, Resolution.Minute)  # Includes trade and quote data
<img alt="Historical minute data dataframe of BTCUSD" class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/i/tu/history-request-single-symbol-1.png"/>
</pre>
 <pre class="csharp"><b>// EXAMPLE 2: Requesting By Bar Count: 5 bars with a specific resolution:</b>
var tradeBars = qb.History&lt;TradeBar&gt;(btcSymbol, 5, Resolution.Daily);
var quoteBars = qb.History&lt;QuoteBar&gt;(btcSymbol, 5, Resolution.Minute);
var tradeBars2 = qb.History(btcSymbol, 5, Resolution.Minute);</pre>
 <pre class="python"><b># EXAMPLE 3: Requesting By a Trailing Period: 3 days of data at the security resolution:</b> 
eth_symbol = qb.AddCrypto('ETHUSD', Resolution.Tick).Symbol
ticks = qb.History[Tick](eth_symbol, timedelta(days=3))
ticks_df = qb.History(eth_symbol, timedelta(days=3))

vix_data = qb.History[CBOE](vix_symbol, timedelta(days=3)) 
trade_bars = qb.History[TradeBar](btc_symbol, timedelta(days=3)) 
quote_bars = qb.History[QuoteBar](btc_symbol, timedelta(days=3))
trade_bars_df = qb.History(TradeBar, btc_symbol, timedelta(days=3))
quote_bars_df = qb.History(QuoteBar, btc_symbol, timedelta(days=3))
df = qb.History(btc_symbol, timedelta(days=3))  # Includes trade and quote data
<img alt="Historical minute data dataframe of BTCUSD" class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/i/tu/history-request-single-symbol-2.png"/>
</pre>
 <pre class="csharp"><b>// EXAMPLE 3: Requesting By a Trailing Period: 3 days of data at the security resolution:</b>
var ethSymbol = qb.AddCrypto("ETHUSD", Resolution.Tick).Symbol;
var ticks = qb.History&lt;Tick&gt;(ethSymbol, TimeSpan.FromDays(3));

var cboeData = qb.History&lt;CBOE&gt;(vixSymbol, TimeSpan.FromDays(3));
var tradeBars = qb.History&lt;TradeBar&gt;(btcSymbol, TimeSpan.FromDays(3));
var quoteBars = qb.History&lt;QuoteBar&gt;(btcSymbol, TimeSpan.FromDays(3));
var tradeBars2 = qb.History(btcSymbol, TimeSpan.FromDays(3));</pre>
 <pre class="python"><b># EXAMPLE 4: Requesting By a Trailing Period: 3 days of data with a specific resolution:</b> 
trade_bars = qb.History[TradeBar](btc_symbol, timedelta(days=3), Resolution.Daily) 
quote_bars = qb.History[QuoteBar](btc_symbol, timedelta(days=3), Resolution.Minute)
ticks = qb.History[Tick](eth_symbol, timedelta(days=3), Resolution.Tick)

trade_bars_df = qb.History(TradeBar, btc_symbol, timedelta(days=3), Resolution.Daily)
quote_bars_df = qb.History(QuoteBar, btc_symbol, timedelta(days=3), Resolution.Minute)
ticks_df = qb.History(eth_symbol, timedelta(days=3), Resolution.Tick)
df = qb.History(btc_symbol, timedelta(days=3), Resolution.Hour)  # Includes trade and quote data
<img alt="Historical hourly data dataframe of BTCUSD" class="img-thumbnail img-responsive" src="https://cdn.quantconnect.com/i/tu/history-request-single-symbol-3.png"/>
# Important Note: Period history requests are relative to "now" notebook time.</pre>
 <pre class="csharp"><b>// EXAMPLE 4: Requesting By a Trailing Period: 3 days of data with a specific resolution:</b>
var tradeBars = qb.History&lt;TradeBar&gt;(btcSymbol, TimeSpan.FromDays(3), Resolution.Daily);
var quoteBars = qb.History&lt;QuoteBar&gt;(btcSymbol, TimeSpan.FromDays(3), Resolution.Minute);
var ticks = qb.History&lt;Tick&gt;(ethSymbol, TimeSpan.FromDays(3), Resolution.Tick);
var tradeBars2 = qb.History(btcSymbol, TimeSpan.FromDays(3), Resolution.Minute);</pre>
 <pre class="python"><b># EXAMPLE 5: Requesting By a Defined Period: 3 days of data at the security resolution:</b> 
start_time = datetime(2022, 1, 1)
end_time = datetime(2022, 1, 4)

vix_data = qb.History[CBOE](vix_symbol, start_time, end_time) 
trade_bars = qb.History[TradeBar](btc_symbol, start_time, end_time) 
quote_bars = qb.History[QuoteBar](btc_symbol, start_time, end_time)
ticks = qb.History[Tick](eth_symbol, start_time, end_time)

trade_bars_df = qb.History(TradeBar, btc_symbol, start_time, end_time)
quote_bars_df = qb.History(QuoteBar, btc_symbol, start_time, end_time)
ticks_df = qb.History(Tick, eth_symbol, start_time, end_time)
df = qb.History(btc_symbol, start_time, end_time)  # Includes trade and quote data
<img alt="Historical minute data dataframe of BTCUSD" class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/i/tu/history-request-defined-period-default-resolution.jpg"/>
</pre>
 <pre class="csharp"><b>// EXAMPLE 5: Requesting By a Defined Period: 3 specific days of data at the security resolution:</b>
var startTime = new DateTime(2022, 1, 1);
var endTime = new DateTime(2022, 1, 4);

var cboeData = qb.History&lt;CBOE&gt;(vixSymbol, startTime, endTime);
var tradeBars = qb.History&lt;TradeBar&gt;(btcSymbol, startTime, endTime);
var quoteBars = qb.History&lt;QuoteBar&gt;(btcSymbol, startTime, endTime);
var ticks = qb.History&lt;Tick&gt;(ethSymbol, startTime, endTime);
var tradeBars2 = qb.History(btcSymbol, startTime, endTime);</pre>
 <pre class="python"><b># EXAMPLE 6: Requesting By a Defined Period: 3 days of data with a specific resolution:</b> 
trade_bars = qb.History[TradeBar](btc_symbol, start_time, end_time, Resolution.Daily) 
quote_bars = qb.History[QuoteBar](btc_symbol, start_time, end_time, Resolution.Minute)
ticks = qb.History[Tick](eth_symbol, start_time, end_time, Resolution.Tick)

trade_bars_df = qb.History(TradeBar, btc_symbol, start_time, end_time, Resolution.Daily)
quote_bars_df = qb.History(QuoteBar, btc_symbol, start_time, end_time, Resolution.Minute)
ticks_df = qb.History(eth_symbol, start_time, end_time, Resolution.Tick)
df = qb.History(btc_symbol, start_time, end_time, Resolution.Hour)  # Includes trade and quote data
<img alt="Historical hourly data dataframe of BTCUSD" class="img-thumbnail img-responsive" src="https://cdn.quantconnect.com/i/tu/history-request-defined-period.jpg"/>
</pre>
 <pre class="csharp"><b>// EXAMPLE 6: Requesting By a Defined Period: 3 days of data with a specific resolution:</b>
var tradeBars = qb.History&lt;TradeBar&gt;(btcSymbol, startTime, endTime, Resolution.Daily);
var quoteBars = qb.History&lt;QuoteBar&gt;(btcSymbol, startTime, endTime, Resolution.Minute);
var ticks = qb.History&lt;Tick&gt;(ethSymbol, startTime, endTime, Resolution.Tick);
var tradeBars2 = qb.History(btcSymbol, startTime, endTime, Resolution.Minute);</pre>
</div>
<h4>
 Multiple Symbol History Requests
</h4>
<p>
 To request history for multiple symbols at a time, pass an array of
 <code>
  Symbol
 </code>
 objects to the same API methods shown in the preceding section. The return type of the method call depends on the history request
 <code class="python">
  [Type]
 </code>
 <code class="csharp">
  &lt;Type&gt;
 </code>
 . The following table describes the return type of each request
 <code class="python">
  [Type]
 </code>
 <code class="csharp">
  &lt;Type&gt;
 </code>
 :
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Request Type
   </th>
   <th>
    Return Data Type
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    No argument
   </td>
   <td>
    <code class="python">
     DataFrame
    </code>
    <code class="csharp">
     List&lt;Slice&gt;
    </code>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     TradeBar
    </code>
   </td>
   <td>
    <code class="python">
     List[TradeBars]
    </code>
    <code class="csharp">
     List&lt;TradeBars&gt;
    </code>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     QuoteBar
    </code>
   </td>
   <td>
    <code class="python">
     List[QuoteBars]
    </code>
    <code class="csharp">
     List&lt;QuoteBars&gt;
    </code>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Tick
    </code>
   </td>
   <td>
    <code class="python">
     List[Ticks]
    </code>
    <code class="csharp">
     List&lt;Ticks&gt;
    </code>
   </td>
  </tr>
  <tr>
   <td>
    <code class="placeholder-text">
     alternativeDataClass
    </code>
    <br/>
    (ex:
    <code>
     CBOE
    </code>
    )
   </td>
   <td>
    <span class="python">
     <code>
      List[Dict[Symbol,
      <span class="placeholder-text">
       alternativeDataClass
      </span>
      ]]
     </code>
     <br/>
     (ex:
     <code>
      List[Dict[Symbol, CBOE]]
     </code>
     )
    </span>
    <span class="csharp">
     <code>
      List&lt;Dictionary&lt;Symbol,
      <span class="placeholder-text">
       alternativeDataClass
      </span>
      &gt;&gt;
     </code>
     <br/>
     (ex:
     <code>
      List&lt;Dictionary&lt;Symbol, CBOE&gt;&gt;
     </code>
     )
    </span>
   </td>
  </tr>
 </tbody>
</table>
<p class="csharp">
 The
 <code>
  Slice
 </code>
 return type provides a container that supports all data types. For example, a history request for Forex
 <code>
  QuoteBars
 </code>
 and Equity
 <code>
  TradeBars
 </code>
 has the Forex data under
 <code>
  slices.QuoteBars
 </code>
 and the Equity data under
 <code>
  slices.Bars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python"><b># EXAMPLE 7: Requesting By Bar Count for Multiple Symbols: 2 bars at the security resolution:</b>
vix = qb.AddData[CBOE]("VIX", Resolution.Daily).Symbol
v3m = qb.AddData[CBOE]("VIX3M", Resolution.Daily).Symbol
cboe_data = qb.History[CBOE]([vix, v3m], 2)

ibm = qb.AddEquity("IBM", Resolution.Minute).Symbol
aapl = qb.AddEquity("AAPL", Resolution.Minute).Symbol
trade_bars_list = qb.History[TradeBar]([ibm, aapl], 2)
quote_bars_list = qb.History[QuoteBar]([ibm, aapl], 2)

trade_bars_df = qb.History(TradeBar, [ibm, aapl], 2)
quote_bars_df = qb.History(QuoteBar, [ibm, aapl], 2)
df = qb.History([ibm, aapl], 2)  # Includes trade and quote data
<img alt="Historical minute data dataframe of IBM &amp; AAPL" class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/i/tu/history-request-single-symbol-4.png"/>
</pre>
 <pre class="csharp"><b>// EXAMPLE 7: Requesting By Bar Count for Multiple Symbols: 2 bars at the security resolution:</b>
var vixSymbol = qb.AddData&lt;CBOE&gt;("VIX", Resolution.Daily).Symbol;
var v3mSymbol = qb.AddData&lt;CBOE&gt;("VIX3m", Resolution.Daily).Symbol;
var cboeData = qb.History&lt;CBOE&gt;(new[] { vix, v3m }, 2);

var ibm = qb.AddEquity("IBM", Resolution.Minute).Symbol;
var aapl = qb.AddEquity("AAPL", Resolution.Minute).Symbol;
var tradeBarsList = qb.History&lt;TradeBar&gt;(new[] { ibm, aapl }, 2);
var quoteBarsList = qb.History&lt;QuoteBar&gt;(new[] { ibm, aapl }, 2);
</pre>
 <pre class="python"><b># EXAMPLE 8: Requesting By Bar Count for Multiple Symbols: 5 bars with a specific resolution:</b>
trade_bars_list = qb.History[TradeBar]([ibm, aapl], 5, Resolution.Daily)
quote_bars_list = qb.History[QuoteBar]([ibm, aapl], 5, Resolution.Minute)

trade_bars_df = qb.History(TradeBar, [ibm, aapl], 5, Resolution.Daily)
quote_bars_df = qb.History(QuoteBar, [ibm, aapl], 5, Resolution.Minute)
df = qb.History([ibm, aapl], 5, Resolution.Daily)  # Includes trade data only. No quote for daily equity data
<img alt="Historical daily data dataframe of IBM &amp; AAPL" class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/i/tu/history-request-single-symbol-5.png"/>
</pre>
 <pre class="csharp"><b>// EXAMPLE 8: Requesting By Bar Count for Multiple Symbols: 5 bars with a specific resolution:</b>
var tradeBarsList = qb.History&lt;TradeBar&gt;(new[] { ibm, aapl }, 5, Resolution.Minute);
var quoteBarsList = qb.History&lt;QuoteBar&gt;(new[] { ibm, aapl }, 5, Resolution.Minute);
</pre>
 <pre class="python"><b># EXAMPLE 9: Requesting By Trailing Period: 3 days of data at the security resolution:</b> 
ticks = qb.History[Tick]([eth_symbol], timedelta(days=3))

trade_bars = qb.History[TradeBar]([btc_symbol], timedelta(days=3)) 
quote_bars = qb.History[QuoteBar]([btc_symbol], timedelta(days=3))
trade_bars_df = qb.History(TradeBar, [btc_symbol], timedelta(days=3))
quote_bars_df = qb.History(QuoteBar, [btc_symbol], timedelta(days=3))
df = qb.History([btc_symbol], timedelta(days=3))  # Includes trade and quote data 
<img alt="Historical minute data dataframe of BTCUSD" class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/i/tu/history-request-single-symbol-6.png"/>
</pre>
 <pre class="csharp"><b>// EXAMPLE 9: Requesting By Trailing Period: 3 days of data at the security resolution:</b>
var ticks = qb.History&lt;Tick&gt;(new[] {ethSymbol}, TimeSpan.FromDays(3));

var tradeBars = qb.History&lt;TradeBar&gt;(new[] {btcSymbol}, TimeSpan.FromDays(3));
var quoteBars = qb.History&lt;QuoteBar&gt;(new[] {btcSymbol}, TimeSpan.FromDays(3));
var tradeBars2 = qb.History(new[] {btcSymbol}, TimeSpan.FromDays(3));</pre>
 <pre class="python"><b># EXAMPLE 10: Requesting By Defined Period: 3 days of data at the security resolution:</b> 
trade_bars = qb.History[TradeBar]([btc_symbol], start_time, end_time) 
quote_bars = qb.History[QuoteBar]([btc_symbol], start_time, end_time)
ticks = qb.History[Tick]([eth_symbol], start_time, end_time)
trade_bars_df = qb.History(TradeBar, btc_symbol, start_time, end_time)
quote_bars_df = qb.History(QuoteBar, btc_symbol, start_time, end_time)
ticks_df = qb.History(Tick, eth_symbol, start_time, end_time)
df = qb.History([btc_symbol], start_time, end_time)  # Includes trade and quote data
<img alt="Historical minute data dataframe of BTCUSD" class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/i/tu/history-request-defined-period-default-resolution.jpg"/>
</pre>
 <pre class="csharp"><b>// EXAMPLE 10: Requesting By Defined Period: 3 days of data at the security resolution:</b>
var tradeBars = qb.History&lt;TradeBar&gt;(new[] {btcSymbol}, startTime, endTime);
var quoteBars = qb.History&lt;QuoteBar&gt;(new[] {btcSymbol}, startTime, endTime);
var ticks = qb.History&lt;Tick&gt;(new[] {ethSymbol}, startTime, endTime);
var tradeBars2 = qb.History(new[] {btcSymbol}, startTime, endTime);</pre>
</div>
<h4>
 All Symbol History Requests
</h4>
<p>
 You can request history for all the securities you have created subscriptions for in your notebook session.  The parameters are very similar to other history method calls, but the return type is an array of
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/time-modeling/timeslices">
  Slice
 </a>
 objects. The
 <code>
  Slice
 </code>
 object holds all of the results in a sorted enumerable collection that you can iterate over with a loop.
</p>
<div class="section-example-container">
 <pre class="python"><b># EXAMPLE 11: Requesting 5 bars for all securities at their respective resolution:</b>

# Create subscriptions
qb.AddEquity("IBM", Resolution.Daily)
qb.AddEquity("AAPL", Resolution.Daily)

# Request history data and enumerate results
slices = qb.History(5)
for s in slices:
    print(str(s.Time) + " AAPL:" + str(s.Bars["AAPL"].Close) + " IBM:" + str(s.Bars["IBM"].Close))
<img alt="Historical daily close price output of IBM &amp; AAPL" class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/i/tu/history-request-single-symbol-7.png"/>
</pre>
 <pre class="csharp"><b>// EXAMPLE 11: Requesting 5 bars for all securities at their respective resolution:</b>

// Set up the universe
qb.AddEquity("IBM", Resolution.Daily);
qb.AddEquity("AAPL", Resolution.Daily);

// Request history data and enumerate results:
var slices = qb.History(5);
foreach (var s in slices) {
    var aaplClose = s.Bars["AAPL"].Close;
    var ibmClose = s.Bars["IBM"].Close;
    Console.WriteLine($"{s.Time} AAPL: {aaplClose} IBM: {ibmClose}");
}
<img alt="Historical daily close price output of IBM &amp; AAPL" class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/i/tu/history-request-single-symbol-9.png"/>
</pre>
</div>
<div class="section-example-container">
 <pre class="python"><b># EXAMPLE 12: Requesting 5 minutes for all securities:</b>

slices = qb.History(timedelta(minutes=5), Resolution.Minute)
for s in slices:
    print(str(s.Time) + " AAPL:" + str(s.Bars["AAPL"].Close) + " IBM:" + str(s.Bars["IBM"].Close))
<img alt="Historical minute close price output of IBM &amp; AAPL" class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/i/tu/history-request-single-symbol-8.png"/>
# timedelta history requests are relative to "now" in notebook Time. If you request this data at 16:05, it returns an empty array because the market is closed.</pre>
 <pre class="csharp"><b>// EXAMPLE 12: Requesting 24 hours of hourly data for all securities:</b>

var slices = qb.History(TimeSpan.FromHours(24), Resolution.Hour);
foreach (var s in slices) {
    var aaplClose = s.Bars["AAPL"].Close;
    var ibmClose = s.Bars["IBM"].Close;
    Console.WriteLine($"{s.Time} AAPL: {aaplClose} IBM: {ibmClose}");
}
<img alt="Historical hourly close price output of IBM &amp; AAPL" class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/i/tu/history-request-single-symbol-10.png"/>
// TimeSpan history requests are relative to "now" in notebook Time.</pre>
</div>
<h4>
 Assumed Default Values
</h4>
<p>
 The following table describes the assumptions of the History API:
</p>
<table class="table qc-table">
 <thead>
  <tr>
   <th>
    Argument
   </th>
   <th>
    Assumption
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    Resolution
   </td>
   <td>
    LEAN guesses the resolution you request by looking at the securities you already have in your notebook. If you have a security subscription in your notebook with a matching
    <code>
     Symbol
    </code>
    , the history request uses the same resolution as the subscription. If you don't have a security subscription in your notebook with a matching
    <code>
     Symbol
    </code>
    ,
    <code>
     Resolution.Minute
    </code>
    is the default.
   </td>
  </tr>
  <tr class="csharp">
   <td>
    Bar type
   </td>
   <td>
    If you don't specify a type for the history request,
    <code>
     TradeBar
    </code>
    is the default. If the asset you request data for doesn't have
    <code>
     TradeBar
    </code>
    data, specify the
    <code>
     QuoteBar
    </code>
    type to receive history.
   </td>
  </tr>
 </tbody>
</table>
<h4>
 Additional Options
</h4>
<p>
 The
 <code>
  History
 </code>
 method accepts the following additional arguments:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Argument
   </th>
   <th>
    Data Type
   </th>
   <th>
    Description
   </th>
   <th>
    Default Value
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <code>
     fillForward
    </code>
   </td>
   <td>
    <code class="csharp">
     bool?
    </code>
    <code class="python">
     bool/NoneType
    </code>
   </td>
   <td>
    True to
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/securities/requesting-data#05-Fill-Forward">
     fill forward
    </a>
    missing data. Otherwise, false.
   </td>
   <td>
    <code class="csharp">
     null
    </code>
    <code class="python">
     None
    </code>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     extendedMarketHours
    </code>
   </td>
   <td>
    <code class="csharp">
     bool?
    </code>
    <code class="python">
     bool/NoneType
    </code>
   </td>
   <td>
    True to include extended market hours data. Otherwise, false.
   </td>
   <td>
    <code class="csharp">
     null
    </code>
    <code class="python">
     None
    </code>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     dataMappingMode
    </code>
   </td>
   <td>
    <code class="csharp">
     DataMappingMode?
    </code>
    <code class="python">
     DataMappingMode/NoneType
    </code>
   </td>
   <td>
    The
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/universes/futures#12-Continous-Contracts">
     contract mapping mode
    </a>
    to use for the security history request.
   </td>
   <td>
    <code class="csharp">
     null
    </code>
    <code class="python">
     None
    </code>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     dataNormalizationMode
    </code>
   </td>
   <td>
    <code class="csharp">
     DataNormalizationMode?
    </code>
    <code class="python">
     DataNormalizationMode/NoneType
    </code>
   </td>
   <td>
    The price scaling mode to use for
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/securities/asset-classes/us-equity/requesting-data#11-Data-Normalization">
     US Equities
    </a>
    or
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/universes/futures#12-Continous-Contracts">
     continuous Futures contracts
    </a>
    . If you don't provide a value, it uses the data normalization mode of the security subscription.
   </td>
   <td>
    <code class="csharp">
     null
    </code>
    <code class="python">
     None
    </code>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     contractDepthOffset
    </code>
   </td>
   <td>
    <code class="csharp">
     int?
    </code>
    <code class="python">
     int/NoneType
    </code>
   </td>
   <td>
    The desired offset from the current front month for
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/universes/futures#12-Continous-Contracts">
     continuous Futures contracts
    </a>
    .
   </td>
   <td>
    <code class="csharp">
     null
    </code>
    <code class="python">
     None
    </code>
   </td>
  </tr>
 </tbody>
</table>
<div class="section-example-container">
 <pre class="python">future = qb.AddFuture(Futures.Currencies.BTC)
history = qb.History(
    tickers=[future.Symbol], 
    start=qb.Time - timedelta(days=15), 
    end=qb.Time, 
    resolution=Resolution.Minute, 
    fillForward=False, 
    extendedMarketHours=False, 
    dataMappingMode=DataMappingMode.OpenInterest, 
    dataNormalizationMode=DataNormalizationMode.Raw, 
    contractDepthOffset=0)</pre>
 <pre class="csharp">var future = qb.AddFuture(Futures.Currencies.BTC);
var history = qb.History(
    symbols: new[] {future.Symbol}, 
    start: qb.Time - TimeSpan.FromDays(15),
    end: qb.Time,
    resolution: Resolution.Minute,
    fillForward: false,
    extendedMarketHours: false,
    dataMappingMode: DataMappingMode.OpenInterest,
    dataNormalizationMode: DataNormalizationMode.Raw,
    contractDepthOffset: 0);</pre>
</div>

<h3>Resolutions</h3>
<p>
 Resolution is the duration of time that's used to sample a data source. The
 <code>
  Resolution
 </code>
 enumeration has the following members:
</p>
<div data-tree="QuantConnect.Resolution">
</div>
<p>
 The default resolution for market data is
 <code>
  Minute
 </code>
 . To set the resolution for a security, pass the
 <code>
  resolution
 </code>
 argument when you create the security subscription.
</p>
<div class="section-example-container">
 <pre class="csharp">qb.AddEquity("SPY", Resolution.Daily);</pre>
 <pre class="python">qb.AddEquity("SPY", Resolution.Daily)</pre>
</div>
<p>
 When you request historical data, the
 <code>
  History
 </code>
 method uses the resolution of your security subscription. To get historical data with a different resolution, pass a
 <code>
  resolution
 </code>
 argument to the
 <code>
  History
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="python">history = qb.History(spy, 10, Resolution.Minute)</pre>
 <pre class="csharp">var history = qb.History(spy, 10, Resolution.Minute);</pre>
</div>

<h3>Markets</h3>
<p>
 The datasets integrated into the Dataset Market cover many markets. The
 <code>
  Market
 </code>
 enumeration has the following members:
</p>
<div data-tree="QuantConnect.Market">
</div>
<p>
 LEAN can usually determine the correct market based on the ticker you provide when you create the security subscription. To manually set the market for a security, pass a
 <code>
  market
 </code>
 argument when you create the security subscription.
</p>
<div class="section-example-container">
 <pre class="csharp">qb.AddEquity("SPY", market: Market.USA);</pre>
 <pre class="python">qb.AddEquity("SPY", market=Market.USA)</pre>
</div>

<h3>Fill Forward</h3>
<p>
 Fill forward means if there is no data point for the current sample, LEAN uses the previous data point. Fill forward is the default data setting. To disable fill forward for a security, set the
 <code>
  fillForward
 </code>
 argument to false when you create the security subscription.
</p>
<div class="section-example-container">
 <pre class="csharp">qb.AddEquity("SPY", fillForward: false);</pre>
 <pre class="python">qb.AddEquity("SPY", fillForward=False)</pre>
</div>
<p>
 When you request historical data, the
 <code>
  History
 </code>
 method uses the fill forward setting of your security subscription. To get historical data with a different fill forward setting, pass a
 <code>
  fillForward
 </code>
 argument to the
 <code>
  History
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">var history = qb.History(qb.Securities.Keys, qb.Time-TimeSpan.FromDays(10), qb.Time, fillForward: true);</pre>
 <pre class="python">history = qb.History(qb.Securities.Keys, qb.Time-timedelta(days=10), qb.Time, fillForward=True)</pre>
</div>

<h3>Extended Market Hours</h3>
<p>
 By default, your security subscriptions only cover regular trading hours. To subscribe to pre and post-market trading hours for a specific asset, enable the
 <code>
  extendedMarketHours
 </code>
 argument when you create the security subscription.
</p>
<div class="section-example-container">
 <pre class="csharp">AddEquity("SPY", extendedMarketHours: true);</pre>
 <pre class="python">self.AddEquity("SPY", extendedMarketHours=True)</pre>
</div>
<p>
 You only receive extended market hours data if you create the subscription with minute, second, or tick resolution. If you create the subscription with daily or hourly resolution, the bars only reflect the regular trading hours.
</p>
<p>
 When you request historical data, the
 <code>
  History
 </code>
 method uses the extended market hours setting of your security subscription. To get historical data with a different extended market hours setting, pass an
 <code>
  extendedMarketHours
 </code>
 argument to the
 <code>
  History
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">var history = qb.History(qb.Securities.Keys, qb.Time-TimeSpan.FromDays(10), qb.Time, extendedMarketHours: false);</pre>
 <pre class="python">history = qb.History(qb.Securities.Keys, qb.Time-timedelta(days=10), qb.Time, extendedMarketHours=False)</pre>
</div>

<h3>Look-Ahead Bias</h3>
<p>
 In the Research Environment, all the historical data is directly available. In backtesting, you can only access the data that is at or before the algorithm time. If you make a history request for the previous 10 days of data in the Research Environment, you get the previous 10 days of data from today's date. If you request the same data in a backtest, you get the previous 10 days of data from the algorithm time.
</p>

<h3>Consolidate Data</h3>
<p>
 History requests usually return data in one of the standard
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/securities/requesting-data#03-Resolutions">
  resolutions
 </a>
 . To analyze data on custom time frames like 5-minute bars or 4-hour bars, you need to aggregate it. Consider an example where you make a history call for minute resolution data and want to create 5-minute resolution data.
 <br/>
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY").Symbol
start_date = datetime(2018, 4, 1)
end_date = datetime(2018, 7, 15)
history = qb.History(symbol, start_date, end_date, Resolution.Minute)</pre>
 <pre class="csharp">var qb = new QuantBook();
var symbol = qb.AddEquity("SPY").Symbol;
var startDate = new DateTime(2018, 4, 1);
var endDate = new DateTime(2018, 7, 15);
var history = qb.History(symbol, startDate, endDate, Resolution.Minute);
foreach (var slice in history)
{
    foreach (var key in slice.Keys)
    {
        Console.WriteLine($"{slice.Time} :: {slice[key].ToString()}");
    }
}</pre>
</div>
<img alt="Historical data of SPY" class="python docs-image" src="https://www.dropbox.com/s/y01mvb29qtaya3e/notebook%2025.PNG?dl=1" title=""/>
<img alt="Historical data of SPY" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/reserach-keyconcept-csharp.png" title=""/>
<p class="python">
 To aggregate the data, use a
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/consolidating-data/getting-started">
  consolidator
 </a>
 or the
 <code>
  pandas
 </code>
 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.resample.html" rel="nofollow" target="_blank">
  resample
 </a>
 method.
 <br/>
</p>
<p class="csharp">
 To aggregate the data, use a
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/consolidating-data/getting-started">
  consolidator
 </a>
 .
 <br/>
</p>
<h4 class="python">
 Consolidators
</h4>
<p class="python">
 The following snippet demonstrates how to use a consolidator to aggregate data:
</p>
<div class="section-example-container">
 <pre class="csharp">// Set up a consolidator and a RollingWindow to save the data
var consolidator = new TradeBarConsolidator(TimeSpan.FromDays(7));
var window = new RollingWindow&lt;TradeBar&gt;(20);

// Attach a consolidation handler method that saves the consolidated bars in the RollingWindow
consolidator.DataConsolidated += (sender, consolidated) =&gt;
{
    window.Add(consolidated);
};

// Iterate the historical market data and feed each bar into the consolidator
foreach(var bar in history)
{
    consolidator.Update(bar);
}</pre>
 <pre class="python"># Set up a consolidator and a RollingWindow to save the data
consolidator = TradeBarConsolidator(timedelta(7))
window = RollingWindow[TradeBar](20)

# Attach a consolidation handler method that saves the consolidated bars in the RollingWindow   
consolidator.DataConsolidated += lambda _, bar: window.Add(bar)

# Iterate the historical market data and feed each bar into the consolidator
for bar in history.itertuples():
    tradebar = TradeBar(bar.Index[1], bar.Index[0], bar.open, bar.high, bar.low, bar.close, bar.volume)
    consolidator.Update(tradebar)</pre>
</div>
<h4 class="python">
 Resample Method
</h4>
<p class="python">
 The
 <code>
  resample
 </code>
 method converts the frequency of a time series DataFrame into a custom frequency. The method only works on DataFrame objects that have a
 <code>
  datetime
 </code>
 index. The
 <code>
  History
 </code>
 method returns a DataFrame with a multi-index. The first index is a
 <code>
  Symbol
 </code>
 index for each security and the second index is a time index for the timestamps of each row of data. To make the DataFrame compatible with the
 <code>
  resample
 </code>
 method, call the
 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.reset_index.html">
  reset_index
 </a>
 method to drop the
 <code>
  Symbol
 </code>
 index.
</p>
<div class="python">
 <div class="section-example-container">
  <pre class="python"># Drop level 0 index (Symbol index) from the DataFrame
history.reset_index(level = 0, drop = True, inplace=True)
</pre>
 </div>
</div>
<img alt="Historical data of SPY (dropped column level 0)" class="python docs-image" src="https://www.dropbox.com/s/7f86n9w82rya8vr/notebook%2023.PNG?dl=1" title=""/>
<p class="python">
 The
 <code>
  resample
 </code>
 method returns a
 <code>
  Resampler
 </code>
 object, which needs to be downsampled using one of the pandas
 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/resampling.html" rel="nofollow" target="_blank">
  downsampling computations
 </a>
 . For example, you can use the
 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.resample.Resampler.ohlc.html" rel="nofollow" target="_blank">
  Resampler.ohlc
 </a>
 downsampling method to aggregate price data.
</p>
<p class="python">
 When you resample a DataFrame with the
 <code>
  ohlc
 </code>
 downsampling method, it creates an OHLC row for each column in the DataFrame. To just calculate the OHLC of the close column, select the close column before you resample the DataFrame. A resample offset of 5T corresponds to a 5-minute resample. Other resampling offsets include 2D = 2 days, 5H = 5 hours, and 3S = 3 seconds.
</p>
<div class="python">
 <div class="section-example-container">
  <pre class="python">close_prices = history["close"]

offset = "5T" 
close_5min_ohlc = close_prices.resample(offset).ohlc()
</pre>
 </div>
</div>
<img alt="Resampled 5-minute interval historical OHLC of SPY" class="python docs-image" src="https://www.dropbox.com/s/t7vrv4ofiupbtzk/notebook%2024.PNG?dl=1" title=""/>

<h3>Common Errors</h3>
<p class="python">
 If the history request returns an empty DataFrame and you try to slice it, it throws an exception. To avoid issues, check if the DataFrame contains data before slicing it.
</p>
<div class="python section-example-container">
 <pre class="python">df = qb.History(symbol, 10).close    # raises exception if the request is empty

def GetSafeHistoryCloses(symbols):
    if not symbols:
        print(f'No symbols')
        return  False, None
    df = qb.History(symbols, 100, Resolution.Daily)
    if df.empty:
        print(f'Empy history for {symbols}')
        return  False, None
     return True, df.close.unstack(0)</pre>
</div>
<p>
 If you run the Research Environment on your local machine and history requests return no data, check if your
 <span class="public-file-name">
  data
 </span>
 directory contains the data you request. To download datasets, see
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/datasets/licensing#04-Download">
  Download
 </a>
 .
</p>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.2"><h3>3.2 US Equity</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical US Equity data.
</p>

<h3>Create Subscriptions</h3>
<p>
 Follow these steps to subscribe to a US Equity security:
</p>
<ol>
 <li class="csharp">
  Load the required assembly files and data types.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Algorithm;
using QuantConnect.Research;
using QuantConnect.Indicators;
using Microsoft.Data.Analysis;</pre>
 </div>
 <li>
  Create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Call the
  <code>
   AddEquity
  </code>
  method with a ticker and then save a reference to the US Equity
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var spy = qb.AddEquity("SPY").Symbol;
var tlt = qb.AddEquity("TLT").Symbol;</pre>
  <pre class="python">spy = qb.AddEquity("SPY").Symbol
tlt = qb.AddEquity("TLT").Symbol</pre>
 </div>
</ol>
<p>
 To view the supported assets in the US Equities dataset, see the
 <a href="/https://www.quantconnect.com/docs/v2/data/tree/equity/usa/daily">
  Data Explorer
 </a>
 .
</p>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#03-Create-Subscriptions">
  subscription
 </a>
 before you can request historical data for a security. On the time dimension, you can request an amount of historical data based on a trailing number of bars, a trailing period of time, or a defined period of time. On the security dimension, you can request historical data for a single US Equity, a subset of the US Equities you created subscriptions for in your notebook, or all of the US Equities in your notebook.
</p>
<h4>
 Trailing Number of Bars
 <br/>
</h4>
<p>
 To get historical data for a number of trailing bars, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s) and an integer.
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(spy, 10);
var subsetHistorySlice = qb.History(new[] {spy, tlt}, 10);
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(spy, 10);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {spy, tlt}, 10);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, 10);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(spy, 10);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {spy, tlt}, 10);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, 10);</pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History(spy, 10)
subset_history_df = qb.History([spy, tlt], 10)
all_history_df = qb.History(qb.Securities.Keys, 10)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, spy, 10)
subset_history_trade_bar_df = qb.History(TradeBar, [spy, tlt], 10)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, 10)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, spy, 10)
subset_history_quote_bar_df = qb.History(QuoteBar, [spy, tlt], 10)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, 10)

# Slice objects
all_history_slice = qb.History(10)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](spy, 10)
subset_history_trade_bars = qb.History[TradeBar]([spy, tlt], 10)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, 10)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](spy, 10)
subset_history_quote_bars = qb.History[QuoteBar]([spy, tlt], 10)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, 10)</pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Trailing Period of Time
 <br/>
</h4>
<p>
 To get historical data for a trailing period of time, call the
 <code>
  History
 </code>
 method with the
 <code style="font-size: 15px; background-color: rgb(255, 255, 255);">
  Symbol
 </code>
 object(s) and a
 <code class="csharp">
  TimeSpan
 </code>
 <code class="python">
  timedelta
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(spy, TimeSpan.FromDays(3));
var subsetHistorySlice = qb.History(new[] {spy, tlt}, TimeSpan.FromDays(3));
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(spy, TimeSpan.FromDays(3));
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {spy, tlt}, TimeSpan.FromDays(3));
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(TimeSpan.FromDays(3));

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(spy, TimeSpan.FromDays(3), Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {spy, tlt}, TimeSpan.FromDays(3), Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Minute);

// Tick objects
var singleHistoryTicks = qb.History&lt;Tick&gt;(spy, TimeSpan.FromDays(3), Resolution.Tick);
var subsetHistoryTicks = qb.History&lt;Tick&gt;(new[] {spy, tlt}, TimeSpan.FromDays(3), Resolution.Tick);<br/>var allHistoryTicks = qb.History&lt;Tick&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Tick);<br/></pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History(spy, timedelta(days=3))
subset_history_df = qb.History([spy, tlt], timedelta(days=3))
all_history_df = qb.History(qb.Securities.Keys, timedelta(days=3))

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, spy, timedelta(days=3))
subset_history_trade_bar_df = qb.History(TradeBar, [spy, tlt], timedelta(days=3))
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, spy, timedelta(days=3))
subset_history_quote_bar_df = qb.History(QuoteBar, [spy, tlt], timedelta(days=3))
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of tick data
single_history_tick_df = qb.History(spy, timedelta(days=3), Resolution.Tick)
subset_history_tick_df = qb.History([spy, tlt], timedelta(days=3), Resolution.Tick)
all_history_tick_df = qb.History(qb.Securities.Keys, timedelta(days=3), Resolution.Tick)

# Slice objects
all_history_slice = qb.History(timedelta(days=3))

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](spy, timedelta(days=3))
subset_history_trade_bars = qb.History[TradeBar]([spy, tlt], timedelta(days=3))
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, timedelta(days=3))

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](spy, timedelta(days=3), Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([spy, tlt], timedelta(days=3), Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, timedelta(days=3), Resolution.Minute)

# Tick objects
single_history_ticks = qb.History[Tick](spy, timedelta(days=3), Resolution.Tick)
subset_history_ticks = qb.History[Tick]([spy, tlt], timedelta(days=3), Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, timedelta(days=3), Resolution.Tick)</pre>
</div>
<p>
 The preceding calls return the most recent bars or ticks, excluding periods of time when the exchange was closed.
</p>
<h4>
 Defined Period of Time
 <br/>
</h4>
<p>
 To get historical data for a specific period of time, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s), a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 . The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2021, 1, 1);
var endTime = new DateTime(2021, 2, 1);

// Slice objects
var singleHistorySlice = qb.History(spy, startTime, endTime);
var subsetHistorySlice = qb.History(new[] {spy, tlt}, startTime, endTime);
var allHistorySlice = qb.History(qb.Securities.Keys, startTime, endTime);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(spy, startTime, endTime);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {spy, tlt}, startTime, endTime);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, startTime, endTime);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(spy, startTime, endTime, Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {spy, tlt}, startTime, endTime, Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Minute);

// Tick objects
var singleHistoryTicks = qb.History&lt;Tick&gt;(spy, startTime, endTime, Resolution.Tick);
var subsetHistoryTicks = qb.History&lt;Tick&gt;(new[] {spy, tlt}, startTime, endTime, Resolution.Tick);
var allHistoryTicks = qb.History&lt;Tick&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Tick);</pre>
 <pre class="python">start_time = datetime(2021, 1, 1)
end_time = datetime(2021, 2, 1)

# DataFrame of trade and quote data
single_history_df = qb.History(spy, start_time, end_time)
subset_history_df = qb.History([spy, tlt], start_time, end_time)
all_history_df = qb.History(qb.Securities.Keys, start_time, end_time)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, spy, start_time, end_time)
subset_history_trade_bar_df = qb.History(TradeBar, [spy, tlt], start_time, end_time)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, spy, start_time, end_time)
subset_history_quote_bar_df = qb.History(QuoteBar, [spy, tlt], start_time, end_time)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of tick data
single_history_tick_df = qb.History(spy, start_time, end_time, Resolution.Tick)
subset_history_tick_df = qb.History([spy, tlt], start_time, end_time, Resolution.Tick)
all_history_tick_df = qb.History(qb.Securities.Keys, start_time, end_time, Resolution.Tick)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](spy, start_time, end_time)
subset_history_trade_bars = qb.History[TradeBar]([spy, tlt], start_time, end_time)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, start_time, end_time)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](spy, start_time, end_time, Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([spy, tlt], start_time, end_time, Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, start_time, end_time, Resolution.Minute)

# Tick objects
single_history_ticks = qb.History[Tick](spy, start_time, end_time, Resolution.Tick)
subset_history_ticks = qb.History[Tick]([spy, tlt], start_time, end_time, Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, start_time, end_time, Resolution.Tick)</pre>
</div>
<p>
 The preceding calls return the bars or ticks that have a timestamp within the defined period of time.
</p>

<h3>Resolutions</h3>
<p>
 The following table shows the available resolutions and data formats for Equity subscriptions:
</p>
<table class="qc-table table" id="resolution-and-data-formats">
 <thead>
  <tr>
   <th>
    Resolution
   </th>
   <th>
    TradeBar
   </th>
   <th>
    QuoteBar
   </th>
   <th>
    Trade Tick
   </th>
   <th>
    Quote Tick
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <code>
     Tick
    </code>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Second
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Minute
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Hour
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Daily
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
 </tbody>
</table>
<style>
 #resolution-and-data-formats td:nth-child(2), 
#resolution-and-data-formats th:nth-child(2), 
#resolution-and-data-formats td:nth-child(3), 
#resolution-and-data-formats th:nth-child(3), 
#resolution-and-data-formats td:nth-child(4), 
#resolution-and-data-formats th:nth-child(4), 
#resolution-and-data-formats td:last-child, 
#resolution-and-data-formats th:last-child {
    text-align: center;
}
</style>

<h3>Markets</h3>
<p>
 LEAN groups all of the US Equity exchanges under
 <code>
  Market.USA
 </code>
 .
</p>

<h3>Data Normalization</h3>
<p>
 The data normalization mode defines how historical data is adjusted for
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/securities/asset-classes/us-equity/corporate-actions">
  corporate actions
 </a>
 . By default, LEAN adjusts US Equity data for splits and dividends to produce a smooth price curve, but the following data normalization modes are available:
</p>
<div data-fields="Raw,Adjusted,SplitAdjusted,TotalReturn" data-tree="QuantConnect.DataNormalizationMode">
</div>
<p>
 We use the entire split and dividend history to adjust historical prices. This process ensures you get the same adjusted prices, 
    regardless of the
 <code>
  QuantBook
 </code>
 time.
</p>
<p>
 To set the data normalization mode for a security, pass a
 <code>
  dataNormalizationMode
 </code>
 argument to the
 <code>
  AddEquity
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">var spy = qb.AddEquity("SPY", dataNormalizationMode: DataNormalizationMode.Raw).Symbol;</pre>
 <pre class="python">spy = qb.AddEquity("SPY", dataNormalizationMode=DataNormalizationMode.Raw).Symbol</pre>
</div>
<p>
 When you request historical data, the
 <code>
  History
 </code>
 method uses the data normalization of your security subscription. To get historical data with a different data normalization, pass a
 <code>
  dataNormalizationMode
 </code>
 argument to the
 <code>
  History
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">var history = qb.History(qb.Securities.Keys, qb.Time-TimeSpan.FromDays(10), qb.Time, dataNormalizationMode: DataNormalizationMode.SplitAdjusted);</pre>
 <pre class="python">history = qb.History(qb.Securities.Keys, qb.Time-timedelta(days=10), qb.Time, dataNormalizationMode=DataNormalizationMode.SplitAdjusted)</pre>
</div>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. The process to manipulate the historical data depends on its data type. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data. The process to manipulate the historical data depends on its data type.
</p>
<h4>
 DataFrame Objects
</h4>
<p class="python">
 If the
 <code>
  History
 </code>
 method returns a
 <code>
  DataFrame
 </code>
 , the first level of the
 <code>
  DataFrame
 </code>
 index is the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/security-identifiers#02-Encoding-Symbols">
  encoded Equity Symbol
 </a>
 and the second level is the
 <code>
  EndTime
 </code>
 of the data sample. The columns of the
 <code>
  DataFrame
 </code>
 are the data properties.
</p>
<img alt="DataFrame of two Equities" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-research-data-1.jpg"/>
<p class="python">
 To select the historical data of a single Equity, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the Equity
 <code>
  Symbol
 </code>
 .
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[spy]  # or all_history_df.loc['SPY']
</pre>
</div>
<img alt="DataFrame of one Equity" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-research-data-2.jpg"/>
<p class="python">
 To select a column of the
 <code>
  DataFrame
 </code>
 , index it with the column name.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[spy]['close']
</pre>
</div>
<img alt="Series of close values" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-research-data-3.jpg"/>
<p class="python">
 If you request historical data for multiple Equities, you can transform the
 <code>
  DataFrame
 </code>
 so that it's a time series of close values for all of the Equities. To transform the
 <code>
  DataFrame
 </code>
 , select the column you want to display for each Equity and then call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html" rel="nofollow" target="_blank">
  unstack
 </a>
 method.
</p>
<div class="section-example-container python">
 <pre class="python">all_history_df['close'].unstack(level=0)</pre>
</div>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 is transformed so that the column indices are the
 <code>
  Symbol
 </code>
 of each Equity and each row contains the close value.
</p>
<img alt="DataFrame of one Equity" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-research-data-4.jpg"/>
<p class="python">
 If you prefer to display the ticker of each
 <code>
  Symbol
 </code>
 instead of the string representation of the
 <code>
  SecurityIdentifier
 </code>
 , follow these steps:
</p>
<ol class="python">
 <li>
  Create a dictionary where the keys are the string representations of each
  <code>
   SecurityIdentifier
  </code>
  and the values are the ticker.
 </li>
 <div class="section-example-container python">
  <pre class="python">tickers_by_id = {str(x.ID): x.Value for x in qb.Securities.Keys}</pre>
 </div>
 <li>
  Get the values of the symbol level of the
  <code>
   DataFrame
  </code>
  index and create a list of tickers.
 </li>
 <div class="section-example-container python">
  <pre class="python">tickers = set([tickers_by_id[x] for x in all_history_df.index.get_level_values('symbol')])</pre>
 </div>
 <li>
  Set the values of the symbol level of the
  <code>
   DataFrame
  </code>
  index to the list of tickers.
 </li>
 <div class="section-example-container python">
  <pre class="python">all_history_df.index.set_levels(tickers, 'symbol', inplace=True)</pre>
 </div>
</ol>
<p class="python">
 The new
 <code>
  DataFrame
 </code>
 is keyed by the ticker.
</p>
<div class="section-example-container python">
 <pre class="python">all_history_df.loc[spy.Value]  # or all_history_df.loc["SPY"]  </pre>
</div>
<p class="python">
 After the index renaming, the unstacked
 <code>
  DataFrame
 </code>
 has the following format:
</p>
<img alt="Historical data dataframe of selected attribute by symbols" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-research-data-5.jpg"/>
<p class="csharp">
 The historical data methods don't return DataFrame objects, but you can create one for efficient vectorized data wrangling.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">using Microsoft.Data.Analysis; 

var columns = new DataFrameColumn[] {
    new PrimitiveDataFrameColumn<datetime>("Time", history.Select(x =&gt; x[spy].EndTime)),
    new DecimalDataFrameColumn("SPY Open", history.Select(x =&gt; x[spy].Open)),
    new DecimalDataFrameColumn("SPY High", history.Select(x =&gt; x[spy].High)),
    new DecimalDataFrameColumn("SPY Low", history.Select(x =&gt; x[spy].Low)),
    new DecimalDataFrameColumn("SPY Close", history.Select(x =&gt; x[spy].Close))
};
var df = new DataFrame(columns);
df</datetime></pre>
</div>
<img alt="Historical C# dataframe" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-research-data-c-1.jpg"/>
<p class="csharp">
 To select a particular column of the DataFrame, index it with the column name.
</p>
<div class="section-example-container">
 <pre class="csharp">df["SPY close"]</pre>
</div>
<img alt="Historical C# dataframe column" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-research-data-c-2.jpg"/>
<h4>
 Slice Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Slice
 </code>
 objects, iterate through the
 <code>
  Slice
 </code>
 objects to get each one. The
 <code>
  Slice
 </code>
 objects may not have data for all of your Equity subscriptions. To avoid issues, check if the
 <code>
  Slice
 </code>
 contains data for your Equity before you index it with the Equity
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice) {
    if (slice.Bars.ContainsKey(spy))
    {
        var tradeBar = slice.Bars[spy];
    }
    if (slice.QuoteBars.ContainsKey(spy))
    {
        var quoteBar = slice.QuoteBars[spy];
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
        if slice.Bars.ContainsKey(spy):
        trade_bar = slice.Bars[spy]
    if slice.QuoteBars.ContainsKey(spy):
        quote_bar = slice.QuoteBars[spy]
</pre>
</div>
<!---- ----->
<p>
 You can also iterate through each
 <code>
  TradeBar
 </code>
 and
 <code>
  QuoteBar
 </code>
 in the
 <code>
  Slice
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice)
{
    foreach (var kvp in slice.Bars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
    foreach (var kvp in slice.QuoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
    for kvp in slice.Bars:
        symbol = kvp.Key
        trade_bar = kvp.Value
    for kvp in slice.QuoteBars:
        symbol = kvp.Key
        quote_bar = kvp.Value
</pre>
</div>
<p class="csharp">
 You can also use LINQ to select each
 <code>
  TradeBar
 </code>
 in the
 <code>
  Slice
 </code>
 for a given
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">
var tradeBars = allHistorySlice.Where(slice =&gt; slice.Bars.ContainsKey(spy)).Select(slice =&gt; slice.Bars[spy]);
</pre>
</div>
<!---- ----->
<h4>
 TradeBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBar
 </code>
 objects, iterate through the
 <code>
  TradeBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBar in singleHistoryTradeBars)
{
    Console.WriteLine(tradeBar);
}</pre>
 <pre class="python">for trade_bar in single_history_trade_bars:
    print(trade_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBars
 </code>
 , iterate through the
 <code>
  TradeBars
 </code>
 to get the
 <code>
  TradeBar
 </code>
 of each Equity. The
 <code>
  TradeBars
 </code>
 may not have data for all of your Equity subscriptions. To avoid issues, check if the
 <code>
  TradeBars
 </code>
 object contains data for your security before you index it with the Equity
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    if (tradeBars.ContainsKey(spy))
    {
        var tradeBar = tradeBars[spy];
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    if trade_bars.ContainsKey(spy):
        trade_bar = trade_bars[spy]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  TradeBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    foreach (var kvp in tradeBars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    for kvp in trade_bars:
        symbol = kvp.Key
        trade_bar = kvp.Value<br/></pre>
</div>
<!---- ----->
<h4>
 QuoteBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBar
 </code>
 objects, iterate through the
 <code>
  QuoteBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBar in singleHistoryQuoteBars)
{
    Console.WriteLine(quoteBar);
}</pre>
 <pre class="python">for quote_bar in single_history_quote_bars:
    print(quote_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBars
 </code>
 , iterate through the
 <code>
  QuoteBars
 </code>
 to get the
 <code>
  QuoteBar
 </code>
 of each Equity. The
 <code>
  QuoteBars
 </code>
 may not have data for all of your Equity subscriptions. To avoid issues, check if the
 <code>
  QuoteBars
 </code>
 object contains data for your security before you index it with the Equity
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    if (quoteBars.ContainsKey(spy))
    {
        var quoteBar = quoteBars[spy];
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    if quote_bars.ContainsKey(spy):
        quote_bar = quote_bars[spy]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  QuoteBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    foreach (var kvp in quoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    for kvp in quote_bars:
        symbol = kvp.Key
        quote_bar = kvp.Value</pre>
</div>
<!---- ----->
<h4>
 Tick Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Tick
 </code>
 objects, iterate through the
 <code>
  Tick
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tick in singleHistoryTicks)
{
    Console.WriteLine(tick);
}</pre>
 <pre class="python">for tick in single_history_ticks:
    print(tick)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Ticks
 </code>
 , iterate through the
 <code>
  Ticks
 </code>
 to get the
 <code>
  Tick
 </code>
 of each Equity. The
 <code>
  Ticks
 </code>
 may not have data for all of your Equity subscriptions. To avoid issues, check if the
 <code>
  Ticks
 </code>
 object contains data for your security before you index it with the Equity
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    if (ticks.ContainsKey(spy))
    {
        var tick = ticks[spy];
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    if ticks.ContainsKey(spy):
        ticks = ticks[spy]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  Ticks
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    foreach (var kvp in ticks)
    {
        var symbol = kvp.Key;
        var tick = kvp.Value;
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    for kvp in ticks:
        symbol = kvp.Key
        tick = kvp.Value</pre>
</div>
<!---- ----->
<!---- ----->
<!---- ----->

<h3>Plot Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  historical Equity data
 </a>
 to produce plots. You can use
 <span class="python">
  many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
 </span>
 <span class="csharp">
  <code>
   Plot.NET
  </code>
  package
 </span>
 to visualize data in various formats. For example, you can plot candlestick and line charts.
</p>
<h4>
 Candlestick Chart
 <br/>
</h4>
<p>
 Follow these steps to plot candlestick charts:
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(spy, datetime(2021, 11, 23), datetime(2021, 12, 8), Resolution.Daily).loc[spy]</pre>
  <pre class="csharp">var history = qb.History&lt;TradeBar&gt;(spy, new DateTime(2021, 11, 23), new DateTime(2021, 12, 8), Resolution.Daily);</pre>
 </div>
 <li>
  Import the
  <code class="python">
   plotly
  </code>
  <code class="csharp">
   Plotly.NET
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">import plotly.graph_objects as go</pre>
  <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
 <li>
  Create a
  <code>
   Candlestick
  </code>
  chart.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">candlestick = go.Candlestick(x=history.index,
                             open=history['open'],
                             high=history['high'],
                             low=history['low'],
                             close=history['close'])</pre>
  <pre class="csharp">var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    history.Select(x =&gt; x.Open),
    history.Select(x =&gt; x.High),
    history.Select(x =&gt; x.Low),
    history.Select(x =&gt; x.Close),
    history.Select(x =&gt; x.EndTime)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">layout = go.Layout(title=go.layout.Title(text='SPY OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init("SPY Price");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="python">
  Create the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig = go.Figure(data=[candlestick], layout=layout)</pre>
  <pre class="csharp">chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Candlestick charts display the open, high, low, and close prices of the security.
 </p>
</ol>
<img alt="Candlestick plot of SPY OHLC" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/reserachhistoryequityonesecuritycandlestickplot.png"/>
<img alt="Candlestick plot of SPY OHLC" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/reserachhistoryequityonesecuritycandlestickplotcsharp.png"/>
<h4>
 Line Chart
</h4>
<p>
 Follow these steps to plot line charts using
 <span class="python">
  built-in methods
 </span>
 <span class="csharp">
  <code>
   Plotly.NET
  </code>
  package
 </span>
 :
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History([spy, tlt], datetime(2021, 11, 23), datetime(2021, 12, 8), Resolution.Daily)</pre>
  <pre class="csharp">var history = qb.History&lt;TradeBar&gt;(new [] {spy, tlt}, new DateTime(2021, 11, 23), new DateTime(2021, 12, 8), Resolution.Daily);</pre>
 </div>
 <li>
  Select the data to plot.
 </li>
 <div class="section-example-container">
  <pre class="python">volume = history['volume'].unstack(level=0)</pre>
  <pre class="csharp">var spy = history.Select(x =&gt; x["SPY"]);</pre>
 </div>
 <li class="python">
  Call the
  <code>
   plot
  </code>
  method on the
  <code>
   pandas
  </code>
  object.
 </li>
 <li class="csharp">
  Create a
  <code>
   Line
  </code>
  chart.
 </li>
 <div class="section-example-container">
  <pre class="python">volume.plot(title="Volume", figsize=(15, 10))</pre>
  <pre class="csharp">var chart = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    spy.Select(x =&gt; x.EndTime),
    spy.Select(x =&gt; x.Volume)
);</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Volume");
Title title = Title.init("SPY Volume");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Line charts display the value of the property you selected in a time series.
 </p>
</ol>
<img class="python docs-image" rel="Line chart of volume for SPY and TLT" src="https://cdn.quantconnect.com/i/tu/research-env-plot-equity-data.jpg"/>
<img class="csharp docs-image" rel="Line chart of volume for SPY" src="https://cdn.quantconnect.com/i/tu/research-env-plot-equity-data-csharp.png"/>

<h3>Common Errors</h3>
<p>
 Some factor files have INF split values, which indicate that the stock has so many splits that prices can't be calculated with correct numerical precision. To allow history requests with these symbols, we need to move the starting date forward when reading the data. If there are numerical precision errors in the factor files for a security in your history request, LEAN throws the following error:
</p>
<div class="error-messages">
 "Warning: when performing history requests, the start date will be adjusted if there are numerical precision errors in the factor files."
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.3"><h3>3.3 Equity Fundamental Data</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical Equity Fundamental data. Corporate fundamental data is available through the
 <a href="https://www.quantconnect.com/datasets/morning-star-us-fundamentals">
  US Fundamental Data from Morningstar
 </a>
 .
</p>

<h3>Create Subscriptions</h3>
<p>
 Follow these steps to subscribe to an Equity security:
</p>
<ol>
 <li class="csharp">
  Load the required assembly files and data types.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Algorithm;
using QuantConnect.Research;
using QuantConnect.Indicators;
using Microsoft.Data.Analysis;</pre>
 </div>
 <li>
  Create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Call the
  <code>
   AddEquity
  </code>
  method with a ticker and then save a reference to the Equity
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var symbols = new [] 
    {
        "AAL",  // American Airlines Group, Inc.
        "ALGT", // Allegiant Travel Company
        "ALK",  // Alaska Air Group, Inc.
        "DAL",  // Delta Air Lines, Inc.
        "LUV",  // Southwest Airlines Company
        "SKYW", // SkyWest, Inc.
        "UAL"   // United Air Lines
    }
    .Select(ticker =&gt; qb.AddEquity(ticker).Symbol);</pre>
  <pre class="python">symbols = [qb.AddEquity(ticker).Symbol
    for ticker in [
        "AAL",   # American Airlines Group, Inc.
        "ALGT",  # Allegiant Travel Company
        "ALK",   # Alaska Air Group, Inc.
        "DAL",   # Delta Air Lines, Inc.
        "LUV",   # Southwest Airlines Company
        "SKYW",  # SkyWest, Inc.
        "UAL"    # United Air Lines
    ]]</pre>
 </div>
</ol>
<p>
 To view the supported assets in the US Equities dataset, see the
 <a href="/https://www.quantconnect.com/docs/v2/data/tree/equity/usa/daily">
  Data Explorer
 </a>
 .
</p>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-fundamental-data#03-Create-Subscriptions">
  subscription
 </a>
 before you can request historical fundamental data for a US Equity.
</p>
<p>
 To get historical data, call the
 <code>
  GetFundamental
 </code>
 method with a list of
 <code>
  Symbol
 </code>
 objects, a fundamental data field name, a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 . The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 . To view the possible fundamental data field names, see the
 <code>
  FineFundamental
 </code>
 attributes in
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/datasets/morningstar/us-fundamental-data#06-Data-Point-Attributes">
  Data Point Attributes
 </a>
 . For example, to get data for airline companies over 2014, run:
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2014, 1, 1);
var endTime = new DateTime(2015, 1, 1);
var history = qb.GetFundamental(symbols, "ValuationRatios.PERatio", startTime, endTime);</pre>
 <pre class="python">start_time = datetime(2014, 1, 1)
end_time = datetime(2015, 1, 1)
history = qb.GetFundamental(symbols, "ValuationRatios.PERatio", start_time, end_time)</pre>
</div>
<p>
 The preceding method returns the fundamental data field values that are timestamped within the defined period of time.
</p>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-fundamental-data#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-fundamental-data#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data.
</p>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 index is the
 <code>
  EndTime
 </code>
 of the data sample. The columns of the
 <code>
  DataFrame
 </code>
 are the Equity
 <code>
  Symbol
 </code>
 objects.
</p>
<img alt="Historical PE ratio of US Equities" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-equity-fundamental-data.jpg"/>
<p class="csharp">
 To get the fundamental data points for each Equity, iterate through the history request result.
</p>
<p class="python">
 To select the historical data of a single Equity, index the
 <code>
  DataFrame
 </code>
 with the Equity
 <code>
  Symbol
 </code>
 . Each history slice may not have data for all of your Equity subscriptions. To avoid issues, check if it contains data for your Equity before you index it with the Equity
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in history)
{
    foreach (var symbol in symbols)
    {
        if (slice.ContainsKey(symbol))
        {
            var peRatio = slice[symbol];
        }
    }
}</pre>
 <pre class="python">history[symbols[1]]</pre>
</div>
<img alt="Historical PE ratio of a single symbol" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-equity-fundamental-data-1.jpg"/>
<p class="csharp">
 You can also iterate through each data point in the slice.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach (var slice in history)
{
    foreach (var kvp in slice)
    {
        var symbol = kvp.Key;
        var peRatio = kvp.Value;
    }
}</pre>
</div>
<p class="csharp">
 You can also use LINQ to select the historical data points.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">var symbol = symbols.Last();
var values = history.Select(slice =&gt; slice[symbol]);</pre>
</div>

<h3>Plot Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-fundamental-data#04-Get-Historical-Data">
  historical Equity fundamental data
 </a>
 to produce plots. You can use
 <span class="python">
  many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
 </span>
 <span class="csharp">
  <code>
   Plot.NET
  </code>
  package
 </span>
 to visualize data in various formats. For example, you can plot line charts.
</p>
<p>
 Follow these steps to plot line charts using
 <span class="python">
  built-in methods
 </span>
 <span class="csharp">
  <code>
   Plotly.NET
  </code>
  package
 </span>
 :
</p>
<ol>
 <li class="python">
  Call the
  <code>
   plot
  </code>
  method on the history
  <code>
   DataFrame
  </code>
  .
 </li>
 <div class="python section-example-container">
  <pre>history.plot(title='PE Ratio Over Time', figsize=(15, 8))</pre>
 </div>
 <li class="csharp">
  Create
  <code>
   Line
  </code>
  charts.
 </li>
 <div class="csharp section-example-container">
  <pre>var chart1 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; (DateTime)x.Time),
    history.Select(x =&gt; (decimal)x[aapl]),
    Name: "AAPL"
);
var chart2 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; (DateTime)x.Time),
    history.Select(x =&gt; (decimal)x[goog]),
    Name: "GOOG"
);</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "PE Ratio");
Title title = Title.init("AAPL &amp; GOOG PE Ratio");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="csharp">
  Combine the charts and assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>var chart = Plotly.NET.Chart.Combine(new []{chart1, chart2});
chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Line charts display the value of the property you selected in a time series.
 </p>
</ol>
<img alt="Line plot of PE ratio of US Equities" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/equity-fundamental-data-plot.jpg"/>
<img alt="Line plot of PE ratio of AAPL &amp; GOOG" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/equity-fundamental-data-plot-csharp.png"/>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.4"><h3>3.4 Equity Options</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical Equity Options data.
</p>

<h3>Create Subscriptions</h3>
<p>
 Follow these steps to subscribe to an Equity Option security:
</p>
<ol>
 <li class="csharp">
  Load the required assembly files and data types.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Data.Market;
using QuantConnect.Algorithm;
using QuantConnect.Securities;
using QuantConnect.Securities.Option;
using QuantConnect.Research;
using Microsoft.Data.Analysis;</pre>
 </div>
 <li>
  Create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Subscribe to the underlying Equity with raw data normalization and save a reference to the Equity
  <span style="color: rgb(220, 67, 67);">
   Symbol
  </span>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var equitySymbol = qb.AddEquity("SPY", dataNormalizationMode: DataNormalizationMode.Raw).Symbol;</pre>
  <pre class="python">equity_symbol = qb.AddEquity("SPY", dataNormalizationMode=DataNormalizationMode.Raw).Symbol</pre>
 </div>
 <div class="csharp section-example-container">
 </div>
 <p>
  To view the supported underlying assets in the US Equity Options dataset, see the
  <a href="/https://www.quantconnect.com/docs/v2/data/tree/option/usa/minute">
   Data Explorer
  </a>
  .
 </p>
 <li>
  Call the
  <code>
   AddOption
  </code>
  method with the underlying Equity
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var option = qb.AddOption(equitySymbol);</pre>
  <pre class="python">option = qb.AddOption(equity_symbol)</pre>
 </div>
 <li>
  <span class="qualifier">
   (Optional)
  </span>
  Set a
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/universes/equity-options#11-Filter-Contracts">
   contract filter
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">option.SetFilter(-1, 1, 0, 90);</pre>
  <pre class="python">option.SetFilter(-1, 1, 0, 90)</pre>
 </div>
 <p>
  The filter determines which contracts the
  <code>
   GetOptionHistory
  </code>
  method returns. If you don't set a filter, the default filter selects the contracts that have the following characteristics:
 </p>
 <ul>
  <li>
   Standard type (exclude weeklys)
  </li>
  <li>
   Within 1 strike price of the underlying asset price
  </li>
  <li>
   Expire within 31 days
  </li>
 </ul>
 <li>
  <span class="qualifier">
   (Optional)
  </span>
  Set the
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/reality-modeling/options-models/pricing">
   price model
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">option.PriceModel = OptionPriceModels.BjerksundStensland();</pre>
  <pre class="python">option.PriceModel = OptionPriceModels.BjerksundStensland()</pre>
 </div>
</ol>
<p>
 If you want historical data on individual contracts and their
 <code>
  OpenInterest
 </code>
 , follow these steps to subscribe to the individual Equity Option contracts:
</p>
<ol>
 <li>
  Call the
  <code>
   GetOptionsContractList
  </code>
  method with the underlying
  <code>
   Equity
  </code>
  <code>
   Symbol
  </code>
  and a
  <code class="python">
   datetime
  </code>
  <code class="csharp">
   DateTime
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var startDate = new DateTime(2021, 12, 31);
var contractSymbols = qb.OptionChainProvider.GetOptionContractList(equitySymbol, startDate);</pre>
  <pre class="python">start_date = datetime(2021, 12, 31)
contract_symbols = qb.OptionChainProvider.GetOptionContractList(equity_symbol, start_date)</pre>
 </div>
 <p>
  This method returns a list of
  <code>
   Symbol
  </code>
  objects that reference the Option contracts that were trading at the given time. If you set a contract filter with
  <code>
   SetFilter
  </code>
  , it doesn't affect the results of
  <code>
   GetOptionsContractList
  </code>
  .
 </p>
 <li>
  Select the
  <code>
   Symbol
  </code>
  of the
  <code>
   OptionContract
  </code>
  object(s) for which you want to get historical data.
 </li>
 <p>
  To filter and select contracts, you can use the following properties of each
  <code>
   Symbol
  </code>
  object:
 </p>
 <table class="qc-table table">
  <thead>
   <tr>
    <th>
     Property
    </th>
    <th>
     Description
    </th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>
     <code>
      ID.Date
     </code>
    </td>
    <td>
     The expiration date of the contract.
    </td>
   </tr>
   <tr>
    <td>
     <code>
      ID.StrikePrice
     </code>
    </td>
    <td>
     The strike price of the contract.
    </td>
   </tr>
   <tr>
    <td>
     <code>
      ID.OptionRight
     </code>
    </td>
    <td>
     The contract type. The
     <code>
      OptionRight
     </code>
     enumeration has the following members:
     <div data-tree="QuantConnect.OptionRight">
     </div>
    </td>
   </tr>
   <tr>
    <td>
     <code>
      ID.OptionStyle
     </code>
    </td>
    <td>
     The contract style. The
     <code>
      OptionStyle
     </code>
     enumeration has the following members:
     <div data-tree="QuantConnect.OptionStyle">
     </div>
    </td>
   </tr>
  </tbody>
 </table>
 <div class="section-example-container">
  <pre class="csharp">var contractSymbol = contractSymbols.Where(s =&gt; 
    s.ID.OptionRight == OptionRight.Call &amp;&amp;
    s.ID.StrikePrice == 477 &amp;&amp;
    s.ID.Date == new DateTime(2022, 1, 21)).First();</pre>
  <pre class="python">contract_symbol = [s for s in contract_symbols 
    if s.ID.OptionRight == OptionRight.Call 
        and s.ID.StrikePrice == 477 
        and s.ID.Date == datetime(2022, 1, 21)][0]</pre>
 </div>
 <li>
  Call the
  <code>
   AddOptionContract
  </code>
  method with an
  <code>
   OptionContract
  </code>
  <code>
   Symbol
  </code>
  and disable fill-forward.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var optionContract = qb.AddOptionContract(contractSymbol, fillForward: false);</pre>
  <pre class="python">option_contract = qb.AddOptionContract(contract_symbol, fillForward = False)</pre>
 </div>
 <p>
  Disable fill-forward because there are only a few
  <code>
   OpenInterest
  </code>
  data points per day.
 </p>
 <li>
  <span class="qualifier">
   (Optional)
  </span>
  Set the
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/reality-modeling/options-models/pricing">
   price model
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">optionContract.PriceModel = OptionPriceModels.BjerksundStensland();</pre>
  <pre class="python">option_contract.PriceModel = OptionPriceModels.BjerksundStensland()</pre>
 </div>
</ol>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-options#03-Create-Subscriptions">
  subscription
 </a>
 before you can request historical data for Equity Option contracts. On the time dimension, you can request an amount of historical data based on a trailing number of bars, a trailing period of time, or a defined period of time. On the contract dimension, you can request historical data for a single contract, a subset of the contracts you created subscriptions for in your notebook, or all of the contracts in your notebook.
</p>
<p>
 Before you request historical data, call the
 <code>
  SetStartDate
 </code>
 method with a
 <code class="python">
  datetime
 </code>
 <code class="csharp">
  DateTime
 </code>
 to reduce the risk of
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/glossary#16-look-ahead-bias">
  look-ahead bias
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">qb.SetStartDate(startDate);</pre>
 <pre class="python">qb.SetStartDate(start_date)</pre>
</div>
<p>
 If you call the
 <code>
  SetStartDate
 </code>
 method, the date that you pass to the method is the latest date for which your history requests will return data.
</p>
<h4>
 Trailing Number of Bars
</h4>
<p>
 To get historical data for a number of trailing bars, call the
 <code>
  History
 </code>
 method with the contract
 <code>
  Symbol
 </code>
 object(s) and an integer.
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(contractSymbol, 10);
var subsetHistorySlice = qb.History(new[] {contractSymbol}, 10);
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(contractSymbol, 10);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {contractSymbol}, 10);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, 10);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(contractSymbol, 10);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {contractSymbol}, 10);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, 10);

// OpenInterest objects
var singleHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(contractSymbol, 400);
var subsetHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(new[] {contractSymbol}, 400);
var allHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(qb.Securities.Keys, 400);</pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History(contract_symbol, 10)
subset_history_df = qb.History([contract_symbol], 10)
all_history_df = qb.History(qb.Securities.Keys, 10)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, contract_symbol, 10)
subset_history_trade_bar_df = qb.History(TradeBar, [contract_symbol], 10)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, 10)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, contract_symbol, 10)
subset_history_quote_bar_df = qb.History(QuoteBar, [contract_symbol], 10)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, 10)

# DataFrame of open interest data
single_history_open_interest_df = qb.History(OpenInterest, contract_symbol, 400)
subset_history_open_interest_df = qb.History(OpenInterest, [contract_symbol], 400)
all_history_open_interest_df = qb.History(OpenInterest, qb.Securities.Keys, 400)

# Slice objects
all_history_slice = qb.History(10)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](contract_symbol, 10)
subset_history_trade_bars = qb.History[TradeBar]([contract_symbol], 10)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, 10)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](contract_symbol, 10)
subset_history_quote_bars = qb.History[QuoteBar]([contract_symbol], 10)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, 10)

# OpenInterest objects
single_history_open_interest = qb.History[OpenInterest](contract_symbol, 400)
subset_history_open_interest = qb.History[OpenInterest]([contract_symbol], 400)
all_history_open_interest = qb.History[OpenInterest](qb.Securities.Keys, 400)</pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Trailing Period of Time
</h4>
<p>
 To get historical data for a trailing period of time, call the
 <code>
  History
 </code>
 method with the contract
 <code>
  Symbol
 </code>
 object(s) and a
 <code class="csharp">
  TimeSpan
 </code>
 <code class="python">
  timedelta
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(contractSymbol, TimeSpan.FromDays(3));
var subsetHistorySlice = qb.History(new[] {contractSymbol}, TimeSpan.FromDays(3));
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(contractSymbol, TimeSpan.FromDays(3));
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {contractSymbol}, TimeSpan.FromDays(3));
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(TimeSpan.FromDays(3));

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(contractSymbol, TimeSpan.FromDays(3), Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {contractSymbol}, TimeSpan.FromDays(3), Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Minute);


// OpenInterest objects
var singleHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(contractSymbol, TimeSpan.FromDays(2));
var subsetHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(new[] {contractSymbol}, TimeSpan.FromDays(2));
var allHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(qb.Securities.Keys, TimeSpan.FromDays(2));</pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History(contract_symbol, timedelta(days=3))
subset_history_df = qb.History([contract_symbol], timedelta(days=3))
all_history_df = qb.History(qb.Securities.Keys, timedelta(days=3))

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, contract_symbol, timedelta(days=3))
subset_history_trade_bar_df = qb.History(TradeBar, [contract_symbol], timedelta(days=3))
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, contract_symbol, timedelta(days=3))
subset_history_quote_bar_df = qb.History(QuoteBar, [contract_symbol], timedelta(days=3))
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of open interest data
single_history_open_interest_df = qb.History(OpenInterest, contract_symbol, timedelta(days=3))
subset_history_open_interest_df = qb.History(OpenInterest, [contract_symbol], timedelta(days=3))
all_history_open_interest_df = qb.History(OpenInterest, qb.Securities.Keys, timedelta(days=3))

# Slice objects
all_history_slice = qb.History(timedelta(days=3))

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](contract_symbol, timedelta(days=3))
subset_history_trade_bars = qb.History[TradeBar]([contract_symbol], timedelta(days=3))
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, timedelta(days=3))

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](contract_symbol, timedelta(days=3), Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([contract_symbol], timedelta(days=3), Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, timedelta(days=3), Resolution.Minute) 


# OpenInterest objects
single_history_open_interest = qb.History[OpenInterest](contract_symbol, timedelta(days=2))
subset_history_open_interest = qb.History[OpenInterest]([contract_symbol], timedelta(days=2))
all_history_open_interest = qb.History[OpenInterest](qb.Securities.Keys, timedelta(days=2))</pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Defined Period of Time
</h4>
<p>
 To get historical data for individual Equity Option contracts during a specific period of time, call the
 <code>
  History
 </code>
 method with the Equity Option contract
 <code>
  Symbol
 </code>
 object(s), a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 .  The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2021, 12, 1);
var endTime = new DateTime(2021, 12, 31);

// Slice objects
var singleHistorySlice = qb.History(contractSymbol, startTime, endTime);
var subsetHistorySlice = qb.History(new[] {contractSymbol}, startTime, endTime);
var allHistorySlice = qb.History(startTime, endTime);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(contractSymbol, startTime, endTime);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {contractSymbol}, startTime, endTime);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, startTime, endTime);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(contractSymbol, startTime, endTime, Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {contractSymbol}, startTime, endTime, Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Minute);


// OpenInterest objects
var singleHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(contractSymbol, startTime, endTime);
var subsetHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(new[] {contractSymbol}, startTime, endTime);
var allHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(qb.Securities.Keys, startTime, endTime);</pre>
 <pre class="python">start_time = datetime(2021, 12, 1)
end_time = datetime(2021, 12, 31)

# DataFrame of trade and quote data
single_history_df = qb.History(contract_symbol, start_time, end_time)
subset_history_df = qb.History([contract_symbol], start_time, end_time)
all_history_df = qb.History(qb.Securities.Keys, start_time, end_time)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, contract_symbol, start_time, end_time)
subset_history_trade_bar_df = qb.History(TradeBar, [contract_symbol], start_time, end_time)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, contract_symbol, start_time, end_time)
subset_history_quote_bar_df = qb.History(QuoteBar, [contract_symbol], start_time, end_time)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of open interest data
single_history_open_interest_df = qb.History(OpenInterest, contract_symbol, start_time, end_time)
subset_history_open_interest_df = qb.History(OpenInterest, [contract_symbol], start_time, end_time)
all_history_trade_open_interest_df = qb.History(OpenInterest, qb.Securities.Keys, start_time, end_time)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](contract_symbol, start_time, end_time)
subset_history_trade_bars = qb.History[TradeBar]([contract_symbol], start_time, end_time)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, start_time, end_time)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](contract_symbol, start_time, end_time, Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([contract_symbol], start_time, end_time, Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, start_time, end_time, Resolution.Minute)


# OpenInterest objects
single_history_open_interest = qb.History[OpenInterest](contract_symbol, start_time, end_time)
subset_history_open_interest = qb.History[OpenInterest]([contract_symbol], start_time, end_time)
all_history_open_interest = qb.History[OpenInterest](qb.Securities.Keys, start_time, end_time)</pre>
</div>
<p>
 To get historical data for all of the Equity Option contracts that pass your
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-options#03-Create-Subscriptions">
  filter
 </a>
 during a specific period of time, call the
 <code>
  GetOptionHistory
 </code>
 method with the underlying Equity
 <code>
  Symbol
 </code>
 object, a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">option_history = qb.GetOptionHistory(equity_symbol, end_time-timedelta(days=2), end_time, Resolution.Minute, fillForward=False, extendedMarketHours=False)</pre>
 <pre class="csharp">var optionHistory = qb.GetOptionHistory(equitySymbol, endTime-TimeSpan.FromDays(2), endTime, Resolution.Minute, fillForward: False, extendedMarketHours: False);</pre>
</div>
<p>
 The preceding calls return data that have a timestamp within the defined period of time.
</p>

<h3>Resolutions</h3>
<p>
 The following table shows the available resolutions and data formats for Equity Option contract subscriptions:
</p>
<table class="qc-table table" id="resolution-and-data-formats">
 <thead>
  <tr>
   <th>
    Resolution
   </th>
   <th>
    TradeBar
   </th>
   <th>
    QuoteBar
   </th>
   <th>
    Trade Tick
   </th>
   <th>
    Quote Tick
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <code>
     Tick
    </code>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <br/>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Second
    </code>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <br/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Minute
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Hour
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Daily
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
 </tbody>
</table>
<style>
 #resolution-and-data-formats td:nth-child(2), 
#resolution-and-data-formats th:nth-child(2), 
#resolution-and-data-formats td:nth-child(3), 
#resolution-and-data-formats th:nth-child(3), 
#resolution-and-data-formats td:nth-child(4), 
#resolution-and-data-formats th:nth-child(4), 
#resolution-and-data-formats td:last-child, 
#resolution-and-data-formats th:last-child {
    text-align: center;
}
</style>

<h3>Markets</h3>
<p>
 LEAN groups all of the US Equity Option exchanges under
 <code>
  Market.USA
 </code>
 , so you don't need to pass a
 <code>
  Market
 </code>
 to the
 <code>
  AddOption
 </code>
 or
 <code>
  AddOptionContract
 </code>
 methods.
</p>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-options#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. The process to manipulate the historical data depends on its data type. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-options#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data. The process to manipulate the historical data depends on its data type.
</p>
<h4>
 DataFrame Objects
</h4>
<p class="python">
 If your history request returns a
 <code>
  DataFrame
 </code>
 , the
 <code>
  DataFrame
 </code>
 has the following index levels:
</p>
<ol class="python">
 <li>
  Contract expiry
 </li>
 <li>
  Contract strike price
 </li>
 <li>
  Contract type (call or put)
 </li>
 <li>
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/security-identifiers#02-Encoding-Symbols">
   Encoded contract Symbol
  </a>
 </li>
 <li>
  The
  <code>
   EndTime
  </code>
  of the data sample
 </li>
</ol>
<p class="python">
 The columns of the
 <code>
  DataFrame
 </code>
 are the data properties. Depending on how you request data, the
 <code>
  DataFrame
 </code>
 may contain data for the underlying security, which causes some of the index levels to be an empty string for the corresponding rows.
</p>
<img alt="Historical data dataframe" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-option-research-data-1.jpg"/>
<p class="python">
 To select the rows of the contract(s) that expire at a specific time, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the expiry time.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[datetime(2022, 1, 21)]</pre>
</div>
<img alt="Historical data dataframe of selected date" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-option-research-data-2.jpg"/>
<p class="python">
 If you remove the first three index levels, you can index the
 <code>
  DataFrame
 </code>
 with just the contract
 <code>
  Symbol
 </code>
 , similiar to how you would with non-derivative asset classes. To remove the first three index levels, call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.droplevel.html" rel="nofollow" target="_blank">
  droplevel
 </a>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.index = all_history_df.index.droplevel([0,1,2])</pre>
</div>
<img alt="Historical data dataframe of dropped first column" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-option-research-data-3.jpg"/>
<p class="python">
 To select the historical data of a single Equity Options contract, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the contract
 <code>
  Symbol
 </code>
 .
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[contract_symbol]
</pre>
</div>
<img alt="DataFrame of one Equity Options" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-option-research-data-5.jpg"/>
<p class="python">
 To select a column of the
 <code>
  DataFrame
 </code>
 , index it with the column name.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[contract_symbol]['close']
</pre>
</div>
<img alt="Series of close values" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-option-research-data-4.jpg"/>
<p class="python">
 If you request historical data for multiple Equity Option contracts, you can transform the
 <code>
  DataFrame
 </code>
 so that it's a time series of close values for all of the Equity Option contracts. To transform the
 <code>
  DataFrame
 </code>
 , select the column you want to display for each Equity Option contract and then call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html" rel="nofollow" target="_blank">
  unstack
 </a>
 method.
</p>
<div class="section-example-container python">
 <pre class="python">all_history_df['close'].unstack(level=0)</pre>
</div>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 is transformed so that the column indices are the
 <code>
  Symbol
 </code>
 of each security and each row contains the close  value.
</p>
<img alt="Historical data dataframe with column indexed by symbols" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-option-research-data-6.jpg"/>
<p class="csharp">
 The historical data methods don't return DataFrame objects, but you can create one for efficient vectorized data wrangling.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">using Microsoft.Data.Analysis; 

var columns = new DataFrameColumn[] {
    new PrimitiveDataFrameColumn<datetime>("Time", history.Select(x =&gt; x[contractSymbol].EndTime)),
    new DecimalDataFrameColumn(" Open", history.Select(x =&gt; x[contractSymbol].Open)),
    new DecimalDataFrameColumn(" High", history.Select(x =&gt; x[contractSymbol].High)),
    new DecimalDataFrameColumn(" Low", history.Select(x =&gt; x[contractSymbol].Low)),
    new DecimalDataFrameColumn(" Close", history.Select(x =&gt; x[contractSymbol].Close))
};
var df = new DataFrame(columns);
df</datetime></pre>
</div>
<img alt="Historical C# dataframe" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-option-research-data-c-1.png"/>
<p class="csharp">
 To select a particular column of the DataFrame, index it with the column name.
</p>
<div class="section-example-container">
 <pre class="csharp">df[" close"]</pre>
</div>
<img alt="Historical C# dataframe column" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-option-research-data-c-2.png"/>
<h4>
 Slice Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Slice
 </code>
 objects, iterate through the
 <code>
  Slice
 </code>
 objects to get each one. The
 <code>
  Slice
 </code>
 objects may not have data for all of your Equity Options subscriptions. To avoid issues, check if the
 <code>
  Slice
 </code>
 contains data for your Equity Option contract before you index it with the Equity Options
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice) {
    if (slice.Bars.ContainsKey(contractSymbol))
    {
        var tradeBar = slice.Bars[contractSymbol];
    }
    if (slice.QuoteBars.ContainsKey(contractSymbol))
    {
        var quoteBar = slice.QuoteBars[contractSymbol];
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
        if slice.Bars.ContainsKey(contract_symbol):
        trade_bar = slice.Bars[contract_symbol]
    if slice.QuoteBars.ContainsKey(contract_symbol):
        quote_bar = slice.QuoteBars[contract_symbol]
</pre>
</div>
<!---- ----->
<p>
 You can also iterate through each
 <code>
  TradeBar
 </code>
 and
 <code>
  QuoteBar
 </code>
 in the
 <code>
  Slice
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice)
{
    foreach (var kvp in slice.Bars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
    foreach (var kvp in slice.QuoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
    for kvp in slice.Bars:
        symbol = kvp.Key
        trade_bar = kvp.Value
    for kvp in slice.QuoteBars:
        symbol = kvp.Key
        quote_bar = kvp.Value
</pre>
</div>
<p class="csharp">
 You can also use LINQ to select each
 <code>
  TradeBar
 </code>
 in the
 <code>
  Slice
 </code>
 for a given
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">
var tradeBars = allHistorySlice.Where(slice =&gt; slice.Bars.ContainsKey(contractSymbol)).Select(slice =&gt; slice.Bars[contractSymbol]);
</pre>
</div>
<!---- ----->
<h4>
 TradeBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBar
 </code>
 objects, iterate through the
 <code>
  TradeBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBar in singleHistoryTradeBars)
{
    Console.WriteLine(tradeBar);
}</pre>
 <pre class="python">for trade_bar in single_history_trade_bars:
    print(trade_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBars
 </code>
 , iterate through the
 <code>
  TradeBars
 </code>
 to get the
 <code>
  TradeBar
 </code>
 of each Equity Option contract. The
 <code>
  TradeBars
 </code>
 may not have data for all of your Equity Options subscriptions. To avoid issues, check if the
 <code>
  TradeBars
 </code>
 object contains data for your security before you index it with the Equity Options
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    if (tradeBars.ContainsKey(contractSymbol))
    {
        var tradeBar = tradeBars[contractSymbol];
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    if trade_bars.ContainsKey(contract_symbol):
        trade_bar = trade_bars[contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  TradeBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    foreach (var kvp in tradeBars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    for kvp in trade_bars:
        symbol = kvp.Key
        trade_bar = kvp.Value<br/></pre>
</div>
<!---- ----->
<h4>
 QuoteBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBar
 </code>
 objects, iterate through the
 <code>
  QuoteBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBar in singleHistoryQuoteBars)
{
    Console.WriteLine(quoteBar);
}</pre>
 <pre class="python">for quote_bar in single_history_quote_bars:
    print(quote_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBars
 </code>
 , iterate through the
 <code>
  QuoteBars
 </code>
 to get the
 <code>
  QuoteBar
 </code>
 of each Equity Option contract. The
 <code>
  QuoteBars
 </code>
 may not have data for all of your Equity Options subscriptions. To avoid issues, check if the
 <code>
  QuoteBars
 </code>
 object contains data for your security before you index it with the Equity Options
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    if (quoteBars.ContainsKey(contractSymbol))
    {
        var quoteBar = quoteBars[contractSymbol];
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    if quote_bars.ContainsKey(contract_symbol):
        quote_bar = quote_bars[contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  QuoteBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    foreach (var kvp in quoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    for kvp in quote_bars:
        symbol = kvp.Key
        quote_bar = kvp.Value</pre>
</div>
<!---- ----->
<!---- ----->
<h4>
 OpenInterest Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  OpenInterest
 </code>
 objects, iterate through the
 <code>
  OpenInterest
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var openInterest in singleHistoryOpenInterest)
{
    Console.WriteLine(openInterest);
}</pre>
 <pre class="python">for open_interest in single_history_open_interest:
    print(open_interest)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns a dictionary of
 <code>
  OpenInterest
 </code>
 objects, iterate through the dictionary to get the
 <code>
  OpenInterest
 </code>
 of each Equity Option contract. The dictionary of
 <code>
  OpenInterest
 </code>
 objects may not have data for all of your Equity Options contract subscriptions. To avoid issues, check if the dictionary contains data for your contract before you index it with the Equity Options contract
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var openInterestDict in allHistoryOpenInterest)
{
    if (openInterestDict.ContainsKey(contractSymbol))
    {
        var openInterest = openInterestDict[contractSymbol];
    }
}</pre>
 <pre class="python">for open_interest_dict in all_history_open_interest:
    if open_interest_dict.ContainsKey(contract_symbol):
        open_interest = open_interest_dict[contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  OpenInterest
 </code>
 dictionaries.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var openInterestDict in allHistoryOpenInterest)
{
    foreach (var kvp in openInterestDict)
    {
        var symbol = kvp.Key;
        var openInterest = kvp.Value;
    }
}</pre>
 <pre class="python">for open_interest_dict in all_history_open_interest:
    for kvp in open_interest_dict:
        symbol = kvp.Key
        open_interest = kvp.Value</pre>
</div>
<!---- ----->
<h4>
 OptionHistory Objects
</h4>
<p>
 The
 <code>
  GetOptionHistory
 </code>
 method returns an
 <code>
  OptionHistory
 </code>
 object. To get each
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/time-modeling/timeslices">
  slice
 </a>
 in the
 <code>
  OptionHistory
 </code>
 object, iterate through it.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in optionHistory)
{
    foreach (var kvp in slice.OptionChains)
    {
        var canonicalSymbol = kvp.Key;
        var chain = kvp.Value;
        foreach (var contract in chain)
        {
            
        }
    }
}</pre>
 <pre class="python">for slice in option_history:
    for canonical_symbol, chain in slice.OptionChains.items(): 
        for contract in chain:
            pass</pre>
</div>
<p class="python">
 To convert the
 <code>
  OptionHistory
 </code>
 object to a
 <code>
  DataFrame
 </code>
 that contains the trade and quote information of each contract and the underlying, call the
 <code>
  GetAllData
 </code>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">option_history.GetAllData()</pre>
</div>
<p class="python">
 To get the expiration dates of all the contracts in an
 <code>
  OptionHistory
 </code>
 object, call the
 <code>
  GetExpiryDates
 </code>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">option_history.GetExpiryDates()</pre>
</div>
<p class="python">
 To get the strike prices of all the contracts in an
 <code>
  OptionHistory
 </code>
 object, call the
 <code>
  GetStrikes
 </code>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">option_history.GetStrikes()</pre>
</div>
<!---- ----->

<h3>Plot Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-options#04-Get-Historical-Data">
  historical Equity Options data
 </a>
 to produce plots. You can use
 <span class="python">
  many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
 </span>
 <span class="csharp">
  <code>
   Plot.NET
  </code>
  package
 </span>
 to visualize data in various formats. For example, you can plot candlestick and line charts.
</p>
<h4>
 Candlestick Chart
 <br/>
</h4>
<p>
 Follow these steps to plot candlestick charts:
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(contract_symbol, datetime(2021, 12, 30), datetime(2021, 12, 31))</pre>
  <pre class="csharp">var history = qb.History&lt;TradeBar&gt;(contractSymbol, new DateTime(2021, 12, 30), new DateTime(2021, 12, 31));</pre>
 </div>
 <li class="python">
  Drop the first four index levels of the
  <code>
   DataFrame
  </code>
  that returns.
 </li>
 <div class="python section-example-container">
  <pre>history.index = history.index.droplevel([0,1,2,3])</pre>
 </div>
 <li>
  Import the
  <code class="python">
   plotly
  </code>
  <code class="csharp">
   Plotly.NET
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">import plotly.graph_objects as go</pre>
  <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
 <li>
  Create a
  <code>
   Candlestick
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">candlestick = go.Candlestick(x=history.index,
                             open=history['open'],
                             high=history['high'],
                             low=history['low'],
                             close=history['close'])</pre>
  <pre class="csharp">var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    history.Select(x =&gt; x.Open),
    history.Select(x =&gt; x.High),
    history.Select(x =&gt; x.Low),
    history.Select(x =&gt; x.Close),
    history.Select(x =&gt; x.EndTime)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">layout = go.Layout(title=go.layout.Title(text=f'{symbol.Value} OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
  <pre>LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{contractSymbol} Price");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="python">
  Create the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="python section-example-container">
  <pre>fig = go.Figure(data=[candlestick], layout=layout)</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  The Jupyter Notebook displays a candlestick chart of the Option contract's price.
 </p>
</ol>
<img alt="Candlestick shart of a contract's price" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-equity-options-contract-candlestick-2022.png"/>
<img alt="Candlestick shart of a contract's price" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-equity-options-contract-candlestick-csharp.png"/>
<h4>
 Line Chart
</h4>
<p>
 Follow these steps to plot line charts using
 <span class="python">
  built-in methods
 </span>
 <span class="csharp">
  <code>
   Plotly.NET
  </code>
  package
 </span>
 :
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(OpenInterest, contract_symbol, datetime(2021, 12, 1), datetime(2021, 12, 31))</pre>
  <pre class="csharp">var history = qb.History&lt;OpenInterest&gt;(contract_symbol, new DateTime(2021, 12, 1), new DateTime(2021, 12, 31));</pre>
 </div>
 <li class="python">
  Drop the first three index levels of the
  <code>
   DataFrame
  </code>
  that returns.
  <br/>
 </li>
 <div class="python section-example-container">
  <pre class="python">history.index = history.index.droplevel([0, 1, 2])</pre>
 </div>
 <li class="python">
  Select the open interest data.
 </li>
 <div class="python section-example-container">
  <pre class="python">history = history['openinterest'].unstack(level=0)</pre>
 </div>
 <li class="python">
  Rename the column to the
  <code>
   Symbol
  </code>
  of the contract.
 </li>
 <div class="python section-example-container">
  <pre class="python">history.columns = [
    Symbol.GetAlias(SecurityIdentifier.Parse(x), equity_symbol)
        for x in history.columns]</pre>
 </div>
 <li class="python">
  Call the
  <code>
   plot
  </code>
  method with a title.
 </li>
 <div class="python section-example-container">
  <pre class="python">history.plot(title="Open Interest")</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Line
  </code>
  chart.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">var chart = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x.EndTime),
    history.Select(x =&gt; x.Value)
);</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Open Interest");
Title title = Title.init("SPY Open Interest");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  The Jupyter Notebook displays a line chart of open interest data.
  <br/>
 </p>
</ol>
<img alt="Line chart of open interest" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-option-research-plot-line-chart.jpg"/>
<img alt="Line chart of open interest" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/us-equity-option-research-plot-line-chart-csharp.png"/>

<h3>Get Price Model Data</h3>
<p>
 Follow these steps to get the values of theoretical prices, implied volatility, and Greeks:
</p>
<ol>
 <li>
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-options#03-Create-Subscriptions">
   Create subscriptions and set the price model
  </a>
  .
 </li>
 <li>
  Set the underlying
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/reality-modeling/options-models/volatility/key-concepts">
   volatility model
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">qb.Securities[equity_symbol].VolatilityModel = StandardDeviationOfReturnsVolatilityModel(30, Resolution.Daily)</pre>
 </div>
 <p>
  You need to reset the volatility before you start calculating the theoretical prices, implied volatility, and Greeks.
 </p>
 <li>
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/equity-options#04-Get-Historical-Data">
   Get historical data
  </a>
  for the underlying Equity and the Option contract(s).
 </li>
 <li>
  Iterate through the historical data and calculate the values.
 </li>
 <div class="section-example-container">
  <pre class="python">df = pd.DataFrame()
for slice in history:
    underlying_price = None
    underlying_volatility = None

    # Update the security with QuoteBar information
    for bar in slice.QuoteBars.Values:
        qb.Securities[bar.Symbol].SetMarketPrice(bar)

    # Update the security with TradeBar information
    for bar in slice.Bars.Values:
        symbol = bar.Symbol
        security = qb.Securities[symbol]
        security.SetMarketPrice(bar)

        if security.Type == SecurityType.Equity:
            underlying_volatility = security.VolatilityModel.Volatility
            underlying_price = security.Price
            continue
        
        # Create the Option contract
        contract = OptionContract.Create(symbol, symbol.Underlying, bar.EndTime, security, underlying_price)
        contract.LastPrice = bar.Close

        # Evaluate the price model to get the IV, Greeks, and theoretical price
        result = security.PriceModel.Evaluate(security, None, contract)
        greeks = result.Greeks
        
        # Append the data to the DataFrame
        data = {
            "IV" : result.ImpliedVolatility,
            "Delta": greeks.Delta,
            "Gamma": greeks.Gamma,
            "Vega": greeks.Vega,
            "Rho": greeks.Rho,
            "Theta": greeks.Theta,
            "LastPrice": contract.LastPrice,
            "Close": security.Close,
            "theoreticalPrice" : result.TheoreticalPrice,
            "underlyingPrice": underlying_price,
            "underlyingVolatility": underlying_volatility
        }
        right = "Put" if symbol.ID.OptionRight == 1 else "Call"
        index = pd.MultiIndex.from_tuples([(symbol.ID.Date, symbol.ID.StrikePrice, right, symbol.Value, bar.EndTime)], names=["expiry", "strike", "type", "symbol", "endTime"])
        df = pd.concat([df, pd.DataFrame(data, index=index)])</pre>
 </div>
</ol>
<p>
 For a full example, see the following project:
</p>
<div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
 <div class="qc-embed-dummy" style="padding-top: 56.25%;">
 </div>
 <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
  <iframe class="qc-embed-backtest" height="100%" scrolling="no" src="https://www.quantconnect.com/terminal/processCache?request=embedded_backtest_dae479978ae8d88030b3a18a2fac837d.html" style="max-width: calc(100vw - 30px); max-height: 100vw; overflow: hidden;" width="100%">
  </iframe>
 </div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.5"><h3>3.5 Crypto</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical Crypto data.
</p>

<h3>Create Subscriptions</h3>
<p>
 Follow these steps to subscribe to a Crypto security:
</p>
<ol>
 <li class="csharp">
  Load the required assembly files and data types.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Algorithm;
using QuantConnect.Research;
using Microsoft.Data.Analysis;</pre>
 </div>
 <li>
  Create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Call the
  <code>
   AddCrypto
  </code>
  method with a ticker and then save a reference to the Crypto
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var btcusd = qb.AddCrypto("BTCUSD").Symbol;
var ethusd = qb.AddCrypto("ETHUSD").Symbol;</pre>
  <pre class="python">btcusd = qb.AddCrypto("BTCUSD").Symbol
ethusd = qb.AddCrypto("ETHUSD").Symbol</pre>
 </div>
</ol>
<p>
 To view the supported assets in the Crypto datasets, see the
 <span class="page-section-name">
  Supported Assets
 </span>
 section of the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/datasets/coinapi">
  CoinAPI dataset listings
 </a>
 .
</p>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/crypto#03-Create-Subscriptions">
  subscription
 </a>
 before you can request historical data for a security. On the time dimension, you can request an amount of historical data based on a trailing number of bars, a trailing period of time, or a defined period of time. On the security dimension, you can request historical data for a single Cryptocurrency, a subset of the Cryptocurrencies you created subscriptions for in your notebook, or all of the Cryptocurrencies in your notebook.
</p>
<h4>
 Trailing Number of Bars
 <br/>
</h4>
<p>
 To get historical data for a number of trailing bars, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s) and an integer.
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(btcusd, 10);
var subsetHistorySlice = qb.History(new[] {btcusd, ethusd}, 10);
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(btcusd, 10);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {btcusd, ethusd}, 10);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, 10);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(btcusd, 10);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {btcusd, ethusd}, 10);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, 10);</pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History(btcusd, 10)
subset_history_df = qb.History([btcusd, ethusd], 10)
all_history_df = qb.History(qb.Securities.Keys, 10)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, btcusd, 10)
subset_history_trade_bar_df = qb.History(TradeBar, [btcusd, ethusd], 10)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, 10)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, btcusd, 10)
subset_history_quote_bar_df = qb.History(QuoteBar, [btcusd, ethusd], 10)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, 10)

# Slice objects
all_history_slice = qb.History(10)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](btcusd, 10)
subset_history_trade_bars = qb.History[TradeBar]([btcusd, ethusd], 10)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, 10)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](btcusd, 10)
subset_history_quote_bars = qb.History[QuoteBar]([btcusd, ethusd], 10)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, 10)</pre>
</div>
<h4>
 Trailing Period of Time
 <br/>
</h4>
<p>
 To get historical data for a trailing period of time, call the
 <code>
  History
 </code>
 method with the
 <code style="font-size: 15px; background-color: rgb(255, 255, 255);">
  Symbol
 </code>
 object(s) and a
 <code class="csharp">
  TimeSpan
 </code>
 <code class="python">
  timedelta
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(btcusd, TimeSpan.FromDays(3));
var subsetHistorySlice = qb.History(new[] {btcusd, ethusd}, TimeSpan.FromDays(3));
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(btcusd, TimeSpan.FromDays(3));
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {btcusd, ethusd}, TimeSpan.FromDays(3));
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(TimeSpan.FromDays(3));

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(btcusd, TimeSpan.FromDays(3), Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {btcusd, ethusd}, TimeSpan.FromDays(3), Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Minute);

// Tick objects
var singleHistoryTicks = qb.History&lt;Tick&gt;(btcusd, TimeSpan.FromDays(3), Resolution.Tick);
var subsetHistoryTicks = qb.History&lt;Tick&gt;(new[] {btcusd, ethusd}, TimeSpan.FromDays(3), Resolution.Tick);<br/>var allHistoryTicks = qb.History&lt;Tick&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Tick);<br/></pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History(btcusd, timedelta(days=3))
subset_history_df = qb.History([btcusd, ethusd], timedelta(days=3))
all_history_df = qb.History(qb.Securities.Keys, timedelta(days=3))

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, btcusd, timedelta(days=3))
subset_history_trade_bar_df = qb.History(TradeBar, [btcusd, ethusd], timedelta(days=3))
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, btcusd, timedelta(days=3))
subset_history_quote_bar_df = qb.History(QuoteBar, [btcusd, ethusd], timedelta(days=3))
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of tick data
single_history_tick_df = qb.History(btcusd, timedelta(days=3), Resolution.Tick)
subset_history_tick_df = qb.History([btcusd, ethusd], timedelta(days=3), Resolution.Tick)
all_history_tick_df = qb.History(qb.Securities.Keys, timedelta(days=3), Resolution.Tick)

# Slice objects
all_history_slice = qb.History(timedelta(days=3))

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](btcusd, timedelta(days=3))
subset_history_trade_bars = qb.History[TradeBar]([btcusd, ethusd], timedelta(days=3))
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, timedelta(days=3))

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](btcusd, timedelta(days=3), Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([btcusd, ethusd], timedelta(days=3), Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, timedelta(days=3), Resolution.Minute)

# Tick objects
single_history_ticks = qb.History[Tick](btcusd, timedelta(days=3), Resolution.Tick)
subset_history_ticks = qb.History[Tick]([btcusd, ethusd], timedelta(days=3), Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, timedelta(days=3), Resolution.Tick)</pre>
</div>
<h4>
 Defined Period of Time
 <br/>
</h4>
<p>
 To get historical data for a specific period of time, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s), a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 . The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2021, 1, 1);
var endTime = new DateTime(2021, 2, 1);

// Slice objects
var singleHistorySlice = qb.History(btcusd, startTime, endTime);
var subsetHistorySlice = qb.History(new[] {btcusd, ethusd}, startTime, endTime);
var allHistorySlice = qb.History(qb.Securities.Keys, startTime, endTime);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(btcusd, startTime, endTime);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {btcusd, ethusd}, startTime, endTime);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, startTime, endTime);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(btcusd, startTime, endTime, Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {btcusd, ethusd}, startTime, endTime, Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Minute);

// Tick objects
var singleHistoryTicks = qb.History&lt;Tick&gt;(btcusd, startTime, endTime, Resolution.Tick);
var subsetHistoryTicks = qb.History&lt;Tick&gt;(new[] {btcusd, ethusd}, startTime, endTime, Resolution.Tick);
var allHistoryTicks = qb.History&lt;Tick&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Tick);</pre>
 <pre class="python">start_time = datetime(2021, 1, 1)
end_time = datetime(2021, 2, 1)

# DataFrame of trade and quote data
single_history_df = qb.History(btcusd, start_time, end_time)
subset_history_df = qb.History([btcusd, ethusd], start_time, end_time)
all_history_df = qb.History(qb.Securities.Keys, start_time, end_time)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, btcusd, start_time, end_time)
subset_history_trade_bar_df = qb.History(TradeBar, [btcusd, ethusd], start_time, end_time)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, btcusd, start_time, end_time)
subset_history_quote_bar_df = qb.History(QuoteBar, [btcusd, ethusd], start_time, end_time)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of tick data
single_history_tick_df = qb.History(btcusd, start_time, end_time, Resolution.Tick)
subset_history_tick_df = qb.History([btcusd, ethusd], start_time, end_time, Resolution.Tick)
all_history_tick_df = qb.History(qb.Securities.Keys, start_time, end_time, Resolution.Tick)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](btcusd, start_time, end_time)
subset_history_trade_bars = qb.History[TradeBar]([btcusd, ethusd], start_time, end_time)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, start_time, end_time)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](btcusd, start_time, end_time, Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([btcusd, ethusd], start_time, end_time, Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, start_time, end_time, Resolution.Minute)

# Tick objects
single_history_ticks = qb.History[Tick](btcusd, start_time, end_time, Resolution.Tick)
subset_history_ticks = qb.History[Tick]([btcusd, ethusd], start_time, end_time, Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, start_time, end_time, Resolution.Tick)</pre>
</div>

<h3>Resolutions</h3>
<p>
 The following table shows the available resolutions and data formats for Crypto subscriptions:
</p>
<table class="qc-table table" id="resolution-and-data-formats">
 <thead>
  <tr>
   <th>
    Resolution
   </th>
   <th>
    TradeBar
   </th>
   <th>
    QuoteBar
   </th>
   <th>
    Trade Tick
   </th>
   <th>
    Quote Tick
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <code>
     Tick
    </code>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Second
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Minute
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Hour
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Daily
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
 </tbody>
</table>
<style>
 #resolution-and-data-formats td:nth-child(2), 
#resolution-and-data-formats th:nth-child(2), 
#resolution-and-data-formats td:nth-child(3), 
#resolution-and-data-formats th:nth-child(3), 
#resolution-and-data-formats td:nth-child(4), 
#resolution-and-data-formats th:nth-child(4), 
#resolution-and-data-formats td:last-child, 
#resolution-and-data-formats th:last-child {
    text-align: center;
}
</style>

<h3>Markets</h3>
<p>
 The following
 <code>
  Market
 </code>
 enumeration members are available for Crypto:
</p>
<div data-fields="Bitfinex,GDAX,Kraken,Binance,BinanceUS" data-tree="QuantConnect.Market">
</div>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/crypto#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. The process to manipulate the historical data depends on its data type. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/crypto#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data. The process to manipulate the historical data depends on its data type.
</p>
<h4>
 DataFrame Objects
</h4>
<p class="python">
 If the
 <code>
  History
 </code>
 method returns a
 <code>
  DataFrame
 </code>
 , the first level of the
 <code>
  DataFrame
 </code>
 index is the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/security-identifiers#02-Encoding-Symbols">
  encoded Crypto Symbol
 </a>
 and the second level is the
 <code>
  EndTime
 </code>
 of the data sample. The columns of the
 <code>
  DataFrame
 </code>
 are the data properties.
</p>
<img alt="DataFrame of two Crypto pairs" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/crypto-research-data-1.jpg"/>
<p class="python">
 To select the historical data of a single Crypto, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the Crypto
 <code>
  Symbol
 </code>
 .
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[btcusd]  # or all_history_df.loc['BTCUSD']
</pre>
</div>
<img alt="DataFrame of one Crypto" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/crypto-research-data-2.jpg"/>
<p class="python">
 To select a column of the
 <code>
  DataFrame
 </code>
 , index it with the column name.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[btcusd]['close']
</pre>
</div>
<img alt="Series of close values" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/crypto-research-data-3.jpg"/>
<p class="python">
 If you request historical data for multiple Crypto pairs, you can transform the
 <code>
  DataFrame
 </code>
 so that it's a time series of close values for all of the Crypto pairs. To transform the
 <code>
  DataFrame
 </code>
 , select the column you want to display for each Crypto pair and then call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html" rel="nofollow" target="_blank">
  unstack
 </a>
 method.
</p>
<div class="section-example-container python">
 <pre class="python">all_history_df['close'].unstack(level=0)</pre>
</div>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 is transformed so that the column indices are the
 <code>
  Symbol
 </code>
 of each Crypto pair and each row contains the close value.
</p>
<img alt="DataFrame of one Crypto" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/crypto-research-data-4.jpg"/>
<p class="csharp">
 The historical data methods don't return DataFrame objects, but you can create one for efficient vectorized data wrangling.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">using Microsoft.Data.Analysis; 

var columns = new DataFrameColumn[] {
    new PrimitiveDataFrameColumn<datetime>("Time", history.Select(x =&gt; x[btcusd].EndTime)),
    new DecimalDataFrameColumn("BTCUSD Open", history.Select(x =&gt; x[btcusd].Open)),
    new DecimalDataFrameColumn("BTCUSD High", history.Select(x =&gt; x[btcusd].High)),
    new DecimalDataFrameColumn("BTCUSD Low", history.Select(x =&gt; x[btcusd].Low)),
    new DecimalDataFrameColumn("BTCUSD Close", history.Select(x =&gt; x[btcusd].Close))
};
var df = new DataFrame(columns);
df</datetime></pre>
</div>
<img alt="Historical C# dataframe" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/crypto-research-data-c-1.png"/>
<p class="csharp">
 To select a particular column of the DataFrame, index it with the column name.
</p>
<div class="section-example-container">
 <pre class="csharp">df["BTCUSD close"]</pre>
</div>
<img alt="Historical C# dataframe column" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/crypto-research-data-c-2.png"/>
<h4>
 Slice Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Slice
 </code>
 objects, iterate through the
 <code>
  Slice
 </code>
 objects to get each one. The
 <code>
  Slice
 </code>
 objects may not have data for all of your Crypto subscriptions. To avoid issues, check if the
 <code>
  Slice
 </code>
 contains data for your Crypto pair before you index it with the Crypto
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice) {
    if (slice.Bars.ContainsKey(btcusd))
    {
        var tradeBar = slice.Bars[btcusd];
    }
    if (slice.QuoteBars.ContainsKey(btcusd))
    {
        var quoteBar = slice.QuoteBars[btcusd];
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
        if slice.Bars.ContainsKey(btcusd):
        trade_bar = slice.Bars[btcusd]
    if slice.QuoteBars.ContainsKey(btcusd):
        quote_bar = slice.QuoteBars[btcusd]
</pre>
</div>
<!---- ----->
<p>
 You can also iterate through each
 <code>
  TradeBar
 </code>
 and
 <code>
  QuoteBar
 </code>
 in the
 <code>
  Slice
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice)
{
    foreach (var kvp in slice.Bars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
    foreach (var kvp in slice.QuoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
    for kvp in slice.Bars:
        symbol = kvp.Key
        trade_bar = kvp.Value
    for kvp in slice.QuoteBars:
        symbol = kvp.Key
        quote_bar = kvp.Value
</pre>
</div>
<p class="csharp">
 You can also use LINQ to select each
 <code>
  TradeBar
 </code>
 in the
 <code>
  Slice
 </code>
 for a given
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">
var tradeBars = allHistorySlice.Where(slice =&gt; slice.Bars.ContainsKey(btcusd)).Select(slice =&gt; slice.Bars[btcusd]);
</pre>
</div>
<!---- ----->
<h4>
 TradeBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBar
 </code>
 objects, iterate through the
 <code>
  TradeBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBar in singleHistoryTradeBars)
{
    Console.WriteLine(tradeBar);
}</pre>
 <pre class="python">for trade_bar in single_history_trade_bars:
    print(trade_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBars
 </code>
 , iterate through the
 <code>
  TradeBars
 </code>
 to get the
 <code>
  TradeBar
 </code>
 of each Crypto pair. The
 <code>
  TradeBars
 </code>
 may not have data for all of your Crypto subscriptions. To avoid issues, check if the
 <code>
  TradeBars
 </code>
 object contains data for your security before you index it with the Crypto
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    if (tradeBars.ContainsKey(btcusd))
    {
        var tradeBar = tradeBars[btcusd];
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    if trade_bars.ContainsKey(btcusd):
        trade_bar = trade_bars[btcusd]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  TradeBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    foreach (var kvp in tradeBars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    for kvp in trade_bars:
        symbol = kvp.Key
        trade_bar = kvp.Value<br/></pre>
</div>
<!---- ----->
<h4>
 QuoteBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBar
 </code>
 objects, iterate through the
 <code>
  QuoteBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBar in singleHistoryQuoteBars)
{
    Console.WriteLine(quoteBar);
}</pre>
 <pre class="python">for quote_bar in single_history_quote_bars:
    print(quote_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBars
 </code>
 , iterate through the
 <code>
  QuoteBars
 </code>
 to get the
 <code>
  QuoteBar
 </code>
 of each Crypto pair. The
 <code>
  QuoteBars
 </code>
 may not have data for all of your Crypto subscriptions. To avoid issues, check if the
 <code>
  QuoteBars
 </code>
 object contains data for your security before you index it with the Crypto
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    if (quoteBars.ContainsKey(btcusd))
    {
        var quoteBar = quoteBars[btcusd];
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    if quote_bars.ContainsKey(btcusd):
        quote_bar = quote_bars[btcusd]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  QuoteBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    foreach (var kvp in quoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    for kvp in quote_bars:
        symbol = kvp.Key
        quote_bar = kvp.Value</pre>
</div>
<!---- ----->
<h4>
 Tick Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Tick
 </code>
 objects, iterate through the
 <code>
  Tick
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tick in singleHistoryTicks)
{
    Console.WriteLine(tick);
}</pre>
 <pre class="python">for tick in single_history_ticks:
    print(tick)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Ticks
 </code>
 , iterate through the
 <code>
  Ticks
 </code>
 to get the
 <code>
  Tick
 </code>
 of each Crypto pair. The
 <code>
  Ticks
 </code>
 may not have data for all of your Crypto subscriptions. To avoid issues, check if the
 <code>
  Ticks
 </code>
 object contains data for your security before you index it with the Crypto
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    if (ticks.ContainsKey(btcusd))
    {
        var tick = ticks[btcusd];
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    if ticks.ContainsKey(btcusd):
        ticks = ticks[btcusd]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  Ticks
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    foreach (var kvp in ticks)
    {
        var symbol = kvp.Key;
        var tick = kvp.Value;
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    for kvp in ticks:
        symbol = kvp.Key
        tick = kvp.Value</pre>
</div>
<!---- ----->
<!---- ----->
<!---- ----->

<h3>Plot Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/crypto#04-Get-Historical-Data">
  historical Crypto data
 </a>
 to produce plots. You can use
 <span class="python">
  many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
 </span>
 <span class="csharp">
  <code>
   Plot.NET
  </code>
  package
 </span>
 to visualize data in various formats. For example, you can plot candlestick and line charts.
</p>
<h4>
 Candlestick Chart
 <br/>
</h4>
<p>
 Follow these steps to plot candlestick charts:
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(btcusd, datetime(2020, 12, 27), datetime(2021, 12, 21), Resolution.Daily).loc[btcusd]</pre>
  <pre class="csharp">var history = qb.History&lt;TradeBar&gt;(btcusd, new DateTime(2020, 12, 27), new DateTime(2021, 12, 21), Resolution.Daily);</pre>
 </div>
 <li>
  Import the
  <code class="python">
   plotly
  </code>
  <code class="csharp">
   Plotly.NET
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">import plotly.graph_objects as go</pre>
  <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
 <li>
  Create a
  <code>
   Candlestick
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">candlestick = go.Candlestick(x=history.index,
                             open=history['open'],
                             high=history['high'],
                             low=history['low'],
                             close=history['close'])</pre>
  <pre class="csharp">var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    history.Select(x =&gt; x.Open),
    history.Select(x =&gt; x.High),
    history.Select(x =&gt; x.Low),
    history.Select(x =&gt; x.Close),
    history.Select(x =&gt; x.EndTime)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">layout = go.Layout(title=go.layout.Title(text='BTCUSD OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{btcusd} Price");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="python">
  Create the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="python section-example-container">
  <pre>fig = go.Figure(data=[candlestick], layout=layout)</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Candlestick charts display the open, high, low, and close prices of the security.
 </p>
</ol>
<img alt="Candlestick plot of BTCUSD OHLC" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-crypto-candlestickplot.png"/>
<img alt="Candlestick plot of BTCUSD OHLC" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-crypto-candlestickplot-csharp.png"/>
<h4>
 Line Chart
</h4>
<p>
 Follow these steps to plot line charts using
 <span class="python">
  built-in methods
 </span>
 <span class="csharp">
  <code>
   Plotly.NET
  </code>
  package
 </span>
 :
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History([btcusd, ethusd], datetime(2020, 12, 27), datetime(2021, 12, 21), Resolution.Daily)</pre>
  <pre>var history = qb.History&lt;TradeBar&gt;(new[] {btcusd, ethusd}, new DateTime(2020, 12, 27), new DateTime(2021, 12, 21), Resolution.Daily);</pre>
 </div>
 <li class="python">
  Select the data to plot.
 </li>
 <div class="python section-example-container">
  <pre>volume = history['volume'].unstack(level=0)</pre>
 </div>
 <li class="python">
  Call the
  <code>
   plot
  </code>
  method on the
  <code>
   pandas
  </code>
  object.
 </li>
 <div class="python section-example-container">
  <pre>volume.plot(title="Volume", figsize=(15, 10))</pre>
 </div>
 <li class="csharp">
  Create
  <code>
   Line
  </code>
  charts.
 </li>
 <div class="csharp section-example-container">
  <pre>var chart1 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x[btcusd].EndTime),
    history.Select(x =&gt; x[btcusd].Volume),
    Name: "BTCUSD"
);
var chart2 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x[ethusd].EndTime),
    history.Select(x =&gt; x[ethusd].Volume),
    Name: "ETHUSD"
);</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Volume");
Title title = Title.init("BTCUSD &amp; ETHUSD Volume");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="csharp">
  Combine the charts and assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>var chart = Plotly.NET.Chart.Combine(new []{chart1, chart2});
chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Line charts display the value of the property you selected in a time series.
 </p>
</ol>
<img alt="Line chart of volume of BTCUSD, &amp; ETHUSD" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-crypto-volume-plot.jpg"/>
<img alt="Line chart of volume of BTCUSD, &amp; ETHUSD" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-crypto-volume-plot-csharp.png"/>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.6"><h3>3.6 Crypto Futures</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical Crypto Futures data.
</p>

<h3>Create Subscriptions</h3>
<p>
 Follow these steps to subscribe to a perpetual Crypto Futures contract:
</p>
<ol>
 <li class="csharp">
  Load the required assembly files and data types.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Algorithm;
using QuantConnect.Research;
using Microsoft.Data.Analysis;</pre>
 </div>
 <li>
  Create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Call the
  <code>
   AddCryptoFuture
  </code>
  method with a ticker and then save a reference to the Crypto Future
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var btcusd = qb.AddCryptoFuture("BTCUSD").Symbol;
var ethusd = qb.AddCryptoFuture("ETHUSD").Symbol;</pre>
  <pre class="python">btcusd = qb.AddCryptoFuture("BTCUSD").Symbol
ethusd = qb.AddCryptoFuture("ETHUSD").Symbol</pre>
 </div>
</ol>
<p>
 To view the supported assets in the Crypto Futures datasets, see the
 <a href="/https://www.quantconnect.com/docs/v2/data/tree/cryptofuture/binance/daily">
  Data Explorer
 </a>
 .
</p>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/crypto-futures#03-Create-Subscriptions">
  subscription
 </a>
 before you can request historical data for a security. You can request an amount of historical data based on a trailing number of bars, a trailing period of time, or a defined period of time. You can also request historical data for a single contract, a subset of the contracts you created subscriptions for in your notebook, or all of the contracts in your notebook.
</p>
<h4>
 Trailing Number of Bars
 <br/>
</h4>
<p>
 To get historical data for a number of trailing bars, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s) and an integer.
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(btcusd, 10);
var subsetHistorySlice = qb.History(new[] {btcusd, ethusd}, 10);
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(btcusd, 10);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {btcusd, ethusd}, 10);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, 10);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(btcusd, 10);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {btcusd, ethusd}, 10);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, 10);</pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History(btcusd, 10)
subset_history_df = qb.History([btcusd, ethusd], 10)
all_history_df = qb.History(qb.Securities.Keys, 10)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, btcusd, 10)
subset_history_trade_bar_df = qb.History(TradeBar, [btcusd, ethusd], 10)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, 10)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, btcusd, 10)
subset_history_quote_bar_df = qb.History(QuoteBar, [btcusd, ethusd], 10)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, 10)

# Slice objects
all_history_slice = qb.History(10)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](btcusd, 10)
subset_history_trade_bars = qb.History[TradeBar]([btcusd, ethusd], 10)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, 10)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](btcusd, 10)
subset_history_quote_bars = qb.History[QuoteBar]([btcusd, ethusd], 10)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, 10)</pre>
</div>
<h4>
 Trailing Period of Time
 <br/>
</h4>
<p>
 To get historical data for a trailing period of time, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s) and a
 <code class="csharp">
  TimeSpan
 </code>
 <code class="python">
  timedelta
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(btcusd, TimeSpan.FromDays(3));
var subsetHistorySlice = qb.History(new[] {btcusd, ethusd}, TimeSpan.FromDays(3));
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(btcusd, TimeSpan.FromDays(3));
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {btcusd, ethusd}, TimeSpan.FromDays(3));
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(TimeSpan.FromDays(3));

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(btcusd, TimeSpan.FromDays(3), Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {btcusd, ethusd}, TimeSpan.FromDays(3), Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Minute);

// Tick objects
var singleHistoryTicks = qb.History&lt;Tick&gt;(btcusd, TimeSpan.FromDays(3), Resolution.Tick);
var subsetHistoryTicks = qb.History&lt;Tick&gt;(new[] {btcusd, ethusd}, TimeSpan.FromDays(3), Resolution.Tick);
var allHistoryTicks = qb.History&lt;Tick&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Tick);<br/></pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History(btcusd, timedelta(days=3))
subset_history_df = qb.History([btcusd, ethusd], timedelta(days=3))
all_history_df = qb.History(qb.Securities.Keys, timedelta(days=3))

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, btcusd, timedelta(days=3))
subset_history_trade_bar_df = qb.History(TradeBar, [btcusd, ethusd], timedelta(days=3))
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, btcusd, timedelta(days=3))
subset_history_quote_bar_df = qb.History(QuoteBar, [btcusd, ethusd], timedelta(days=3))
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of tick data
single_history_tick_df = qb.History(btcusd, timedelta(days=3), Resolution.Tick)
subset_history_tick_df = qb.History([btcusd, ethusd], timedelta(days=3), Resolution.Tick)
all_history_tick_df = qb.History(qb.Securities.Keys, timedelta(days=3), Resolution.Tick)

# Slice objects
all_history_slice = qb.History(timedelta(days=3))

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](btcusd, timedelta(days=3))
subset_history_trade_bars = qb.History[TradeBar]([btcusd, ethusd], timedelta(days=3))
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, timedelta(days=3))

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](btcusd, timedelta(days=3), Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([btcusd, ethusd], timedelta(days=3), Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, timedelta(days=3), Resolution.Minute)

# Tick objects
single_history_ticks = qb.History[Tick](btcusd, timedelta(days=3), Resolution.Tick)
subset_history_ticks = qb.History[Tick]([btcusd, ethusd], timedelta(days=3), Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, timedelta(days=3), Resolution.Tick)</pre>
</div>
<h4>
 Defined Period of Time
 <br/>
</h4>
<p>
 To get historical data for a specific period of time, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s), a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 . The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2021, 1, 1);
var endTime = new DateTime(2021, 2, 1);

// Slice objects
var singleHistorySlice = qb.History(btcusd, startTime, endTime);
var subsetHistorySlice = qb.History(new[] {btcusd, ethusd}, startTime, endTime);
var allHistorySlice = qb.History(qb.Securities.Keys, startTime, endTime);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(btcusd, startTime, endTime);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {btcusd, ethusd}, startTime, endTime);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, startTime, endTime);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(btcusd, startTime, endTime, Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {btcusd, ethusd}, startTime, endTime, Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Minute);

// Tick objects
var singleHistoryTicks = qb.History&lt;Tick&gt;(btcusd, startTime, endTime, Resolution.Tick);
var subsetHistoryTicks = qb.History&lt;Tick&gt;(new[] {btcusd, ethusd}, startTime, endTime, Resolution.Tick);
var allHistoryTicks = qb.History&lt;Tick&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Tick);</pre>
 <pre class="python">start_time = datetime(2021, 1, 1)
end_time = datetime(2021, 2, 1)

# DataFrame of trade and quote data
single_history_df = qb.History(btcusd, start_time, end_time)
subset_history_df = qb.History([btcusd, ethusd], start_time, end_time)
all_history_df = qb.History(qb.Securities.Keys, start_time, end_time)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, btcusd, start_time, end_time)
subset_history_trade_bar_df = qb.History(TradeBar, [btcusd, ethusd], start_time, end_time)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, btcusd, start_time, end_time)
subset_history_quote_bar_df = qb.History(QuoteBar, [btcusd, ethusd], start_time, end_time)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of tick data
single_history_tick_df = qb.History(btcusd, start_time, end_time, Resolution.Tick)
subset_history_tick_df = qb.History([btcusd, ethusd], start_time, end_time, Resolution.Tick)
all_history_tick_df = qb.History(qb.Securities.Keys, start_time, end_time, Resolution.Tick)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](btcusd, start_time, end_time)
subset_history_trade_bars = qb.History[TradeBar]([btcusd, ethusd], start_time, end_time)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, start_time, end_time)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](btcusd, start_time, end_time, Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([btcusd, ethusd], start_time, end_time, Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, start_time, end_time, Resolution.Minute)

# Tick objects
single_history_ticks = qb.History[Tick](btcusd, start_time, end_time, Resolution.Tick)
subset_history_ticks = qb.History[Tick]([btcusd, ethusd], start_time, end_time, Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, start_time, end_time, Resolution.Tick)</pre>
</div>

<h3>Resolutions</h3>
<p>
 The following table shows the available resolutions and data formats for Crypto Futures contract subscriptions:
</p>
<table class="qc-table table" id="resolution-and-data-formats">
 <thead>
  <tr>
   <th>
    Resolution
   </th>
   <th>
    TradeBar
   </th>
   <th>
    QuoteBar
   </th>
   <th>
    Trade Tick
   </th>
   <th>
    Quote Tick
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <code>
     Tick
    </code>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Second
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Minute
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Hour
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Daily
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
 </tbody>
</table>
<style>
 #resolution-and-data-formats td:nth-child(2), 
#resolution-and-data-formats th:nth-child(2), 
#resolution-and-data-formats td:nth-child(3), 
#resolution-and-data-formats th:nth-child(3), 
#resolution-and-data-formats td:nth-child(4), 
#resolution-and-data-formats th:nth-child(4), 
#resolution-and-data-formats td:last-child, 
#resolution-and-data-formats th:last-child {
    text-align: center;
}
</style>

<h3>Markets</h3>
<p>
 Crypto Futures are currently only available on
 <code>
  Market.Binance
 </code>
 .
</p>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/crypto-futures#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. The process to manipulate the historical data depends on its data type. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/crypto-futures#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data. The process to manipulate the historical data depends on its data type.
</p>
<h4>
 DataFrame Objects
</h4>
<p class="python">
 If the
 <code>
  History
 </code>
 method returns a
 <code>
  DataFrame
 </code>
 , the first level of the
 <code>
  DataFrame
 </code>
 index is the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/security-identifiers#02-Encoding-Symbols">
  encoded Crypto Future Symbol
 </a>
 and the second level is the
 <code>
  EndTime
 </code>
 of the data sample. The columns of the
 <code>
  DataFrame
 </code>
 are the data properties.
</p>
<img alt="DataFrame of two Crypto Futures contracts" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/crypto-future-research-data-1.jpg"/>
<p class="python">
 To select the historical data of a single Crypto Future, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the Crypto Future
 <code>
  Symbol
 </code>
 .
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[btcusd]  # or all_history_df.loc['BTCUSD']
</pre>
</div>
<img alt="DataFrame of one Crypto Future" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/crypto-future-research-data-2.jpg"/>
<p class="python">
 To select a column of the
 <code>
  DataFrame
 </code>
 , index it with the column name.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[btcusd]['close']
</pre>
</div>
<img alt="Series of close values" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/crypto-future-research-data-3.jpg"/>
<p class="python">
 If you request historical data for multiple Crypto Futures contracts, you can transform the
 <code>
  DataFrame
 </code>
 so that it's a time series of close values for all of the Crypto Futures contracts. To transform the
 <code>
  DataFrame
 </code>
 , select the column you want to display for each Crypto Futures contract and then call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html" rel="nofollow" target="_blank">
  unstack
 </a>
 method.
</p>
<div class="section-example-container python">
 <pre class="python">all_history_df['close'].unstack(level=0)</pre>
</div>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 is transformed so that the column indices are the
 <code>
  Symbol
 </code>
 of each Crypto Futures contract and each row contains the close value.
</p>
<img alt="DataFrame of one Crypto Future" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/crypto-future-research-data-4.jpg"/>
<p class="csharp">
 The historical data methods don't return DataFrame objects, but you can create one for efficient vectorized data wrangling.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">using Microsoft.Data.Analysis; 

var columns = new DataFrameColumn[] {
    new PrimitiveDataFrameColumn<datetime>("Time", history.Select(x =&gt; x[btcusd].EndTime)),
    new DecimalDataFrameColumn("BTCUSD Open", history.Select(x =&gt; x[btcusd].Open)),
    new DecimalDataFrameColumn("BTCUSD High", history.Select(x =&gt; x[btcusd].High)),
    new DecimalDataFrameColumn("BTCUSD Low", history.Select(x =&gt; x[btcusd].Low)),
    new DecimalDataFrameColumn("BTCUSD Close", history.Select(x =&gt; x[btcusd].Close))
};
var df = new DataFrame(columns);
df</datetime></pre>
</div>
<img alt="Historical C# dataframe" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/crypto-future-research-data-c-1.png"/>
<p class="csharp">
 To select a particular column of the DataFrame, index it with the column name.
</p>
<div class="section-example-container">
 <pre class="csharp">df["BTCUSD close"]</pre>
</div>
<img alt="Historical C# dataframe column" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/crypto-future-research-data-c-2.png"/>
<h4>
 Slice Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Slice
 </code>
 objects, iterate through the
 <code>
  Slice
 </code>
 objects to get each one. The
 <code>
  Slice
 </code>
 objects may not have data for all of your Crypto Future subscriptions. To avoid issues, check if the
 <code>
  Slice
 </code>
 contains data for your Crypto Futures contract before you index it with the Crypto Future
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice) {
    if (slice.Bars.ContainsKey(btcusd))
    {
        var tradeBar = slice.Bars[btcusd];
    }
    if (slice.QuoteBars.ContainsKey(btcusd))
    {
        var quoteBar = slice.QuoteBars[btcusd];
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
        if slice.Bars.ContainsKey(btcusd):
        trade_bar = slice.Bars[btcusd]
    if slice.QuoteBars.ContainsKey(btcusd):
        quote_bar = slice.QuoteBars[btcusd]
</pre>
</div>
<!---- ----->
<p>
 You can also iterate through each
 <code>
  TradeBar
 </code>
 and
 <code>
  QuoteBar
 </code>
 in the
 <code>
  Slice
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice)
{
    foreach (var kvp in slice.Bars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
    foreach (var kvp in slice.QuoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
    for kvp in slice.Bars:
        symbol = kvp.Key
        trade_bar = kvp.Value
    for kvp in slice.QuoteBars:
        symbol = kvp.Key
        quote_bar = kvp.Value
</pre>
</div>
<p class="csharp">
 You can also use LINQ to select each
 <code>
  TradeBar
 </code>
 in the
 <code>
  Slice
 </code>
 for a given
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">
var tradeBars = allHistorySlice.Where(slice =&gt; slice.Bars.ContainsKey(btcusd)).Select(slice =&gt; slice.Bars[btcusd]);
</pre>
</div>
<!---- ----->
<h4>
 TradeBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBar
 </code>
 objects, iterate through the
 <code>
  TradeBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBar in singleHistoryTradeBars)
{
    Console.WriteLine(tradeBar);
}</pre>
 <pre class="python">for trade_bar in single_history_trade_bars:
    print(trade_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBars
 </code>
 , iterate through the
 <code>
  TradeBars
 </code>
 to get the
 <code>
  TradeBar
 </code>
 of each Crypto Futures contract. The
 <code>
  TradeBars
 </code>
 may not have data for all of your Crypto Future subscriptions. To avoid issues, check if the
 <code>
  TradeBars
 </code>
 object contains data for your security before you index it with the Crypto Future
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    if (tradeBars.ContainsKey(btcusd))
    {
        var tradeBar = tradeBars[btcusd];
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    if trade_bars.ContainsKey(btcusd):
        trade_bar = trade_bars[btcusd]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  TradeBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    foreach (var kvp in tradeBars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    for kvp in trade_bars:
        symbol = kvp.Key
        trade_bar = kvp.Value<br/></pre>
</div>
<!---- ----->
<h4>
 QuoteBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBar
 </code>
 objects, iterate through the
 <code>
  QuoteBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBar in singleHistoryQuoteBars)
{
    Console.WriteLine(quoteBar);
}</pre>
 <pre class="python">for quote_bar in single_history_quote_bars:
    print(quote_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBars
 </code>
 , iterate through the
 <code>
  QuoteBars
 </code>
 to get the
 <code>
  QuoteBar
 </code>
 of each Crypto Futures contract. The
 <code>
  QuoteBars
 </code>
 may not have data for all of your Crypto Future subscriptions. To avoid issues, check if the
 <code>
  QuoteBars
 </code>
 object contains data for your security before you index it with the Crypto Future
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    if (quoteBars.ContainsKey(btcusd))
    {
        var quoteBar = quoteBars[btcusd];
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    if quote_bars.ContainsKey(btcusd):
        quote_bar = quote_bars[btcusd]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  QuoteBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    foreach (var kvp in quoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    for kvp in quote_bars:
        symbol = kvp.Key
        quote_bar = kvp.Value</pre>
</div>
<!---- ----->
<h4>
 Tick Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Tick
 </code>
 objects, iterate through the
 <code>
  Tick
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tick in singleHistoryTicks)
{
    Console.WriteLine(tick);
}</pre>
 <pre class="python">for tick in single_history_ticks:
    print(tick)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Ticks
 </code>
 , iterate through the
 <code>
  Ticks
 </code>
 to get the
 <code>
  Tick
 </code>
 of each Crypto Futures contract. The
 <code>
  Ticks
 </code>
 may not have data for all of your Crypto Future subscriptions. To avoid issues, check if the
 <code>
  Ticks
 </code>
 object contains data for your security before you index it with the Crypto Future
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    if (ticks.ContainsKey(btcusd))
    {
        var tick = ticks[btcusd];
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    if ticks.ContainsKey(btcusd):
        ticks = ticks[btcusd]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  Ticks
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    foreach (var kvp in ticks)
    {
        var symbol = kvp.Key;
        var tick = kvp.Value;
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    for kvp in ticks:
        symbol = kvp.Key
        tick = kvp.Value</pre>
</div>
<!---- ----->
<!---- ----->
<!---- ----->

<h3>Plot Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/crypto-futures#04-Get-Historical-Data">
  historical Crypto Futures data
 </a>
 to produce plots. You can use
 <span class="python">
  many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
 </span>
 <span class="csharp">
  <code>
   Plot.NET
  </code>
  package
 </span>
 to visualize data in various formats. For example, you can plot candlestick and line charts.
</p>
<h4>
 Candlestick Chart
 <br/>
</h4>
<p>
 Follow these steps to plot candlestick charts:
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(btcusd, datetime(2021, 11, 23), datetime(2021, 12, 8), Resolution.Daily).loc[btcusd]</pre>
  <pre class="csharp">var history = qb.History&lt;TradeBar&gt;(btcusd, new DateTime(2021, 11, 23), new DateTime(2021, 12, 8), Resolution.Daily);</pre>
 </div>
 <li>
  Import the
  <code class="python">
   plotly
  </code>
  <code class="csharp">
   Plotly.NET
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">import plotly.graph_objects as go</pre>
  <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
 <li>
  Create a
  <code>
   Candlestick
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">candlestick = go.Candlestick(x=history.index,
                             open=history['open'],
                             high=history['high'],
                             low=history['low'],
                             close=history['close'])</pre>
  <pre class="csharp">var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    history.Select(x =&gt; x.Open),
    history.Select(x =&gt; x.High),
    history.Select(x =&gt; x.Low),
    history.Select(x =&gt; x.Close),
    history.Select(x =&gt; x.EndTime)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">layout = go.Layout(title=go.layout.Title(text='BTCUSD 18R OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init("BTCUSD 18R OHLC");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="python">
  Create the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="python section-example-container">
  <pre>fig = go.Figure(data=[candlestick], layout=layout)</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Candlestick charts display the open, high, low, and close prices of the security.
 </p>
</ol>
<img alt="Candlestick plot of BTCUSD 18R OHLC" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-crypto-future-candlestick-plot.jpg"/>
<img alt="Candlestick plot of BTCUSD 18R OHLC" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-crypto-future-candlestick-plot-csharp.png"/>
<h4>
 Line Chart
</h4>
<p>
 Follow these steps to plot line charts using
 <span class="python">
  built-in methods
 </span>
 <span class="csharp">
  <code>
   Plotly.NET
  </code>
  package
 </span>
 :
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History([btcusd, ethusd], datetime(2021, 11, 23), datetime(2021, 12, 8), Resolution.Daily)</pre>
 </div>
 <li class="python">
  Select the data to plot.
 </li>
 <div class="python section-example-container">
  <pre>volume = history['volume'].unstack(level=0)</pre>
 </div>
 <li class="python">
  Call the
  <code>
   plot
  </code>
  method on the
  <code>
   pandas
  </code>
  object.
 </li>
 <div class="python section-example-container">
  <pre>volume.plot(title="Volume", figsize=(15, 10))</pre>
 </div>
 <li class="csharp">
  Create
  <code>
   Line
  </code>
  charts.
 </li>
 <div class="csharp section-example-container">
  <pre>var chart1 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x[btcusd].EndTime),
    history.Select(x =&gt; x[btcusd].Volume),
    Name: "BTCUSD 18R"
);
var chart2 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x[ethusd].EndTime),
    history.Select(x =&gt; x[ethusd].Volume),
    Name: "ETHUSD 18R"
);</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Volume");
Title title = Title.init("BTCUSD 18R &amp; ETHUSD 18R Volume");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="csharp">
  Combine the charts and assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>var chart = Plotly.NET.Chart.Combine(new []{chart1, chart2});
chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Line charts display the value of the property you selected in a time series.
 </p>
</ol>
<img alt="Line chart of volume of BTCUSD, &amp; ETHUSD" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-crypto-future-volume-plot.jpg"/>
<img alt="Line chart of volume of BTCUSD, &amp; ETHUSD" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-crypto-future-volume-plot-csharp.png"/>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.7"><h3>3.7 Futures</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical Futures data.
</p>

<h3>Create Subscriptions</h3>
<p>
 Follow these steps to subscribe to a Future security:
</p>
<ol>
 <li class="csharp">
  Load the required assembly files and data types.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Data.Market;
using QuantConnect.Algorithm;
using QuantConnect.Securities;
using QuantConnect.Securities.Future;
using QuantConnect.Research;
using Microsoft.Data.Analysis;</pre>
 </div>
 <li>
  Create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Call the
  <code>
   AddFuture
  </code>
  method with a ticker, resolution, and
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/universes/futures#12-Continous-Contracts">
   contract rollover settings
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var future = qb.AddFuture(Futures.Indices.SP500EMini, Resolution.Minute,
                dataNormalizationMode: DataNormalizationMode.BackwardsRatio,
                dataMappingMode: DataMappingMode.LastTradingDay,
                contractDepthOffset: 0);</pre>
  <pre class="python">future = qb.AddFuture(Futures.Indices.SP500EMini, Resolution.Minute,
                dataNormalizationMode = DataNormalizationMode.BackwardsRatio,
                dataMappingMode = DataMappingMode.LastTradingDay,
                contractDepthOffset = 0)</pre>
 </div>
 <p>
  To view the available tickers in the US Futures dataset, see
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/datasets/algoseek/us-futures#05-Supported-Assets">
   Supported Assets
  </a>
  .
 </p>
 <p>
  If you omit any of the arguments after the ticker, see the following table for their default values:
 </p>
 <table class="qc-table table">
  <thead>
   <tr>
    <th>
     Argument
    </th>
    <th>
     Default Value
    </th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>
     <code>
      resolution
     </code>
    </td>
    <td>
     <code>
      Resolution.Minute
     </code>
    </td>
   </tr>
   <tr>
    <td>
     <code>
      dataNormalizationMode
     </code>
    </td>
    <td>
     <code>
      DataNormalizationMode.Adjusted
     </code>
    </td>
   </tr>
   <tr>
    <td>
     <code>
      dataMappingMode
     </code>
    </td>
    <td>
     <code>
      DataMappingMode.OpenInterest
     </code>
    </td>
   </tr>
   <tr>
    <td>
     <code>
      contractDepthOffset
     </code>
    </td>
    <td>
     0
    </td>
   </tr>
  </tbody>
 </table>
 <li>
  <i>
   (Optional)
  </i>
  Set a
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/universes/futures#13-Filter-Contracts">
   contract filter
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">future.SetFilter(0, 90);</pre>
  <pre class="python">future.SetFilter(0, 90)</pre>
 </div>
 <p>
  If you don't call the
  <code>
   SetFilter
  </code>
  method, the
  <code>
   GetFutureHistory
  </code>
  method won't return historical data.
 </p>
</ol>
<p>
 If you want historical data on individual contracts and their
 <code>
  OpenInterest
 </code>
 , follow these steps to subscribe to individual Future contracts:
</p>
<ol>
 <li>
  Call the
  <code>
   GetFuturesContractList
  </code>
  method with the underlying
  <code>
   Future
  </code>
  <code>
   Symbol
  </code>
  and a
  <code class="python">
   datetime
  </code>
  <code class="csharp">
   DateTime
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var startDate = new DateTime(2021,12,20);
var symbols = qb.FutureChainProvider.GetFutureContractList(future.Symbol, startDate);</pre>
  <pre class="python">start_date = datetime(2021,12,20)
symbols = qb.FutureChainProvider.GetFutureContractList(future.Symbol, start_date)</pre>
 </div>
 <p>
  This method returns a list of
  <code>
   Symbol
  </code>
  objects that reference the Future contracts that were trading at the given time. If you set a contract filter with
  <code>
   SetFilter
  </code>
  , it doesn't affect the results of
  <code>
   GetFutureContractList
  </code>
  .
 </p>
 <li>
  Select the
  <code>
   Symbol
  </code>
  of the
  <code>
   FutureContract
  </code>
  object(s) for which you want to get historical data.
 </li>
 <p>
  For example, select the
  <code>
   Symbol
  </code>
  of the contract with the closest expiry.
  <br/>
 </p>
 <div class="section-example-container">
  <pre class="csharp">var contractSymbol = symbols.OrderBy(s =&gt; s.ID.Date).FirstOrDefault();</pre>
  <pre class="python">contract_symbol = sorted(symbols, key=lambda s: s.ID.Date)[0]</pre>
 </div>
 <li>
  Call the
  <code>
   AddFutureContract
  </code>
  method with an
  <code>
   FutureContract
  </code>
  <code>
   Symbol
  </code>
  and disable fill-forward.
 </li>
 <div class="section-example-container">
  <pre class="csharp">qb.AddFutureContract(contractSymbol, fillForward: false);</pre>
  <pre class="python">qb.AddFutureContract(contract_symbol, fillForward = False)</pre>
 </div>
 <p>
  Disable fill-forward because there are only a few
  <code>
   OpenInterest
  </code>
  data points per day.
 </p>
</ol>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/futures#03-Create-Subscriptions">
  subscription
 </a>
 before you can request historical data for Futures contracts. On the time dimension, you can request an amount of historical data based on a trailing number of bars, a trailing period of time, or a defined period of time. On the contract dimension, you can request historical data for a single contract, a subset of the contracts you created subscriptions for in your notebook, or all of the contracts in your notebook.
</p>
<p>
 Before you request historical data, call the
 <code>
  SetStartDate
 </code>
 method with a
 <code class="python">
  datetime
 </code>
 <code class="csharp">
  DateTime
 </code>
 to reduce the risk of
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/glossary#16-look-ahead-bias">
  look-ahead bias
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">qb.SetStartDate(startDate);</pre>
 <pre class="python">qb.SetStartDate(start_date)</pre>
</div>
<p>
 If you call the
 <code>
  SetStartDate
 </code>
 method, the date that you pass to the method is the latest date for which your history requests will return data.
</p>
<h4>
 Trailing Number of Bars
</h4>
<p>
 To get historical data for a number of trailing bars, call the
 <code>
  History
 </code>
 method with the contract
 <code>
  Symbol
 </code>
 object(s) and an integer.
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(contractSymbol, 10);
var subsetHistorySlice = qb.History(new[] {contractSymbol}, 10);
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(contractSymbol, 10);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {contractSymbol}, 10);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, 10);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(contractSymbol, 10);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {contractSymbol}, 10);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, 10);

// OpenInterest objects
var singleHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(contractSymbol, 400);
var subsetHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(new[] {contractSymbol}, 400);
var allHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(qb.Securities.Keys, 400);</pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History(contract_symbol, 10)
subset_history_df = qb.History([contract_symbol], 10)
all_history_df = qb.History(qb.Securities.Keys, 10)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, contract_symbol, 10)
subset_history_trade_bar_df = qb.History(TradeBar, [contract_symbol], 10)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, 10)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, contract_symbol, 10)
subset_history_quote_bar_df = qb.History(QuoteBar, [contract_symbol], 10)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, 10)

# DataFrame of open interest data
single_history_open_interest_df = qb.History(OpenInterest, contract_symbol, 400)
subset_history_open_interest_df = qb.History(OpenInterest, [contract_symbol], 400)
all_history_open_interest_df = qb.History(OpenInterest, qb.Securities.Keys, 400)

# Slice objects
all_history_slice = qb.History(10)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](contract_symbol, 10)
subset_history_trade_bars = qb.History[TradeBar]([contract_symbol], 10)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, 10)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](contract_symbol, 10)
subset_history_quote_bars = qb.History[QuoteBar]([contract_symbol], 10)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, 10)

# OpenInterest objects
single_history_open_interest = qb.History[OpenInterest](contract_symbol, 400)
subset_history_open_interest = qb.History[OpenInterest]([contract_symbol], 400)
all_history_open_interest = qb.History[OpenInterest](qb.Securities.Keys, 400)</pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<p>
 To get historical data for the continous Futures contract, in the preceding history requests, replace
 <code class="python">
  contract_symbol
 </code>
 <code class="csharp">
  contractSymbol
 </code>
 with
 <code>
  future.Symbol
 </code>
 .
</p>
<h4>
 Trailing Period of Time
</h4>
<p>
 To get historical data for a trailing period of time, call the
 <code>
  History
 </code>
 method with the contract
 <code>
  Symbol
 </code>
 object(s) and a
 <code class="csharp">
  TimeSpan
 </code>
 <code class="python">
  timedelta
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(contractSymbol, TimeSpan.FromDays(3));
var subsetHistorySlice = qb.History(new[] {contractSymbol}, TimeSpan.FromDays(3));
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(contractSymbol, TimeSpan.FromDays(3));
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {contractSymbol}, TimeSpan.FromDays(3));
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(TimeSpan.FromDays(3));

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(contractSymbol, TimeSpan.FromDays(3), Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {contractSymbol}, TimeSpan.FromDays(3), Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Minute);

// Tick objects
var singleHistoryTicks = qb.History<tick>(contractSymbol, TimeSpan.FromDays(3), Resolution.Tick);
var subsetHistoryTicks = qb.History<tick>(new[] {contractSymbol}, TimeSpan.FromDays(3), Resolution.Tick);
var allHistoryTicks = qb.History<tick>(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Tick);

// OpenInterest objects
var singleHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(contractSymbol, TimeSpan.FromDays(2));
var subsetHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(new[] {contractSymbol}, TimeSpan.FromDays(2));
var allHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(qb.Securities.Keys, TimeSpan.FromDays(2));</tick></tick></tick></pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History(contract_symbol, timedelta(days=3))
subset_history_df = qb.History([contract_symbol], timedelta(days=3))
all_history_df = qb.History(qb.Securities.Keys, timedelta(days=3))

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, contract_symbol, timedelta(days=3))
subset_history_trade_bar_df = qb.History(TradeBar, [contract_symbol], timedelta(days=3))
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, contract_symbol, timedelta(days=3))
subset_history_quote_bar_df = qb.History(QuoteBar, [contract_symbol], timedelta(days=3))
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of open interest data
single_history_open_interest_df = qb.History(OpenInterest, contract_symbol, timedelta(days=3))
subset_history_open_interest_df = qb.History(OpenInterest, [contract_symbol], timedelta(days=3))
all_history_open_interest_df = qb.History(OpenInterest, qb.Securities.Keys, timedelta(days=3))

# Slice objects
all_history_slice = qb.History(timedelta(days=3))

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](contract_symbol, timedelta(days=3))
subset_history_trade_bars = qb.History[TradeBar]([contract_symbol], timedelta(days=3))
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, timedelta(days=3))

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](contract_symbol, timedelta(days=3), Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([contract_symbol], timedelta(days=3), Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, timedelta(days=3), Resolution.Minute) 

# Tick objects
single_history_ticks = qb.History[Tick](contract_symbol, timedelta(days=3), Resolution.Tick)
subset_history_ticks = qb.History[Tick]([contract_symbol], timedelta(days=3), Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, timedelta(days=3), Resolution.Tick)

# OpenInterest objects
single_history_open_interest = qb.History[OpenInterest](contract_symbol, timedelta(days=2))
subset_history_open_interest = qb.History[OpenInterest]([contract_symbol], timedelta(days=2))
all_history_open_interest = qb.History[OpenInterest](qb.Securities.Keys, timedelta(days=2))</pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<p>
 To get historical data for the continous Futures contract, in the preceding history requests, replace
 <code class="python">
  contract_symbol
 </code>
 <code class="csharp">
  contractSymbol
 </code>
 with
 <code>
  future.Symbol
 </code>
 .
</p>
<h4>
 Defined Period of Time
</h4>
<p>
 To get historical data for individual Futures contracts during a specific period of time, call the
 <code>
  History
 </code>
 method with the Futures contract
 <code>
  Symbol
 </code>
 object(s), a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 .  The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2021, 12, 1);
var endTime = new DateTime(2021, 12, 31);

// Slice objects
var singleHistorySlice = qb.History(contractSymbol, startTime, endTime);
var subsetHistorySlice = qb.History(new[] {contractSymbol}, startTime, endTime);
var allHistorySlice = qb.History(startTime, endTime);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(contractSymbol, startTime, endTime);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {contractSymbol}, startTime, endTime);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, startTime, endTime);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(contractSymbol, startTime, endTime, Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {contractSymbol}, startTime, endTime, Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Minute);

// Tick objects
var singleHistoryTicks = qb.History<tick>(contractSymbol, startTime, endTime, Resolution.Tick);
var subsetHistoryTicks = qb.History<tick>(new[] {contractSymbol}, startTime, endTime, Resolution.Tick);
var allHistoryTicks = qb.History<tick>(qb.Securities.Keys, startTime, endTime, Resolution.Tick);

// OpenInterest objects
var singleHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(contractSymbol, startTime, endTime);
var subsetHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(new[] {contractSymbol}, startTime, endTime);
var allHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(qb.Securities.Keys, startTime, endTime);</tick></tick></tick></pre>
 <pre class="python">start_time = datetime(2021, 12, 1)
end_time = datetime(2021, 12, 31)

# DataFrame of trade and quote data
single_history_df = qb.History(contract_symbol, start_time, end_time)
subset_history_df = qb.History([contract_symbol], start_time, end_time)
all_history_df = qb.History(qb.Securities.Keys, start_time, end_time)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, contract_symbol, start_time, end_time)
subset_history_trade_bar_df = qb.History(TradeBar, [contract_symbol], start_time, end_time)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, contract_symbol, start_time, end_time)
subset_history_quote_bar_df = qb.History(QuoteBar, [contract_symbol], start_time, end_time)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of open interest data
single_history_open_interest_df = qb.History(OpenInterest, contract_symbol, start_time, end_time)
subset_history_open_interest_df = qb.History(OpenInterest, [contract_symbol], start_time, end_time)
all_history_trade_open_interest_df = qb.History(OpenInterest, qb.Securities.Keys, start_time, end_time)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](contract_symbol, start_time, end_time)
subset_history_trade_bars = qb.History[TradeBar]([contract_symbol], start_time, end_time)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, start_time, end_time)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](contract_symbol, start_time, end_time, Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([contract_symbol], start_time, end_time, Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, start_time, end_time, Resolution.Minute)

# Tick objects
single_history_ticks = qb.History[Tick](contract_symbol, start_time, end_time, Resolution.Tick)
subset_history_ticks = qb.History[Tick]([contract_symbol], start_time, end_time, Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, start_time, end_time, Resolution.Tick)

# OpenInterest objects
single_history_open_interest = qb.History[OpenInterest](contract_symbol, start_time, end_time)
subset_history_open_interest = qb.History[OpenInterest]([contract_symbol], start_time, end_time)
all_history_open_interest = qb.History[OpenInterest](qb.Securities.Keys, start_time, end_time)</pre>
</div>
<p>
 To get historical data for the continous Futures contract, in the preceding history requests, replace
 <code class="python">
  contract_symbol
 </code>
 <code class="csharp">
  contractSymbol
 </code>
 with
 <code>
  future.Symbol
 </code>
 .
</p>
<p>
 To get historical data for all of the Futures contracts that pass your
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/futures#03-Create-Subscriptions">
  filter
 </a>
 during a specific period of time, call the
 <code>
  GetFutureHistory
 </code>
 method with the
 <code>
  Symbol
 </code>
 object of the continuous Future, a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">future_history = qb.GetFutureHistory(future.Symbol, end_time-timedelta(days=2), end_time, Resolution.Minute, fillForward=False, extendedMarketHours=False)</pre>
 <pre class="csharp">var futureHistory = qb.GetFutureHistory(future.Symbol, endTime-TimeSpan.FromDays(2), endTime, Resolution.Minute, fillForward: False, extendedMarketHours: False);</pre>
</div>
<p>
 The preceding calls return data that have a timestamp within the defined period of time.
</p>

<h3>Resolutions</h3>
<p>
 The following table shows the available resolutions and data formats for Futures subscriptions:
</p>
<table class="qc-table table" id="resolution-and-data-formats">
 <thead>
  <tr>
   <th>
    Resolution
   </th>
   <th>
    TradeBar
   </th>
   <th>
    QuoteBar
   </th>
   <th>
    Trade Tick
   </th>
   <th>
    Quote Tick
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <code>
     Tick
    </code>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Second
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Minute
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Hour
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Daily
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
 </tbody>
</table>
<style>
 #resolution-and-data-formats td:nth-child(2), 
#resolution-and-data-formats th:nth-child(2), 
#resolution-and-data-formats td:nth-child(3), 
#resolution-and-data-formats th:nth-child(3), 
#resolution-and-data-formats td:nth-child(4), 
#resolution-and-data-formats th:nth-child(4), 
#resolution-and-data-formats td:last-child, 
#resolution-and-data-formats th:last-child {
    text-align: center;
}
</style>

<h3>Markets</h3>
<p>
 The following
 <code>
  Market
 </code>
 enumeration members are available for Futures:
</p>
<div data-fields="NYMEX,CBOT,ICE,CFE,India,COMEX,CME,SGX,NYSELIFFE" data-tree="QuantConnect.Market">
</div>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/futures#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. The process to manipulate the historical data depends on its data type. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/futures#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data. The process to manipulate the historical data depends on its data type.
</p>
<h4>
 DataFrame Objects
</h4>
<p class="python">
 If your history request returns a
 <code>
  DataFrame
 </code>
 , the
 <code>
  DataFrame
 </code>
 has the following index levels:
</p>
<ol class="python">
 <li>
  Contract expiry
 </li>
 <li>
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/security-identifiers#02-Encoding-Symbols">
   Encoded contract Symbol
  </a>
 </li>
 <li>
  The
  <code>
   EndTime
  </code>
  of the data sample
 </li>
</ol>
<p class="python">
 The columns of the
 <code>
  DataFrame
 </code>
 are the data properties. Depending on how you request data, the
 <code>
  DataFrame
 </code>
 may contain data for the continuous Futures contract. The continuous contract doesn't expire, so the default expiry date of December 30, 1899 doesn't have any practical meaning.
</p>
<img alt="Historical data dataframe" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/futures-research-data-1.jpg"/>
<p class="python">
 To select the rows of the contract(s) that expire at a specific time, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the expiry time.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[datetime(2022, 3, 18, 13, 30)]</pre>
</div>
<img alt="Historical data dataframe of selected date" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/futures-research-data-2.jpg"/>
<p class="python">
 If you remove the first index level, you can index the
 <code>
  DataFrame
 </code>
 with just the contract
 <code>
  Symbol
 </code>
 , similiar to how you would with non-derivative asset classes. To remove the first index level, call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.droplevel.html" rel="nofollow" target="_blank">
  droplevel
 </a>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.index = all_history_df.index.droplevel(0)</pre>
</div>
<img alt="Historical data dataframe of dropped first column" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/futures-research-data-3.jpg"/>
<p class="python">
 To select the historical data of a single Futures contract, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the contract
 <code>
  Symbol
 </code>
 .
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[contract_symbol]
</pre>
</div>
<img alt="DataFrame of one Futures" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/futures-research-data-4.jpg"/>
<p class="python">
 To select a column of the
 <code>
  DataFrame
 </code>
 , index it with the column name.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[contract_symbol]['close']
</pre>
</div>
<img alt="Series of close values" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/futures-research-data-5.jpg"/>
<p class="python">
 If you request historical data for multiple Futures contracts, you can transform the
 <code>
  DataFrame
 </code>
 so that it's a time series of close values for all of the Futures contracts. To transform the
 <code>
  DataFrame
 </code>
 , select the column you want to display for each Futures contract and then call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html" rel="nofollow" target="_blank">
  unstack
 </a>
 method.
</p>
<div class="section-example-container python">
 <pre class="python">all_history_df['close'].unstack(level=0)</pre>
</div>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 is transformed so that the column indices are the
 <code>
  Symbol
 </code>
 of each security and each row contains the close  value.
</p>
<img alt="Historical data dataframe with column indexed by symbols" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/futures-research-data-6.jpg"/>
<p class="csharp">
 The historical data methods don't return DataFrame objects, but you can create one for efficient vectorized data wrangling.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">using Microsoft.Data.Analysis; 

var columns = new DataFrameColumn[] {
    new PrimitiveDataFrameColumn<datetime>("Time", history.Select(x =&gt; x[contractSymbol].EndTime)),
    new DecimalDataFrameColumn(" Open", history.Select(x =&gt; x[contractSymbol].Open)),
    new DecimalDataFrameColumn(" High", history.Select(x =&gt; x[contractSymbol].High)),
    new DecimalDataFrameColumn(" Low", history.Select(x =&gt; x[contractSymbol].Low)),
    new DecimalDataFrameColumn(" Close", history.Select(x =&gt; x[contractSymbol].Close))
};
var df = new DataFrame(columns);
df</datetime></pre>
</div>
<img alt="Historical C# dataframe" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/futures-research-data-c-1.png"/>
<p class="csharp">
 To select a particular column of the DataFrame, index it with the column name.
</p>
<div class="section-example-container">
 <pre class="csharp">df[" close"]</pre>
</div>
<img alt="Historical C# dataframe column" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/futures-research-data-c-2.png"/>
<h4>
 Slice Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Slice
 </code>
 objects, iterate through the
 <code>
  Slice
 </code>
 objects to get each one. The
 <code>
  Slice
 </code>
 objects may not have data for all of your Futures subscriptions. To avoid issues, check if the
 <code>
  Slice
 </code>
 contains data for your Futures contract before you index it with the Futures
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice) {
    if (slice.Bars.ContainsKey(contractSymbol))
    {
        var tradeBar = slice.Bars[contractSymbol];
    }
    if (slice.QuoteBars.ContainsKey(contractSymbol))
    {
        var quoteBar = slice.QuoteBars[contractSymbol];
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
        if slice.Bars.ContainsKey(contract_symbol):
        trade_bar = slice.Bars[contract_symbol]
    if slice.QuoteBars.ContainsKey(contract_symbol):
        quote_bar = slice.QuoteBars[contract_symbol]
</pre>
</div>
<!---- ----->
<p>
 You can also iterate through each
 <code>
  TradeBar
 </code>
 and
 <code>
  QuoteBar
 </code>
 in the
 <code>
  Slice
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice)
{
    foreach (var kvp in slice.Bars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
    foreach (var kvp in slice.QuoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
    for kvp in slice.Bars:
        symbol = kvp.Key
        trade_bar = kvp.Value
    for kvp in slice.QuoteBars:
        symbol = kvp.Key
        quote_bar = kvp.Value
</pre>
</div>
<p class="csharp">
 You can also use LINQ to select each
 <code>
  TradeBar
 </code>
 in the
 <code>
  Slice
 </code>
 for a given
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">
var tradeBars = allHistorySlice.Where(slice =&gt; slice.Bars.ContainsKey(contractSymbol)).Select(slice =&gt; slice.Bars[contractSymbol]);
</pre>
</div>
<!---- ----->
<h4>
 TradeBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBar
 </code>
 objects, iterate through the
 <code>
  TradeBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBar in singleHistoryTradeBars)
{
    Console.WriteLine(tradeBar);
}</pre>
 <pre class="python">for trade_bar in single_history_trade_bars:
    print(trade_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBars
 </code>
 , iterate through the
 <code>
  TradeBars
 </code>
 to get the
 <code>
  TradeBar
 </code>
 of each Futures contract. The
 <code>
  TradeBars
 </code>
 may not have data for all of your Futures subscriptions. To avoid issues, check if the
 <code>
  TradeBars
 </code>
 object contains data for your security before you index it with the Futures
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    if (tradeBars.ContainsKey(contractSymbol))
    {
        var tradeBar = tradeBars[contractSymbol];
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    if trade_bars.ContainsKey(contract_symbol):
        trade_bar = trade_bars[contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  TradeBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    foreach (var kvp in tradeBars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    for kvp in trade_bars:
        symbol = kvp.Key
        trade_bar = kvp.Value<br/></pre>
</div>
<!---- ----->
<h4>
 QuoteBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBar
 </code>
 objects, iterate through the
 <code>
  QuoteBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBar in singleHistoryQuoteBars)
{
    Console.WriteLine(quoteBar);
}</pre>
 <pre class="python">for quote_bar in single_history_quote_bars:
    print(quote_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBars
 </code>
 , iterate through the
 <code>
  QuoteBars
 </code>
 to get the
 <code>
  QuoteBar
 </code>
 of each Futures contract. The
 <code>
  QuoteBars
 </code>
 may not have data for all of your Futures subscriptions. To avoid issues, check if the
 <code>
  QuoteBars
 </code>
 object contains data for your security before you index it with the Futures
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    if (quoteBars.ContainsKey(contractSymbol))
    {
        var quoteBar = quoteBars[contractSymbol];
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    if quote_bars.ContainsKey(contract_symbol):
        quote_bar = quote_bars[contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  QuoteBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    foreach (var kvp in quoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    for kvp in quote_bars:
        symbol = kvp.Key
        quote_bar = kvp.Value</pre>
</div>
<!---- ----->
<h4>
 Tick Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Tick
 </code>
 objects, iterate through the
 <code>
  Tick
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tick in singleHistoryTicks)
{
    Console.WriteLine(tick);
}</pre>
 <pre class="python">for tick in single_history_ticks:
    print(tick)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Ticks
 </code>
 , iterate through the
 <code>
  Ticks
 </code>
 to get the
 <code>
  Tick
 </code>
 of each Futures contract. The
 <code>
  Ticks
 </code>
 may not have data for all of your Futures subscriptions. To avoid issues, check if the
 <code>
  Ticks
 </code>
 object contains data for your security before you index it with the Futures
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    if (ticks.ContainsKey(contractSymbol))
    {
        var tick = ticks[contractSymbol];
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    if ticks.ContainsKey(contract_symbol):
        ticks = ticks[contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  Ticks
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    foreach (var kvp in ticks)
    {
        var symbol = kvp.Key;
        var tick = kvp.Value;
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    for kvp in ticks:
        symbol = kvp.Key
        tick = kvp.Value</pre>
</div>
<!---- ----->
<h4>
 OpenInterest Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  OpenInterest
 </code>
 objects, iterate through the
 <code>
  OpenInterest
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var openInterest in singleHistoryOpenInterest)
{
    Console.WriteLine(openInterest);
}</pre>
 <pre class="python">for open_interest in single_history_open_interest:
    print(open_interest)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns a dictionary of
 <code>
  OpenInterest
 </code>
 objects, iterate through the dictionary to get the
 <code>
  OpenInterest
 </code>
 of each Futures contract. The dictionary of
 <code>
  OpenInterest
 </code>
 objects may not have data for all of your Futures contract subscriptions. To avoid issues, check if the dictionary contains data for your contract before you index it with the Futures contract
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var openInterestDict in allHistoryOpenInterest)
{
    if (openInterestDict.ContainsKey(contractSymbol))
    {
        var openInterest = openInterestDict[contractSymbol];
    }
}</pre>
 <pre class="python">for open_interest_dict in all_history_open_interest:
    if open_interest_dict.ContainsKey(contract_symbol):
        open_interest = open_interest_dict[contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  OpenInterest
 </code>
 dictionaries.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var openInterestDict in allHistoryOpenInterest)
{
    foreach (var kvp in openInterestDict)
    {
        var symbol = kvp.Key;
        var openInterest = kvp.Value;
    }
}</pre>
 <pre class="python">for open_interest_dict in all_history_open_interest:
    for kvp in open_interest_dict:
        symbol = kvp.Key
        open_interest = kvp.Value</pre>
</div>
<!---- ----->
<!---- ----->
<h4>
 FutureHistory Objects
</h4>
<p>
 The
 <code>
  GetFutureHistory
 </code>
 method returns a
 <code>
  FutureHistory
 </code>
 object. To get each
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/time-modeling/timeslices">
  slice
 </a>
 in the
 <code>
  FutureHistory
 </code>
 object, iterate through it.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in futureHistory)
{
    foreach (var kvp in slice.FuturesChains)
    {
        var continuousContractSymbol = kvp.Key;
        var chain = kvp.Value;
        foreach (var contract in chain)
        {
            
        }
    }
}</pre>
 <pre class="python">for slice in future_history:
    for continuous_contract_symbol, chain in slice.FuturesChains.items(): 
        for contract in chain:
            pass</pre>
</div>
<p class="python">
 To convert the
 <code>
  FutureHistory
 </code>
 object to a
 <code>
  DataFrame
 </code>
 that contains the trade and quote information of each contract, call the
 <code>
  GetAllData
 </code>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">future_history.GetAllData()</pre>
</div>
<p class="python">
 To get the expiration dates of all the contracts in an
 <code>
  FutureHistory
 </code>
 object, call the
 <code>
  GetExpiryDates
 </code>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">future_history.GetExpiryDates()</pre>
</div>

<h3>Plot Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/futures#04-Get-Historical-Data">
  historical Futures data
 </a>
 to produce plots. You can use
 <span class="python">
  many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
 </span>
 <span class="csharp">
  <code>
   Plot.NET
  </code>
  package
 </span>
 to visualize data in various formats. For example, you can plot candlestick and line charts.
</p>
<h4>
 Candlestick Chart
 <br/>
</h4>
<p>
 Follow these steps to plot candlestick charts:
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(contract_symbol, datetime(2021, 12, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
  <pre class="csharp">var history = qb.History&lt;TradeBar&gt;(contractSymbol, new DateTime(2021, 12, 1), new DateTime(2021, 12, 31), Resolution.Daily);</pre>
 </div>
 <li class="python">
  Drop the first two index levels.
 </li>
 <div class="python section-example-container">
  <pre>history.index = history.index.droplevel([0, 1])</pre>
 </div>
 <li>
  Import the
  <code class="python">
   plotly
  </code>
  <code class="csharp">
   Plotly.NET
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">import plotly.graph_objects as go</pre>
  <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
 <li>
  Create a
  <code>
   Candlestick
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">candlestick = go.Candlestick(x=history.index,
                             open=history['open'],
                             high=history['high'],
                             low=history['low'],
                             close=history['close'])</pre>
  <pre class="csharp">var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    history.Select(x =&gt; x.Open),
    history.Select(x =&gt; x.High),
    history.Select(x =&gt; x.Low),
    history.Select(x =&gt; x.Close),
    history.Select(x =&gt; x.EndTime)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">layout = go.Layout(title=go.layout.Title(text=f'{contract_symbol.Value} OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{contractSymbol} OHLC");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="python">
  Create the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="python section-example-container">
  <pre>fig = go.Figure(data=[candlestick], layout=layout)</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Candlestick charts display the open, high, low, and close prices of the contract.
 </p>
</ol>
<img alt="Candlestick plot of ES18H22 OHLC" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/futures-candlestick-plot.jpg"/>
<img alt="Candlestick plot of ES18H22 OHLC" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/futures-candlestick-plot-csharp.png"/>
<h4>
 Line Chart
</h4>
<p>
 Follow these steps to plot line charts using
 <span class="python">
  built-in methods
 </span>
 <span class="csharp">
  <code>
   Plotly.NET
  </code>
  package
 </span>
 :
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(symbols, datetime(2021, 12, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
  <pre class="csharp">var history = qb.History&lt;OpenInterest&gt;(contractSymbol, new DateTime(2021, 12, 1), new DateTime(2021, 12, 31));</pre>
 </div>
 <li class="python">
  Drop the first index level.
 </li>
 <div class="python section-example-container">
  <pre>history.index = history.index.droplevel(0)</pre>
 </div>
 <li class="python">
  Select data to plot.
 </li>
 <div class="python section-example-container">
  <pre>closing_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li class="python">
  Rename the columns to be the
  <code>
   Symbol
  </code>
  of each contract.
 </li>
 <div class="python section-example-container">
  <pre>closing_prices.columns = [Symbol.GetAlias(SecurityIdentifier.Parse(x)) for x in closing_prices.columns]</pre>
 </div>
 <li class="python">
  Call the
  <code>
   plot
  </code>
  method on the
  <code>
   pandas
  </code>
  object.
 </li>
 <div class="python section-example-container">
  <pre>closing_prices.plot(title="Close", figsize=(15, 8))</pre>
 </div>
 <li class="csharp">
  Create
  <code>
   Line
  </code>
  charts.
 </li>
 <div class="csharp section-example-container">
  <pre>var chart = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x.EndTime),
    history.Select(x =&gt; x.Value)
);</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Open Interest");
Title title = Title.init($"{contractSymbol} Open Interest");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Line charts display the value of the property you selected in a time series.
 </p>
</ol>
<img alt="Line chart of close price of Future contracts" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/futures-line-plot.jpg"/>
<img alt="Line chart of open interest of ES18H22" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/futures-line-plot-csharp.png"/>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.8"><h3>3.8 Futures Options</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical Future Options data.
</p>

<h3>Create Subscriptions</h3>
<p>
 Follow these steps to subscribe to a Futures Option contract:
</p>
<ol>
 <li class="csharp">
  Load the required assembly files and data types.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Data.Market;
using QuantConnect.Algorithm;
using QuantConnect.Securities;
using QuantConnect.Securities.Future;
using QuantConnect.Research;
using Microsoft.Data.Analysis;</pre>
 </div>
 <li>
  Create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/futures#03-Create-Subscriptions">
   Subscribe to a Futures contract
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var future = qb.AddFuture(Futures.Indices.SP500EMini, Resolution.Minute);
var startDate = new DateTime(2021,12,20);
var futuresContractSymbols = qb.FutureChainProvider.GetFutureContractList(future.Symbol, startDate);
var futuresContractSymbol = futuresContractSymbols.OrderBy(s =&gt; s.ID.Date).FirstOrDefault();
qb.AddFutureContract(futuresContractSymbol, fillForward: false);</pre>
  <pre class="python">future = qb.AddFuture(Futures.Indices.SP500EMini, Resolution.Minute)
start_date = datetime(2021,12,20)
futures_contract_symbols = qb.FutureChainProvider.GetFutureContractList(future.Symbol, start_date)
futures_contract_symbol = sorted(futures_contract_symbols, key=lambda s: s.ID.Date)[0]
qb.AddFutureContract(futures_contract_symbol, fillForward = False)</pre>
 </div>
 <p>
  To view the available underlying Futures in the US Future Options dataset, see
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/datasets/algoseek/us-future-options#05-Supported-Assets">
   Supported Assets
  </a>
  .
 </p>
 <li>
  <span class="qualifier">
   (Optional)
  </span>
  Set a
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/universes/future-options#03-Filter-Contracts">
   contract filter
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">qb.AddFutureOption(future.Symbol, optionFilterUniverse =&gt; optionFilterUniverse.Strikes(-1, 1));</pre>
  <pre class="python">qb.AddFutureOption(future.Symbol, lambda option_filter_universe: option_filter_universe.Strikes(-1, 1))</pre>
 </div>
 <p>
  The filter determines which contracts the
  <code>
   GetOptionHistory
  </code>
  method returns. If you don't set a filter, the default filter selects the contracts that have the following characteristics:
 </p>
 <ul>
  <li>
   Standard type (exclude weeklys)
  </li>
  <li>
   Within 1 strike price of the underlying asset price
  </li>
  <li>
   Expire within 31 days
  </li>
 </ul>
</ol>
<p>
 If you want historical data on individual contracts and their
 <code>
  OpenInterest
 </code>
 , follow these steps to subscribe to the individual Futures Option contracts:
</p>
<ol>
 <li>
  Call the
  <code>
   GetOptionsContractList
  </code>
  method with the underlying Futures Contract
  <code>
   Symbol
  </code>
  and a
  <code class="python">
   datetime
  </code>
  <code class="csharp">
   DateTime
  </code>
  object.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var fopContractSymbols = qb.OptionChainProvider.GetOptionContractList(futuresContractSymbol, startDate);</pre>
  <pre class="python">fop_contract_symbols = qb.OptionChainProvider.GetOptionContractList(futures_contract_symbol, start_date)</pre>
 </div>
 <p>
  This method returns a list of
  <code>
   Symbol
  </code>
  objects that reference the Option contracts that were trading for the underlying Future contract at the given time. If you set a contract filter with
  <code>
   SetFilter
  </code>
  , it doesn't affect the results of
  <code>
   GetOptionContractList
  </code>
  .
 </p>
 <li>
  Select the Symbol of the
  <code>
   OptionContract
  </code>
  object(s) for which you want to get historical data.
 </li>
 <p>
  To filter and select contracts, you can use the following properties of each
  <code>
   Symbol
  </code>
  object:
 </p>
 <table class="qc-table table">
  <thead>
   <tr>
    <th>
     Property
    </th>
    <th>
     Description
    </th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>
     <code>
      ID.Date
     </code>
    </td>
    <td>
     The expiration date of the contract.
    </td>
   </tr>
   <tr>
    <td>
     <code>
      ID.StrikePrice
     </code>
    </td>
    <td>
     The strike price of the contract.
    </td>
   </tr>
   <tr>
    <td>
     <code>
      ID.OptionRight
     </code>
    </td>
    <td>
     The contract type. The
     <code>
      OptionRight
     </code>
     enumeration has the following members:
     <div data-tree="QuantConnect.OptionRight">
     </div>
    </td>
   </tr>
   <tr>
    <td>
     <code>
      ID.OptionStyle
     </code>
    </td>
    <td>
     The contract style. The
     <code>
      OptionStyle
     </code>
     enumeration has the following members:
     <div data-tree="QuantConnect.OptionStyle">
     </div>
    </td>
   </tr>
  </tbody>
 </table>
 <div class="section-example-container">
  <pre class="csharp">var closestExpiry = fopContractSymbols.Select(c =&gt; c.ID.Date).Min();
var fopContractSymbol = fopContractSymbols
    .Where(c =&gt; c.ID.Date == closestExpiry &amp;&amp; c.ID.OptionRight == OptionRight.Call)
    .OrderBy(c =&gt; c.ID.StrikePrice)
    .FirstOrDefault();</pre>
  <pre class="python">closest_expiry = min([c.ID.Date for c in fop_contract_symbols])
calls = [c for c in fop_contract_symbols if c.ID.Date == closest_expiry and c.ID.OptionRight == OptionRight.Call]
fop_contract_symbol = sorted(calls, key=lambda c: c.ID.StrikePrice)[0]</pre>
 </div>
 <li>
  Call the
  <code>
   AddFutureOptionContract
  </code>
  method with an
  <code>
   OptionContract
  </code>
  Symbol and disable fill-forward.
 </li>
 <div class="section-example-container">
  <pre class="csharp">qb.AddFutureOptionContract(fopContractSymbol, fillForward: false);</pre>
  <pre class="python">qb.AddFutureOptionContract(fop_contract_symbol, fillForward = False)</pre>
 </div>
 <p>
  Disable fill-forward because there are only a few
  <code>
   OpenInterest
  </code>
  data points per day.
 </p>
</ol>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/futures-options#03-Create-Subscriptions">
  subscription
 </a>
 before you can request historical data for Futures Option contracts. On the time dimension, you can request an amount of historical data based on a trailing number of bars, a trailing period of time, or a defined period of time. On the contract dimension, you can request historical data for a single contract, a subset of the contracts you created subscriptions for in your notebook, or all of the contracts in your notebook.
</p>
<p>
 Before you request historical data, call the
 <code>
  SetStartDate
 </code>
 method with a
 <code class="python">
  datetime
 </code>
 <code class="csharp">
  DateTime
 </code>
 to reduce the risk of
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/glossary#16-look-ahead-bias">
  look-ahead bias
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">qb.SetStartDate(startDate);</pre>
 <pre class="python">qb.SetStartDate(start_date)</pre>
</div>
<p>
 If you call the
 <code>
  SetStartDate
 </code>
 method, the date that you pass to the method is the latest date for which your history requests will return data.
</p>
<h4>
 Trailing Number of Bars
</h4>
<p>
 To get historical data for a number of trailing bars, call the
 <code>
  History
 </code>
 method with the contract
 <code>
  Symbol
 </code>
 object(s) and an integer.
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(fopContractSymbol, 10);
var subsetHistorySlice = qb.History(new[] {fopContractSymbol}, 10);
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(fopContractSymbol, 10);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {fopContractSymbol}, 10);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, 10);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(fopContractSymbol, 10);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {fopContractSymbol}, 10);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, 10);

// OpenInterest objects
var singleHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(fopContractSymbol, 400);
var subsetHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(new[] {fopContractSymbol}, 400);
var allHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(qb.Securities.Keys, 400);</pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History(fop_contract_symbol, 10)
subset_history_df = qb.History([fop_contract_symbol], 10)
all_history_df = qb.History(qb.Securities.Keys, 10)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, fop_contract_symbol, 10)
subset_history_trade_bar_df = qb.History(TradeBar, [fop_contract_symbol], 10)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, 10)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, fop_contract_symbol, 10)
subset_history_quote_bar_df = qb.History(QuoteBar, [fop_contract_symbol], 10)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, 10)

# DataFrame of open interest data
single_history_open_interest_df = qb.History(OpenInterest, fop_contract_symbol, 400)
subset_history_open_interest_df = qb.History(OpenInterest, [fop_contract_symbol], 400)
all_history_open_interest_df = qb.History(OpenInterest, qb.Securities.Keys, 400)

# Slice objects
all_history_slice = qb.History(10)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](fop_contract_symbol, 10)
subset_history_trade_bars = qb.History[TradeBar]([fop_contract_symbol], 10)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, 10)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](fop_contract_symbol, 10)
subset_history_quote_bars = qb.History[QuoteBar]([fop_contract_symbol], 10)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, 10)

# OpenInterest objects
single_history_open_interest = qb.History[OpenInterest](fop_contract_symbol, 400)
subset_history_open_interest = qb.History[OpenInterest]([fop_contract_symbol], 400)
all_history_open_interest = qb.History[OpenInterest](qb.Securities.Keys, 400)</pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Trailing Period of Time
</h4>
<p>
 To get historical data for a trailing period of time, call the
 <code>
  History
 </code>
 method with the contract
 <code>
  Symbol
 </code>
 object(s) and a
 <code class="csharp">
  TimeSpan
 </code>
 <code class="python">
  timedelta
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(fopContractSymbol, TimeSpan.FromDays(3));
var subsetHistorySlice = qb.History(new[] {fopContractSymbol}, TimeSpan.FromDays(3));
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(fopContractSymbol, TimeSpan.FromDays(3));
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {fopContractSymbol}, TimeSpan.FromDays(3));
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(TimeSpan.FromDays(3));

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(fopContractSymbol, TimeSpan.FromDays(3), Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {fopContractSymbol}, TimeSpan.FromDays(3), Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Minute);


// OpenInterest objects
var singleHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(fopContractSymbol, TimeSpan.FromDays(2));
var subsetHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(new[] {fopContractSymbol}, TimeSpan.FromDays(2));
var allHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(qb.Securities.Keys, TimeSpan.FromDays(2));</pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History(fop_contract_symbol, timedelta(days=3))
subset_history_df = qb.History([fop_contract_symbol], timedelta(days=3))
all_history_df = qb.History(qb.Securities.Keys, timedelta(days=3))

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, fop_contract_symbol, timedelta(days=3))
subset_history_trade_bar_df = qb.History(TradeBar, [fop_contract_symbol], timedelta(days=3))
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, fop_contract_symbol, timedelta(days=3))
subset_history_quote_bar_df = qb.History(QuoteBar, [fop_contract_symbol], timedelta(days=3))
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of open interest data
single_history_open_interest_df = qb.History(OpenInterest, fop_contract_symbol, timedelta(days=3))
subset_history_open_interest_df = qb.History(OpenInterest, [fop_contract_symbol], timedelta(days=3))
all_history_open_interest_df = qb.History(OpenInterest, qb.Securities.Keys, timedelta(days=3))

# Slice objects
all_history_slice = qb.History(timedelta(days=3))

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](fop_contract_symbol, timedelta(days=3))
subset_history_trade_bars = qb.History[TradeBar]([fop_contract_symbol], timedelta(days=3))
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, timedelta(days=3))

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](fop_contract_symbol, timedelta(days=3), Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([fop_contract_symbol], timedelta(days=3), Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, timedelta(days=3), Resolution.Minute) 


# OpenInterest objects
single_history_open_interest = qb.History[OpenInterest](fop_contract_symbol, timedelta(days=2))
subset_history_open_interest = qb.History[OpenInterest]([fop_contract_symbol], timedelta(days=2))
all_history_open_interest = qb.History[OpenInterest](qb.Securities.Keys, timedelta(days=2))</pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Defined Period of Time
</h4>
<p>
 To get historical data for individual Futures Option contracts during a specific period of time, call the
 <code>
  History
 </code>
 method with the Futures Option contract
 <code>
  Symbol
 </code>
 object(s), a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 .  The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2021, 12, 1);
var endTime = new DateTime(2021, 12, 31);

// Slice objects
var singleHistorySlice = qb.History(fopContractSymbol, startTime, endTime);
var subsetHistorySlice = qb.History(new[] {fopContractSymbol}, startTime, endTime);
var allHistorySlice = qb.History(startTime, endTime);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(fopContractSymbol, startTime, endTime);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {fopContractSymbol}, startTime, endTime);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, startTime, endTime);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(fopContractSymbol, startTime, endTime, Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {fopContractSymbol}, startTime, endTime, Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Minute);


// OpenInterest objects
var singleHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(fopContractSymbol, startTime, endTime);
var subsetHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(new[] {fopContractSymbol}, startTime, endTime);
var allHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(qb.Securities.Keys, startTime, endTime);</pre>
 <pre class="python">start_time = datetime(2021, 12, 1)
end_time = datetime(2021, 12, 31)

# DataFrame of trade and quote data
single_history_df = qb.History(fop_contract_symbol, start_time, end_time)
subset_history_df = qb.History([fop_contract_symbol], start_time, end_time)
all_history_df = qb.History(qb.Securities.Keys, start_time, end_time)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, fop_contract_symbol, start_time, end_time)
subset_history_trade_bar_df = qb.History(TradeBar, [fop_contract_symbol], start_time, end_time)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, fop_contract_symbol, start_time, end_time)
subset_history_quote_bar_df = qb.History(QuoteBar, [fop_contract_symbol], start_time, end_time)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of open interest data
single_history_open_interest_df = qb.History(OpenInterest, fop_contract_symbol, start_time, end_time)
subset_history_open_interest_df = qb.History(OpenInterest, [fop_contract_symbol], start_time, end_time)
all_history_trade_open_interest_df = qb.History(OpenInterest, qb.Securities.Keys, start_time, end_time)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](fop_contract_symbol, start_time, end_time)
subset_history_trade_bars = qb.History[TradeBar]([fop_contract_symbol], start_time, end_time)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, start_time, end_time)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](fop_contract_symbol, start_time, end_time, Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([fop_contract_symbol], start_time, end_time, Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, start_time, end_time, Resolution.Minute)


# OpenInterest objects
single_history_open_interest = qb.History[OpenInterest](fop_contract_symbol, start_time, end_time)
subset_history_open_interest = qb.History[OpenInterest]([fop_contract_symbol], start_time, end_time)
all_history_open_interest = qb.History[OpenInterest](qb.Securities.Keys, start_time, end_time)</pre>
</div>
<p>
 To get historical data for all of the Futures Option contracts that traded during a specific period of time, call the
 <code>
  GetOptionHistory
 </code>
 method with the underlying Futures contract
 <code>
  Symbol
 </code>
 object, a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">option_history = qb.GetOptionHistory(futures_contract_symbol, end_time-timedelta(days=2), end_time, Resolution.Minute, fillForward=False, extendedMarketHours=False)</pre>
 <pre class="csharp">var optionHistory = qb.GetOptionHistory(futuresContractSymbol, endTime-TimeSpan.FromDays(2), endTime, Resolution.Minute, fillForward: False, extendedMarketHours: False);</pre>
</div>
<p>
 The preceding calls return data that have a timestamp within the defined period of time.
</p>

<h3>Resolutions</h3>
<p>
 The following table shows the available resolutions and data formats for Future Option contract subscriptions:
</p>
<table class="qc-table table" id="resolution-and-data-formats">
 <thead>
  <tr>
   <th>
    Resolution
   </th>
   <th>
    TradeBar
   </th>
   <th>
    QuoteBar
   </th>
   <th>
    Trade Tick
   </th>
   <th>
    Quote Tick
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <code>
     Tick
    </code>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <br/>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Second
    </code>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <br/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Minute
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Hour
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Daily
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
 </tbody>
</table>
<style>
 #resolution-and-data-formats td:nth-child(2), 
#resolution-and-data-formats th:nth-child(2), 
#resolution-and-data-formats td:nth-child(3), 
#resolution-and-data-formats th:nth-child(3), 
#resolution-and-data-formats td:nth-child(4), 
#resolution-and-data-formats th:nth-child(4), 
#resolution-and-data-formats td:last-child, 
#resolution-and-data-formats th:last-child {
    text-align: center;
}
</style>

<h3>Markets</h3>
<p>
 The following
 <code>
  Market
 </code>
 enumeration members are available for Future Options:
</p>
<div data-fields="CBOT,COMEX,NYSELIFFE" data-tree="QuantConnect.Market">
</div>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/futures-options#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. The process to manipulate the historical data depends on its data type. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/futures-options#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data. The process to manipulate the historical data depends on its data type.
</p>
<h4>
 DataFrame Objects
</h4>
<p class="python">
 If your history request returns a
 <code>
  DataFrame
 </code>
 , the
 <code>
  DataFrame
 </code>
 has the following index levels:
</p>
<ol class="python">
 <li>
  Contract expiry
 </li>
 <li>
  Contract strike price
 </li>
 <li>
  Contract type (call or put)
 </li>
 <li>
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/security-identifiers#02-Encoding-Symbols">
   Encoded contract Symbol
  </a>
 </li>
 <li>
  The
  <code>
   EndTime
  </code>
  of the data sample
 </li>
</ol>
<p class="python">
 The columns of the
 <code>
  DataFrame
 </code>
 are the data properties. Depending on how you request data, the
 <code>
  DataFrame
 </code>
 may contain data for the underlying security, which causes some of the index levels to be an empty string for the corresponding rows.
</p>
<img alt="Historical data dataframe" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/fop-research-data-1.jpg"/>
<p class="python">
 To select the rows of the contract(s) that expire at a specific time, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the expiry time.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[datetime(2022, 3, 18)]</pre>
</div>
<img alt="Historical data dataframe of selected date" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/fop-research-data-2.jpg"/>
<p class="python">
 If you remove the first three index levels, you can index the
 <code>
  DataFrame
 </code>
 with just the contract
 <code>
  Symbol
 </code>
 , similiar to how you would with non-derivative asset classes. To remove the first three index levels, call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.droplevel.html" rel="nofollow" target="_blank">
  droplevel
 </a>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.index = all_history_df.index.droplevel([0,1,2])</pre>
</div>
<img alt="Historical data dataframe of dropped first column" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/fop-research-data-3.jpg"/>
<p class="python">
 To select the historical data of a single Futures Option contract, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the contract
 <code>
  Symbol
 </code>
 .
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[fop_contract_symbol]
</pre>
</div>
<img alt="DataFrame of one Futures Option" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/fop-research-data-4.jpg"/>
<p class="python">
 To select a column of the
 <code>
  DataFrame
 </code>
 , index it with the column name.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[fop_contract_symbol]['close']
</pre>
</div>
<img alt="Series of close values" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/fop-research-data-5.jpg"/>
<p class="python">
 If you request historical data for multiple Futures Option contracts, you can transform the
 <code>
  DataFrame
 </code>
 so that it's a time series of close values for all of the Futures Option contracts. To transform the
 <code>
  DataFrame
 </code>
 , select the column you want to display for each Futures Option contract and then call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html" rel="nofollow" target="_blank">
  unstack
 </a>
 method.
</p>
<div class="section-example-container python">
 <pre class="python">all_history_df['close'].unstack(level=0)</pre>
</div>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 is transformed so that the column indices are the
 <code>
  Symbol
 </code>
 of each security and each row contains the close  value.
</p>
<img alt="Historical data dataframe with column indexed by symbols" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/fop-research-data-6.jpg"/>
<p class="csharp">
 The historical data methods don't return DataFrame objects, but you can create one for efficient vectorized data wrangling.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">using Microsoft.Data.Analysis; 

var columns = new DataFrameColumn[] {
    new PrimitiveDataFrameColumn<datetime>("Time", history.Select(x =&gt; x[fopContractSymbol].EndTime)),
    new DecimalDataFrameColumn(" Open", history.Select(x =&gt; x[fopContractSymbol].Open)),
    new DecimalDataFrameColumn(" High", history.Select(x =&gt; x[fopContractSymbol].High)),
    new DecimalDataFrameColumn(" Low", history.Select(x =&gt; x[fopContractSymbol].Low)),
    new DecimalDataFrameColumn(" Close", history.Select(x =&gt; x[fopContractSymbol].Close))
};
var df = new DataFrame(columns);
df</datetime></pre>
</div>
<img alt="Historical C# dataframe" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/future-options-research-data-c-1.png"/>
<p class="csharp">
 To select a particular column of the DataFrame, index it with the column name.
</p>
<div class="section-example-container">
 <pre class="csharp">df[" close"]</pre>
</div>
<img alt="Historical C# dataframe column" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/future-options-research-data-c-2.png"/>
<h4>
 Slice Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Slice
 </code>
 objects, iterate through the
 <code>
  Slice
 </code>
 objects to get each one. The
 <code>
  Slice
 </code>
 objects may not have data for all of your Futures Option subscriptions. To avoid issues, check if the
 <code>
  Slice
 </code>
 contains data for your Futures Option contract before you index it with the Futures Option
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice) {
    if (slice.Bars.ContainsKey(fopContractSymbol))
    {
        var tradeBar = slice.Bars[fopContractSymbol];
    }
    if (slice.QuoteBars.ContainsKey(fopContractSymbol))
    {
        var quoteBar = slice.QuoteBars[fopContractSymbol];
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
        if slice.Bars.ContainsKey(fop_contract_symbol):
        trade_bar = slice.Bars[fop_contract_symbol]
    if slice.QuoteBars.ContainsKey(fop_contract_symbol):
        quote_bar = slice.QuoteBars[fop_contract_symbol]
</pre>
</div>
<!---- ----->
<p>
 You can also iterate through each
 <code>
  TradeBar
 </code>
 and
 <code>
  QuoteBar
 </code>
 in the
 <code>
  Slice
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice)
{
    foreach (var kvp in slice.Bars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
    foreach (var kvp in slice.QuoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
    for kvp in slice.Bars:
        symbol = kvp.Key
        trade_bar = kvp.Value
    for kvp in slice.QuoteBars:
        symbol = kvp.Key
        quote_bar = kvp.Value
</pre>
</div>
<p class="csharp">
 You can also use LINQ to select each
 <code>
  TradeBar
 </code>
 in the
 <code>
  Slice
 </code>
 for a given
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">
var tradeBars = allHistorySlice.Where(slice =&gt; slice.Bars.ContainsKey(fopContractSymbol)).Select(slice =&gt; slice.Bars[fopContractSymbol]);
</pre>
</div>
<!---- ----->
<h4>
 TradeBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBar
 </code>
 objects, iterate through the
 <code>
  TradeBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBar in singleHistoryTradeBars)
{
    Console.WriteLine(tradeBar);
}</pre>
 <pre class="python">for trade_bar in single_history_trade_bars:
    print(trade_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBars
 </code>
 , iterate through the
 <code>
  TradeBars
 </code>
 to get the
 <code>
  TradeBar
 </code>
 of each Futures Option contract. The
 <code>
  TradeBars
 </code>
 may not have data for all of your Futures Option subscriptions. To avoid issues, check if the
 <code>
  TradeBars
 </code>
 object contains data for your security before you index it with the Futures Option
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    if (tradeBars.ContainsKey(fopContractSymbol))
    {
        var tradeBar = tradeBars[fopContractSymbol];
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    if trade_bars.ContainsKey(fop_contract_symbol):
        trade_bar = trade_bars[fop_contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  TradeBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    foreach (var kvp in tradeBars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    for kvp in trade_bars:
        symbol = kvp.Key
        trade_bar = kvp.Value<br/></pre>
</div>
<!---- ----->
<h4>
 QuoteBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBar
 </code>
 objects, iterate through the
 <code>
  QuoteBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBar in singleHistoryQuoteBars)
{
    Console.WriteLine(quoteBar);
}</pre>
 <pre class="python">for quote_bar in single_history_quote_bars:
    print(quote_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBars
 </code>
 , iterate through the
 <code>
  QuoteBars
 </code>
 to get the
 <code>
  QuoteBar
 </code>
 of each Futures Option contract. The
 <code>
  QuoteBars
 </code>
 may not have data for all of your Futures Option subscriptions. To avoid issues, check if the
 <code>
  QuoteBars
 </code>
 object contains data for your security before you index it with the Futures Option
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    if (quoteBars.ContainsKey(fopContractSymbol))
    {
        var quoteBar = quoteBars[fopContractSymbol];
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    if quote_bars.ContainsKey(fop_contract_symbol):
        quote_bar = quote_bars[fop_contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  QuoteBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    foreach (var kvp in quoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    for kvp in quote_bars:
        symbol = kvp.Key
        quote_bar = kvp.Value</pre>
</div>
<!---- ----->
<!---- ----->
<h4>
 OpenInterest Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  OpenInterest
 </code>
 objects, iterate through the
 <code>
  OpenInterest
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var openInterest in singleHistoryOpenInterest)
{
    Console.WriteLine(openInterest);
}</pre>
 <pre class="python">for open_interest in single_history_open_interest:
    print(open_interest)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns a dictionary of
 <code>
  OpenInterest
 </code>
 objects, iterate through the dictionary to get the
 <code>
  OpenInterest
 </code>
 of each Futures Option contract. The dictionary of
 <code>
  OpenInterest
 </code>
 objects may not have data for all of your Futures Option contract subscriptions. To avoid issues, check if the dictionary contains data for your contract before you index it with the Futures Option contract
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var openInterestDict in allHistoryOpenInterest)
{
    if (openInterestDict.ContainsKey(fopContractSymbol))
    {
        var openInterest = openInterestDict[fopContractSymbol];
    }
}</pre>
 <pre class="python">for open_interest_dict in all_history_open_interest:
    if open_interest_dict.ContainsKey(fop_contract_symbol):
        open_interest = open_interest_dict[fop_contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  OpenInterest
 </code>
 dictionaries.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var openInterestDict in allHistoryOpenInterest)
{
    foreach (var kvp in openInterestDict)
    {
        var symbol = kvp.Key;
        var openInterest = kvp.Value;
    }
}</pre>
 <pre class="python">for open_interest_dict in all_history_open_interest:
    for kvp in open_interest_dict:
        symbol = kvp.Key
        open_interest = kvp.Value</pre>
</div>
<!---- ----->
<h4>
 OptionHistory Objects
</h4>
<p>
 The
 <code>
  GetOptionHistory
 </code>
 method returns an
 <code>
  OptionHistory
 </code>
 object. To get each
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/time-modeling/timeslices">
  slice
 </a>
 in the
 <code>
  OptionHistory
 </code>
 object, iterate through it.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in optionHistory)
{
    foreach (var kvp in slice.OptionChains)
    {
        var canonicalSymbol = kvp.Key;
        var chain = kvp.Value;
        foreach (var contract in chain)
        {
            
        }
    }
}</pre>
 <pre class="python">for slice in option_history:
    for canonical_symbol, chain in slice.OptionChains.items(): 
        for contract in chain:
            pass</pre>
</div>
<p class="python">
 To convert the
 <code>
  OptionHistory
 </code>
 object to a
 <code>
  DataFrame
 </code>
 that contains the trade and quote information of each contract and the underlying, call the
 <code>
  GetAllData
 </code>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">option_history.GetAllData()</pre>
</div>
<p class="python">
 To get the expiration dates of all the contracts in an
 <code>
  OptionHistory
 </code>
 object, call the
 <code>
  GetExpiryDates
 </code>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">option_history.GetExpiryDates()</pre>
</div>
<p class="python">
 To get the strike prices of all the contracts in an
 <code>
  OptionHistory
 </code>
 object, call the
 <code>
  GetStrikes
 </code>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">option_history.GetStrikes()</pre>
</div>
<!---- ----->

<h3>Plot Data</h3>
<p class="csharp">
 Jupyter Notebooks don't currently support libraries to plot historical data, but we are working on adding the functionality. Until we add the functionality, use Python to plot historical Future Options data.
</p>
<div class="python">
 <p>
  You need to
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/futures-options#04-Get-Historical-Data">
   get some historical Future Options data
  </a>
  to plot it. You can use many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
  to visualize data in various formats. For example, you can plot candlestick and line charts.
 </p>
 <h4>
  Candlestick Chart
 </h4>
 <p>
  Follow these steps to plot candlestick charts:
 </p>
 <ol>
  <li>
   Get some historical data.
  </li>
  <div class="section-example-container">
   <pre class="python">history = qb.History(fop_contract_symbol, datetime(2021, 12, 2), datetime(2021, 12, 3))</pre>
   <pre class="csharp">var history = qb.History&lt;QuoteBar&gt;(fopContractSymbol, new DateTime(2021, 12, 2), new DateTime(2021, 12, 3));</pre>
  </div>
  <li class="python">
   Drop the first four index levels of the
   <code>
    DataFrame
   </code>
   that returns.
  </li>
  <div class="python section-example-container">
   <pre>history.index = history.index.droplevel([0,1,2,3])</pre>
  </div>
  <li>
   Import the
   <code class="python">
    plotly
   </code>
   <code class="csharp">
    Plotly.NET
   </code>
   library.
  </li>
  <div class="section-example-container">
   <pre class="python">import plotly.graph_objects as go</pre>
   <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
  </div>
  <li>
   Create a
   <code>
    Candlestick
   </code>
   .
   <br/>
  </li>
  <div class="section-example-container">
   <pre class="python">candlestick = go.Candlestick(x=history.index,
                             open=history['open'],
                             high=history['high'],
                             low=history['low'],
                             close=history['close'])</pre>
   <pre class="csharp">var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    history.Select(x =&gt; x.Open),
    history.Select(x =&gt; x.High),
    history.Select(x =&gt; x.Low),
    history.Select(x =&gt; x.Close),
    history.Select(x =&gt; x.EndTime)
);</pre>
  </div>
  <li>
   Create a
   <code>
    Layout
   </code>
   .
   <br/>
  </li>
  <div class="section-example-container">
   <pre class="python">layout = go.Layout(title=go.layout.Title(text=f'{fop_contract_symbol.Value} OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
   <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{fopContractSymbol} OHLC");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
  </div>
  <li class="python">
   Create the
   <code>
    Figure
   </code>
   .
   <br/>
  </li>
  <div class="python section-example-container">
   <pre>fig = go.Figure(data=[candlestick], layout=layout)</pre>
  </div>
  <li class="csharp">
   Assign the
   <code>
    Layout
   </code>
   to the chart.
   <br/>
  </li>
  <div class="csharp section-example-container">
   <pre>chart.WithLayout(layout);</pre>
  </div>
  <li>
   Show the
   <code>
    Figure
   </code>
   .
   <br/>
  </li>
  <div class="section-example-container">
   <pre class="python">fig.show()</pre>
   <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
  </div>
  <p>
   Candlestick charts display the open, high, low, and close prices of the contract.
  </p>
 </ol>
 <img alt="Candlestick plot of Future Option contracts OHLC" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/fop-candlestick-plot.jpg"/>
 <img alt="Candlestick plot of Future Option contract OHLC" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/fop-candlestick-plot-csharp.png"/>
 <h4>
  Line Chart
 </h4>
 <p>
  Follow these steps to plot line charts using
  <span class="python">
   built-in methods
  </span>
  <span class="csharp">
   <code>
    Plotly.NET
   </code>
   package
  </span>
  :
 </p>
 <ol>
  <li class="python">
   Get some historical data.
  </li>
  <div class="python section-example-container">
   <pre>history = qb.History(fop_contract_symbols[:5], datetime(2021, 12, 2), datetime(2021, 12, 30), Resolution.Daily)</pre>
  </div>
  <li class="python">
   Drop the first three index levels of the returned
   <code>
    pandas.DataFrame
   </code>
   .
  </li>
  <div class="python section-example-container">
   <pre>history.index = history.index.droplevel([0,1,2])</pre>
  </div>
  <li class="python">
   Select the data to plot.
  </li>
  <div class="python section-example-container">
   <pre>closes = history['close'].unstack(level=0)</pre>
  </div>
  <li class="python">
   Call the
   <code>
    plot
   </code>
   method on the
   <code>
    pandas
   </code>
   object.
  </li>
  <div class="python section-example-container">
   <pre>closes.plot(title="Close", figsize=(15, 5))</pre>
  </div>
  <li class="csharp">
   Create
   <code>
    Line
   </code>
   charts.
  </li>
  <div class="csharp section-example-container">
   <pre>var chart = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x.EndTime),
    history.Select(x =&gt; x.Close)
);</pre>
  </div>
  <li class="csharp">
   Create a
   <code>
    Layout
   </code>
   .
   <br/>
  </li>
  <div class="csharp section-example-container">
   <pre>LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{fopContractSymbol} Close");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
  </div>
  <li class="csharp">
   Assign the
   <code>
    Layout
   </code>
   to the chart.
   <br/>
  </li>
  <div class="csharp section-example-container">
   <pre>chart.WithLayout(layout);</pre>
  </div>
  <li>
   Show the plot.
  </li>
  <div class="section-example-container">
   <pre class="python">plt.show()</pre>
   <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
  </div>
  <p>
   Line charts display the value of the property you selected in a time series.
  </p>
  <img alt="Line chart of close price of Future Option contracts" class="docs-image" src="https://cdn.quantconnect.com/i/tu/fop-line-plot.jpg"/>
  <img alt="Line chart of close price of Future Option contract" class="docs-image" src="https://cdn.quantconnect.com/i/tu/fop-line-plot-csharp-2.png"/>
 </ol>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.9"><h3>3.9 Forex</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical Forex data.
</p>

<h3>Create Subscriptions</h3>
<p>
 Follow these steps to subscribe to a Forex security:
</p>
<ol>
 <li class="csharp">
  Load the required assembly files and data types.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Algorithm;
using QuantConnect.Research;
using Microsoft.Data.Analysis;</pre>
 </div>
 <li>
  Create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Call the
  <code>
   AddForex
  </code>
  method with a ticker and then save a reference to the Forex
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var eurusd = qb.AddForex("EURUSD").Symbol;
var gbpusd = qb.AddForex("GBPUSD").Symbol;</pre>
  <pre class="python">eurusd = qb.AddForex("EURUSD").Symbol
gbpusd = qb.AddForex("GBPUSD").Symbol</pre>
 </div>
</ol>
<p>
 To view all of the available Forex pairs, see
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/datasets/oanda/forex-data#05-Supported-Assets">
  Supported Assets
 </a>
 .
</p>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/forex#03-Create-Subscriptions">
  subscription
 </a>
 before you can request historical data for a security. On the time dimension, you can request an amount of historical data based on a trailing number of bars, a trailing period of time, or a defined period of time. On the security dimension, you can request historical data for a single Forex pair, a subset of the pairs you created subscriptions for in your notebook, or all of the pairs in your notebook.
</p>
<h4>
 Trailing Number of Bars
 <br/>
</h4>
<p>
 To get historical data for a number of trailing bars, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s) and an integer.
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(eurusd, 10);
var subsetHistorySlice = qb.History(new[] {eurusd, gbpusd}, 10);
var allHistorySlice = qb.History(10);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(eurusd, 10);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {eurusd, gbpusd}, 10);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, 10);</pre>
 <pre class="python"># DataFrame
single_history_df = qb.History(eurusd, 10)
subset_history_df = qb.History([eurusd, gbpusd], 10)
all_history_df = qb.History(qb.Securities.Keys, 10)

# Slice objects
all_history_slice = qb.History(10)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](eurusd, 10)
subset_history_quote_bars = qb.History[QuoteBar]([eurusd, gbpusd], 10)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, 10)</pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Trailing Period of Time
 <br/>
</h4>
<p>
 To get historical data for a trailing period of time, call the
 <code>
  History
 </code>
 method with the
 <code style="font-size: 15px; background-color: rgb(255, 255, 255);">
  Symbol
 </code>
 object(s) and a
 <code class="csharp">
  TimeSpan
 </code>
 <code class="python">
  timedelta
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(eurusd, TimeSpan.FromDays(3));
var subsetHistorySlice = qb.History(new[] {eurusd, gbpusd}, TimeSpan.FromDays(3));
var allHistorySlice = qb.History(10);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(eurusd, TimeSpan.FromDays(3), Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {eurusd, gbpusd}, TimeSpan.FromDays(3), Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Minute);

// Tick objects
var singleHistoryTicks = qb.History&lt;Tick&gt;(eurusd, TimeSpan.FromDays(3), Resolution.Tick);
var subsetHistoryTicks = qb.History&lt;Tick&gt;(new[] {eurusd, gbpusd}, TimeSpan.FromDays(3), Resolution.Tick);<br/>var allHistoryTicks = qb.History&lt;Tick&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Tick);<br/></pre>
 <pre class="python"># DataFrame of quote data (Forex data doesn't have trade data)
single_history_df = qb.History(eurusd, timedelta(days=3))
subset_history_df = qb.History([eurusd, gbpusd], timedelta(days=3))
all_history_df = qb.History(qb.Securities.Keys, timedelta(days=3))

# DataFrame of tick data
single_history_tick_df = qb.History(eurusd, timedelta(days=3), Resolution.Tick)
subset_history_tick_df = qb.History([eurusd, gbpusd], timedelta(days=3), Resolution.Tick)
all_history_tick_df = qb.History(qb.Securities.Keys, timedelta(days=3), Resolution.Tick)

# Slice objects
all_history_slice = qb.History(timedelta(days=3))

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](eurusd, timedelta(days=3), Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([eurusd, gbpusd], timedelta(days=3), Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, timedelta(days=3), Resolution.Minute)

# Tick objects
single_history_ticks = qb.History[Tick](eurusd, timedelta(days=3), Resolution.Tick)
subset_history_ticks = qb.History[Tick]([eurusd, gbpusd], timedelta(days=3), Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, timedelta(days=3), Resolution.Tick)</pre>
</div>
<p>
 The preceding calls return the most recent bars or ticks, excluding periods of time when the exchange was closed.
</p>
<h4>
 Defined Period of Time
 <br/>
</h4>
<p>
 To get historical data for a specific period of time, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s), a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 . The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2021, 1, 1);
var endTime = new DateTime(2021, 2, 1);

// Slice objects
var singleHistorySlice = qb.History(eurusd, startTime, endTime);
var subsetHistorySlice = qb.History(new[] {eurusd, gbpusd}, startTime, endTime);
var allHistorySlice = qb.History(qb.Securities.Keys, startTime, endTime);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(eurusd, startTime, endTime, Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {eurusd, gbpusd}, startTime, endTime, Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Minute);

// Tick objects
var singleHistoryTicks = qb.History&lt;Tick&gt;(eurusd, startTime, endTime, Resolution.Tick);
var subsetHistoryTicks = qb.History&lt;Tick&gt;(new[] {eurusd, gbpusd}, startTime, endTime, Resolution.Tick);
var allHistoryTicks = qb.History&lt;Tick&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Tick);</pre>
 <pre class="python">start_time = datetime(2021, 1, 1)
end_time = datetime(2021, 2, 1)

# DataFrame of quote data (Forex data doesn't have trade data)
single_history_df = qb.History(eurusd, start_time, end_time)
subset_history_df = qb.History([eurusd, gbpusd], start_time, end_time)
all_history_df = qb.History(qb.Securities.Keys, start_time, end_time)

# DataFrame of tick data
single_history_tick_df = qb.History(eurusd, start_time, end_time, Resolution.Tick)
subset_history_tick_df = qb.History([eurusd, gbpusd], start_time, end_time, Resolution.Tick)
all_history_tick_df = qb.History(qb.Securities.Keys, start_time, end_time, Resolution.Tick)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](eurusd, start_time, end_time, Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([eurusd, gbpusd], start_time, end_time, Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, start_time, end_time, Resolution.Minute)

# Tick objects
single_history_ticks = qb.History[Tick](eurusd, start_time, end_time, Resolution.Tick)
subset_history_ticks = qb.History[Tick]([eurusd, gbpusd], start_time, end_time, Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, start_time, end_time, Resolution.Tick)</pre>
</div>
<p>
 The preceding calls return the bars or ticks that have a timestamp within the defined period of time.
</p>

<h3>Resolutions</h3>
<p>
 The following table shows the available resolutions and data formats for Forex subscriptions:
</p>
<table class="qc-table table" id="resolution-and-data-formats">
 <thead>
  <tr>
   <th>
    Resolution
   </th>
   <th>
    TradeBar
   </th>
   <th>
    QuoteBar
   </th>
   <th>
    Trade Tick
   </th>
   <th>
    Quote Tick
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <code>
     Tick
    </code>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" style="font-size: 16px;" width="15px;"/>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Second
    </code>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Minute
    </code>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Hour
    </code>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" style="font-size: 16px;" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Daily
    </code>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" style="font-size: 16px;" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
 </tbody>
</table>
<style>
 #resolution-and-data-formats td:nth-child(2), 
#resolution-and-data-formats th:nth-child(2), 
#resolution-and-data-formats td:nth-child(3), 
#resolution-and-data-formats th:nth-child(3), 
#resolution-and-data-formats td:nth-child(4), 
#resolution-and-data-formats th:nth-child(4), 
#resolution-and-data-formats td:last-child, 
#resolution-and-data-formats th:last-child {
    text-align: center;
}
</style>

<h3>Markets</h3>
<p>
 The only market available for Forex pairs is
 <code>
  Market.Oanda
 </code>
 .
</p>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/forex#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. The process to manipulate the historical data depends on its data type. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/forex#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data. The process to manipulate the historical data depends on its data type.
</p>
<h4>
 DataFrame Objects
</h4>
<p class="python">
 If the
 <code>
  History
 </code>
 method returns a
 <code>
  DataFrame
 </code>
 , the first level of the
 <code>
  DataFrame
 </code>
 index is the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/security-identifiers#02-Encoding-Symbols">
  encoded Forex Symbol
 </a>
 and the second level is the
 <code>
  EndTime
 </code>
 of the data sample. The columns of the
 <code>
  DataFrame
 </code>
 are the data properties.
</p>
<img alt="DataFrame of two Forex pairs" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/forex-research-data-1.jpg"/>
<p class="python">
 To select the historical data of a single Forex, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the Forex
 <code>
  Symbol
 </code>
 .
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[eurusd]  # or all_history_df.loc['EURUSD']
</pre>
</div>
<img alt="DataFrame of one Forex" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/forex-research-data-2.jpg"/>
<p class="python">
 To select a column of the
 <code>
  DataFrame
 </code>
 , index it with the column name.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[eurusd]['close']
</pre>
</div>
<img alt="Series of close values" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/forex-research-data-3.jpg"/>
<p class="python">
 If you request historical data for multiple Forex pairs, you can transform the
 <code>
  DataFrame
 </code>
 so that it's a time series of close values for all of the Forex pairs. To transform the
 <code>
  DataFrame
 </code>
 , select the column you want to display for each Forex pair and then call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html" rel="nofollow" target="_blank">
  unstack
 </a>
 method.
</p>
<div class="section-example-container python">
 <pre class="python">all_history_df['close'].unstack(level=0)</pre>
</div>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 is transformed so that the column indices are the
 <code>
  Symbol
 </code>
 of each Forex pair and each row contains the close value.
</p>
<img alt="DataFrame of one Forex" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/forex-research-data-4.jpg"/>
<p class="csharp">
 The historical data methods don't return DataFrame objects, but you can create one for efficient vectorized data wrangling.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">using Microsoft.Data.Analysis; 

var columns = new DataFrameColumn[] {
    new PrimitiveDataFrameColumn<datetime>("Time", history.Select(x =&gt; x[eurusd].EndTime)),
    new DecimalDataFrameColumn("EURUSD Open", history.Select(x =&gt; x[eurusd].Open)),
    new DecimalDataFrameColumn("EURUSD High", history.Select(x =&gt; x[eurusd].High)),
    new DecimalDataFrameColumn("EURUSD Low", history.Select(x =&gt; x[eurusd].Low)),
    new DecimalDataFrameColumn("EURUSD Close", history.Select(x =&gt; x[eurusd].Close))
};
var df = new DataFrame(columns);
df</datetime></pre>
</div>
<img alt="Historical C# dataframe" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/forex-research-data-c-1.png"/>
<p class="csharp">
 To select a particular column of the DataFrame, index it with the column name.
</p>
<div class="section-example-container">
 <pre class="csharp">df["EURUSD close"]</pre>
</div>
<img alt="Historical C# dataframe column" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/forex-research-data-c-2.png"/>
<h4>
 Slice Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Slice
 </code>
 objects, iterate through the
 <code>
  Slice
 </code>
 objects to get each one. The
 <code>
  Slice
 </code>
 objects may not have data for all of your Forex subscriptions. To avoid issues, check if the
 <code>
  Slice
 </code>
 contains data for your Forex pair before you index it with the Forex
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice) {
    if (slice.QuoteBars.ContainsKey(eurusd))
    {
        var quoteBar = slice.QuoteBars[eurusd];
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
        if slice.QuoteBars.ContainsKey(eurusd):
        quote_bar = slice.QuoteBars[eurusd]
</pre>
</div>
<!---- ----->
<p>
 You can also iterate through each
 <code>
  QuoteBar
 </code>
 in the
 <code>
  Slice
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice)
{
    foreach (var kvp in slice.QuoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
    for kvp in slice.QuoteBars:
        symbol = kvp.Key
        quote_bar = kvp.Value
</pre>
</div>
<p class="csharp">
 You can also use LINQ to select each
 <code>
  QuoteBar
 </code>
 in the
 <code>
  Slice
 </code>
 for a given
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">
var quoteBars = allHistorySlice.Where(slice =&gt; slice.QuoteBars.ContainsKey(eurusd)).Select(slice =&gt; slice.QuoteBars[eurusd]);
</pre>
</div>
<!---- ----->
<!---- ----->
<h4>
 QuoteBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBar
 </code>
 objects, iterate through the
 <code>
  QuoteBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBar in singleHistoryQuoteBars)
{
    Console.WriteLine(quoteBar);
}</pre>
 <pre class="python">for quote_bar in single_history_quote_bars:
    print(quote_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBars
 </code>
 , iterate through the
 <code>
  QuoteBars
 </code>
 to get the
 <code>
  QuoteBar
 </code>
 of each Forex pair. The
 <code>
  QuoteBars
 </code>
 may not have data for all of your Forex subscriptions. To avoid issues, check if the
 <code>
  QuoteBars
 </code>
 object contains data for your security before you index it with the Forex
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    if (quoteBars.ContainsKey(eurusd))
    {
        var quoteBar = quoteBars[eurusd];
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    if quote_bars.ContainsKey(eurusd):
        quote_bar = quote_bars[eurusd]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  QuoteBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    foreach (var kvp in quoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    for kvp in quote_bars:
        symbol = kvp.Key
        quote_bar = kvp.Value</pre>
</div>
<!---- ----->
<h4>
 Tick Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Tick
 </code>
 objects, iterate through the
 <code>
  Tick
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tick in singleHistoryTicks)
{
    Console.WriteLine(tick);
}</pre>
 <pre class="python">for tick in single_history_ticks:
    print(tick)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Ticks
 </code>
 , iterate through the
 <code>
  Ticks
 </code>
 to get the
 <code>
  Tick
 </code>
 of each Forex pair. The
 <code>
  Ticks
 </code>
 may not have data for all of your Forex subscriptions. To avoid issues, check if the
 <code>
  Ticks
 </code>
 object contains data for your security before you index it with the Forex
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    if (ticks.ContainsKey(eurusd))
    {
        var tick = ticks[eurusd];
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    if ticks.ContainsKey(eurusd):
        ticks = ticks[eurusd]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  Ticks
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    foreach (var kvp in ticks)
    {
        var symbol = kvp.Key;
        var tick = kvp.Value;
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    for kvp in ticks:
        symbol = kvp.Key
        tick = kvp.Value</pre>
</div>
<!---- ----->
<!---- ----->
<!---- ----->

<h3>Plot Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/forex#04-Get-Historical-Data">
  historical Forex data
 </a>
 to produce plots. You can use
 <span class="python">
  many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
 </span>
 <span class="csharp">
  <code>
   Plot.NET
  </code>
  package
 </span>
 to visualize data in various formats. For example, you can plot candlestick and line charts.
</p>
<h4>
 Candlestick Chart
 <br/>
</h4>
<p>
 Follow these steps to plot candlestick charts:
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(eurusd, datetime(2021, 11, 26), datetime(2021, 12, 8), Resolution.Daily).loc[eurusd]</pre>
  <pre class="csharp">var history = qb.History&lt;QuoteBar&gt;(eurusd, new DateTime(2021, 11, 26), new DateTime(2021, 12, 8), Resolution.Daily);</pre>
 </div>
 <li>
  Import the
  <code class="python">
   plotly
  </code>
  <code class="csharp">
   Plotly.NET
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">import plotly.graph_objects as go</pre>
  <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
 <li>
  Create a
  <code>
   Candlestick
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">candlestick = go.Candlestick(x=history.index,
                             open=history['open'],
                             high=history['high'],
                             low=history['low'],
                             close=history['close'])</pre>
  <pre class="csharp">var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    history.Select(x =&gt; x.Open),
    history.Select(x =&gt; x.High),
    history.Select(x =&gt; x.Low),
    history.Select(x =&gt; x.Close),
    history.Select(x =&gt; x.EndTime)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">layout = go.Layout(title=go.layout.Title(text='EURUSD OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{eurusd} OHLC");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="python">
  Create the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="python section-example-container">
  <pre>fig = go.Figure(data=[candlestick], layout=layout)</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Candlestick charts display the open, high, low, and close prices of the security.
 </p>
</ol>
<img alt="Candlestick plot of EURUSD OHLC" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/reserachhistoryforexonesecuritycandlestickplot.png"/>
<img alt="Candlestick plot of EURUSD OHLC" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/reserachhistoryforexonesecuritycandlestickplotcsharp.png"/>
<h4>
 Line Chart
</h4>
<p>
 Follow these steps to plot line charts using
 <span class="python">
  built-in methods
 </span>
 <span class="csharp">
  <code>
   Plotly.NET
  </code>
  package
 </span>
 :
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History([eurusd, gbpusd], datetime(2021, 11, 26), datetime(2021, 12, 8), Resolution.Daily)</pre>
  <pre class="csharp">var history = qb.History&lt;QuoteBar&gt;(new [] {eurusd, gbpusd}, new DateTime(2021, 11, 26), new DateTime(2021, 12, 8), Resolution.Daily);</pre>
 </div>
 <li class="python">
  Select the data to plot.
 </li>
 <div class="python section-example-container">
  <pre>pct_change = history['close'].unstack(0).pct_change().dropna()</pre>
 </div>
 <li class="python">
  Call the
  <code>
   plot
  </code>
  method on the
  <code>
   pandas
  </code>
  object.
 </li>
 <div class="python section-example-container">
  <pre>pct_change.plot(title="Close Price %Change", figsize=(15, 10))</pre>
 </div>
 <li class="csharp">
  Create
  <code>
   Line
  </code>
  charts.
 </li>
 <div class="csharp section-example-container">
  <pre>var chart1 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x[eurusd].EndTime),
    history.Select(x =&gt; x[eurusd].Close),
    Name: "EURUSD"
);
var chart2 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x[gbpusd].EndTime),
    history.Select(x =&gt; x[gbpusd].Close),
    Name: "GBPUSD"
);</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init("EURUSD &amp; GBPUSD Close Price");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="csharp">
  Combine the charts and assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>var chart = Plotly.NET.Chart.Combine(new []{chart1, chart2});
chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Line charts display the value of the property you selected in a time series.
 </p>
</ol>
<img alt="Line chart of Forex close price return%" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-forex-plot.jpg"/>
<img alt="Line chart of Forex close price" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-forex-line-plot-csharp.png"/>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.10"><h3>3.10 CFD</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical CFD data.
</p>

<h3>Create Subscriptions</h3>
<p>
 Follow these steps to subscribe to a CFD security:
</p>
<ol>
 <li class="csharp">
  Load the required assembly files and data types.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Algorithm;
using QuantConnect.Research;
using Microsoft.Data.Analysis;</pre>
 </div>
 <li>
  Create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Call the
  <code>
   AddCfd
  </code>
  method with a ticker and then save a reference to the CFD
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var spx = qb.AddCfd("SPX500USD").Symbol;
var usb = qb.AddCfd("USB10YUSD").Symbol;</pre>
  <pre class="python">spx = qb.AddCfd("SPX500USD").Symbol
usb = qb.AddCfd("USB10YUSD").Symbol</pre>
 </div>
</ol>
<p>
 To view all of the available contracts, see
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/datasets/oanda/cfd-data#05-Supported-Assets">
  Supported Assets
 </a>
 .
</p>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/cfd#03-Create-Subscriptions">
  subscription
 </a>
 before you can request historical data for a security. On the time dimension, you can request an amount of historical data based on a trailing number of bars, a trailing period of time, or a defined period of time. On the security dimension, you can request historical data for a single CFD contract, a subset of the contracts you created subscriptions for in your notebook, or all of the contracts in your notebook.
</p>
<h4>
 Trailing Number of Bars
 <br/>
</h4>
<p>
 To get historical data for a number of trailing bars, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s) and an integer.
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(spx, 10);
var subsetHistorySlice = qb.History(new[] {spx, usb}, 10);
var allHistorySlice = qb.History(10);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(spx, 10);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {spx, usb}, 10);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, 10);</pre>
 <pre class="python"># DataFrame
single_history_df = qb.History(spx, 10)
subset_history_df = qb.History([spx, usb], 10)
all_history_df = qb.History(qb.Securities.Keys, 10)

# Slice objects
all_history_slice = qb.History(10)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](spx, 10)
subset_history_quote_bars = qb.History[QuoteBar]([spx, usb], 10)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, 10)</pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Trailing Period of Time
 <br/>
</h4>
<p>
 To get historical data for a trailing period of time, call the
 <code>
  History
 </code>
 method with the
 <code style="font-size: 15px; background-color: rgb(255, 255, 255);">
  Symbol
 </code>
 object(s) and a
 <code class="csharp">
  TimeSpan
 </code>
 <code class="python">
  timedelta
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(spx, TimeSpan.FromDays(3));
var subsetHistorySlice = qb.History(new[] {spx, usb}, TimeSpan.FromDays(3));
var allHistorySlice = qb.History(10);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(spx, TimeSpan.FromDays(3), Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {spx, usb}, TimeSpan.FromDays(3), Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Minute);

// Tick objects
var singleHistoryTicks = qb.History&lt;Tick&gt;(spx, TimeSpan.FromDays(3), Resolution.Tick);
var subsetHistoryTicks = qb.History&lt;Tick&gt;(new[] {spx, usb}, TimeSpan.FromDays(3), Resolution.Tick);<br/>var allHistoryTicks = qb.History&lt;Tick&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Tick);<br/></pre>
 <pre class="python"># DataFrame of quote data (CFD data doesn't have trade data)
single_history_df = qb.History(spx, timedelta(days=3))
subset_history_df = qb.History([spx, usb], timedelta(days=3))
all_history_df = qb.History(qb.Securities.Keys, timedelta(days=3))

# DataFrame of tick data
single_history_tick_df = qb.History(spx, timedelta(days=3), Resolution.Tick)
subset_history_tick_df = qb.History([spx, usb], timedelta(days=3), Resolution.Tick)
all_history_tick_df = qb.History(qb.Securities.Keys, timedelta(days=3), Resolution.Tick)

# Slice objects
all_history_slice = qb.History(timedelta(days=3))

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](spx, timedelta(days=3), Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([spx, usb], timedelta(days=3), Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, timedelta(days=3), Resolution.Minute)

# Tick objects
single_history_ticks = qb.History[Tick](spx, timedelta(days=3), Resolution.Tick)
subset_history_ticks = qb.History[Tick]([spx, usb], timedelta(days=3), Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, timedelta(days=3), Resolution.Tick)</pre>
</div>
<p>
 The preceding calls return the most recent bars or ticks, excluding periods of time when the exchange was closed.
</p>
<h4>
 Defined Period of Time
 <br/>
</h4>
<p>
 To get historical data for a specific period of time, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s), a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 . The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2021, 1, 1);
var endTime = new DateTime(2021, 2, 1);

// Slice objects
var singleHistorySlice = qb.History(spx, startTime, endTime);
var subsetHistorySlice = qb.History(new[] {spx, usb}, startTime, endTime);
var allHistorySlice = qb.History(qb.Securities.Keys, startTime, endTime);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(spx, startTime, endTime, Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {spx, usb}, startTime, endTime, Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Minute);

// Tick objects
var singleHistoryTicks = qb.History&lt;Tick&gt;(spx, startTime, endTime, Resolution.Tick);
var subsetHistoryTicks = qb.History&lt;Tick&gt;(new[] {spx, usb}, startTime, endTime, Resolution.Tick);
var allHistoryTicks = qb.History&lt;Tick&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Tick);</pre>
 <pre class="python">start_time = datetime(2021, 1, 1)
end_time = datetime(2021, 2, 1)

# DataFrame of quote data (CFD data doesn't have trade data)
single_history_df = qb.History(spx, start_time, end_time)
subset_history_df = qb.History([spx, usb], start_time, end_time)
all_history_df = qb.History(qb.Securities.Keys, start_time, end_time)

# DataFrame of tick data
single_history_tick_df = qb.History(spx, start_time, end_time, Resolution.Tick)
subset_history_tick_df = qb.History([spx, usb], start_time, end_time, Resolution.Tick)
all_history_tick_df = qb.History(qb.Securities.Keys, start_time, end_time, Resolution.Tick)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar](spx, start_time, end_time, Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar]([spx, usb], start_time, end_time, Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, start_time, end_time, Resolution.Minute)

# Tick objects
single_history_ticks = qb.History[Tick](spx, start_time, end_time, Resolution.Tick)
subset_history_ticks = qb.History[Tick]([spx, usb], start_time, end_time, Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, start_time, end_time, Resolution.Tick)</pre>
</div>
<p>
 The preceding calls return the bars or ticks that have a timestamp within the defined period of time.
</p>

<h3>Resolutions</h3>
<p>
 The following table shows the available resolutions and data formats for CFD subscriptions:
</p>
<table class="qc-table table" id="resolution-and-data-formats">
 <thead>
  <tr>
   <th>
    Resolution
   </th>
   <th>
    TradeBar
   </th>
   <th>
    QuoteBar
   </th>
   <th>
    Trade Tick
   </th>
   <th>
    Quote Tick
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <code>
     Tick
    </code>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" style="font-size: 16px;" width="15px;"/>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Second
    </code>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Minute
    </code>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Hour
    </code>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" style="font-size: 16px;" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Daily
    </code>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" style="font-size: 16px;" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
 </tbody>
</table>
<style>
 #resolution-and-data-formats td:nth-child(2), 
#resolution-and-data-formats th:nth-child(2), 
#resolution-and-data-formats td:nth-child(3), 
#resolution-and-data-formats th:nth-child(3), 
#resolution-and-data-formats td:nth-child(4), 
#resolution-and-data-formats th:nth-child(4), 
#resolution-and-data-formats td:last-child, 
#resolution-and-data-formats th:last-child {
    text-align: center;
}
</style>

<h3>Markets</h3>
<p>
 The only market available for CFD contracts is
 <code>
  Market.Oanda
 </code>
 .
</p>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/cfd#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. The process to manipulate the historical data depends on its data type. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/cfd#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data. The process to manipulate the historical data depends on its data type.
</p>
<h4>
 DataFrame Objects
</h4>
<p class="python">
 If the
 <code>
  History
 </code>
 method returns a
 <code>
  DataFrame
 </code>
 , the first level of the
 <code>
  DataFrame
 </code>
 index is the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/security-identifiers#02-Encoding-Symbols">
  encoded CFD Symbol
 </a>
 and the second level is the
 <code>
  EndTime
 </code>
 of the data sample. The columns of the
 <code>
  DataFrame
 </code>
 are the data properties.
</p>
<img alt="DataFrame of two CFD contracts" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/cfd-research-data-1.jpg"/>
<p class="python">
 To select the historical data of a single CFD, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the CFD
 <code>
  Symbol
 </code>
 .
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[spx]  # or all_history_df.loc['SPX500USD']
</pre>
</div>
<img alt="DataFrame of one CFD" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/cfd-research-data-2.jpg"/>
<p class="python">
 To select a column of the
 <code>
  DataFrame
 </code>
 , index it with the column name.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[spx]['close']
</pre>
</div>
<img alt="Series of close values" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/cfd-research-data-3.jpg"/>
<p class="python">
 If you request historical data for multiple CFD contracts, you can transform the
 <code>
  DataFrame
 </code>
 so that it's a time series of close values for all of the CFD contracts. To transform the
 <code>
  DataFrame
 </code>
 , select the column you want to display for each CFD contract and then call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html" rel="nofollow" target="_blank">
  unstack
 </a>
 method.
</p>
<div class="section-example-container python">
 <pre class="python">all_history_df['close'].unstack(level=0)</pre>
</div>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 is transformed so that the column indices are the
 <code>
  Symbol
 </code>
 of each CFD contract and each row contains the close value.
</p>
<img alt="DataFrame of one CFD" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/cfd-research-data-4.jpg"/>
<p class="csharp">
 The historical data methods don't return DataFrame objects, but you can create one for efficient vectorized data wrangling.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">using Microsoft.Data.Analysis; 

var columns = new DataFrameColumn[] {
    new PrimitiveDataFrameColumn<datetime>("Time", history.Select(x =&gt; x[spx].EndTime)),
    new DecimalDataFrameColumn("SPX500USD Open", history.Select(x =&gt; x[spx].Open)),
    new DecimalDataFrameColumn("SPX500USD High", history.Select(x =&gt; x[spx].High)),
    new DecimalDataFrameColumn("SPX500USD Low", history.Select(x =&gt; x[spx].Low)),
    new DecimalDataFrameColumn("SPX500USD Close", history.Select(x =&gt; x[spx].Close))
};
var df = new DataFrame(columns);
df</datetime></pre>
</div>
<img alt="Historical C# dataframe" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/cfd-research-data-c-1.png"/>
<p class="csharp">
 To select a particular column of the DataFrame, index it with the column name.
</p>
<div class="section-example-container">
 <pre class="csharp">df["SPX500USD close"]</pre>
</div>
<img alt="Historical C# dataframe column" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/cfd-research-data-c-2.png"/>
<h4>
 Slice Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Slice
 </code>
 objects, iterate through the
 <code>
  Slice
 </code>
 objects to get each one. The
 <code>
  Slice
 </code>
 objects may not have data for all of your CFD subscriptions. To avoid issues, check if the
 <code>
  Slice
 </code>
 contains data for your CFD contract before you index it with the CFD
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice) {
    if (slice.QuoteBars.ContainsKey(spx))
    {
        var quoteBar = slice.QuoteBars[spx];
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
        if slice.QuoteBars.ContainsKey(spx):
        quote_bar = slice.QuoteBars[spx]
</pre>
</div>
<!---- ----->
<p>
 You can also iterate through each
 <code>
  QuoteBar
 </code>
 in the
 <code>
  Slice
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice)
{
    foreach (var kvp in slice.QuoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
    for kvp in slice.QuoteBars:
        symbol = kvp.Key
        quote_bar = kvp.Value
</pre>
</div>
<p class="csharp">
 You can also use LINQ to select each
 <code>
  QuoteBar
 </code>
 in the
 <code>
  Slice
 </code>
 for a given
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">
var quoteBars = allHistorySlice.Where(slice =&gt; slice.QuoteBars.ContainsKey(spx)).Select(slice =&gt; slice.QuoteBars[spx]);
</pre>
</div>
<!---- ----->
<!---- ----->
<h4>
 QuoteBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBar
 </code>
 objects, iterate through the
 <code>
  QuoteBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBar in singleHistoryQuoteBars)
{
    Console.WriteLine(quoteBar);
}</pre>
 <pre class="python">for quote_bar in single_history_quote_bars:
    print(quote_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBars
 </code>
 , iterate through the
 <code>
  QuoteBars
 </code>
 to get the
 <code>
  QuoteBar
 </code>
 of each CFD contract. The
 <code>
  QuoteBars
 </code>
 may not have data for all of your CFD subscriptions. To avoid issues, check if the
 <code>
  QuoteBars
 </code>
 object contains data for your security before you index it with the CFD
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    if (quoteBars.ContainsKey(spx))
    {
        var quoteBar = quoteBars[spx];
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    if quote_bars.ContainsKey(spx):
        quote_bar = quote_bars[spx]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  QuoteBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    foreach (var kvp in quoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    for kvp in quote_bars:
        symbol = kvp.Key
        quote_bar = kvp.Value</pre>
</div>
<!---- ----->
<h4>
 Tick Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Tick
 </code>
 objects, iterate through the
 <code>
  Tick
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tick in singleHistoryTicks)
{
    Console.WriteLine(tick);
}</pre>
 <pre class="python">for tick in single_history_ticks:
    print(tick)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Ticks
 </code>
 , iterate through the
 <code>
  Ticks
 </code>
 to get the
 <code>
  Tick
 </code>
 of each CFD contract. The
 <code>
  Ticks
 </code>
 may not have data for all of your CFD subscriptions. To avoid issues, check if the
 <code>
  Ticks
 </code>
 object contains data for your security before you index it with the CFD
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    if (ticks.ContainsKey(spx))
    {
        var tick = ticks[spx];
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    if ticks.ContainsKey(spx):
        ticks = ticks[spx]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  Ticks
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    foreach (var kvp in ticks)
    {
        var symbol = kvp.Key;
        var tick = kvp.Value;
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    for kvp in ticks:
        symbol = kvp.Key
        tick = kvp.Value</pre>
</div>
<!---- ----->
<!---- ----->
<!---- ----->

<h3>Plot Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/cfd#04-Get-Historical-Data">
  historical CFD data
 </a>
 to produce plots. You can use
 <span class="python">
  many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
 </span>
 <span class="csharp">
  <code>
   Plot.NET
  </code>
  package
 </span>
 to visualize data in various formats. For example, you can plot candlestick and line charts.
</p>
<h4>
 Candlestick Chart
 <br/>
</h4>
<p>
 Follow these steps to plot candlestick charts:
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(spx, datetime(2021, 11, 26), datetime(2021, 12, 8), Resolution.Daily).loc[spx]</pre>
  <pre class="csharp">var history = qb.History&lt;QuoteBar&gt;(spx, new DateTime(2021, 11, 26), new DateTime(2021, 12, 8), Resolution.Daily);</pre>
 </div>
 <li>
  Import the
  <code class="python">
   plotly
  </code>
  <code class="csharp">
   Plotly.NET
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">import plotly.graph_objects as go</pre>
  <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
 <li>
  Create a
  <code>
   Candlestick
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">candlestick = go.Candlestick(x=history.index,
                             open=history['open'],
                             high=history['high'],
                             low=history['low'],
                             close=history['close'])</pre>
  <pre class="csharp">var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    history.Select(x =&gt; x.Open),
    history.Select(x =&gt; x.High),
    history.Select(x =&gt; x.Low),
    history.Select(x =&gt; x.Close),
    history.Select(x =&gt; x.EndTime)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">layout = go.Layout(title=go.layout.Title(text='SPX CFD OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{spx} OHLC");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="python">
  Create the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="python section-example-container">
  <pre>fig = go.Figure(data=[candlestick], layout=layout)</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Candlestick charts display the open, high, low, and close prices of the security.
 </p>
</ol>
<img alt="Candlestick plot of SPY CFD OHLC" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/researchhistorycfdonesecuritycandlestickplot.png"/>
<img alt="Candlestick plot of SPY CFD OHLC" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/researchhistorycfdonesecuritycandlestickplotcsharp.png"/>
<h4>
 Line Chart
</h4>
<p>
 Follow these steps to plot line charts using
 <span class="python">
  built-in methods
 </span>
 <span class="csharp">
  <code>
   Plotly.NET
  </code>
  package
 </span>
 :
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History([spx, usb], datetime(2021, 11, 26), datetime(2021, 12, 8), Resolution.Daily)</pre>
  <pre class="csharp">var history = qb.History&lt;QuoteBar&gt;(new [] {spx, usb}, new DateTime(2021, 11, 26), new DateTime(2021, 12, 8), Resolution.Daily);</pre>
 </div>
 <li class="python">
  Select the data to plot.
 </li>
 <div class="python section-example-container">
  <pre>pct_change = history['close'].unstack(0).pct_change().dropna()</pre>
 </div>
 <li class="python">
  Call the
  <code>
   plot
  </code>
  method on the
  <code>
   pandas
  </code>
  object.
 </li>
 <div class="python section-example-container">
  <pre>pct_change.plot(title="Close Price %Change", figsize=(15, 10))</pre>
 </div>
 <li class="csharp">
  Create
  <code>
   Line
  </code>
  charts.
 </li>
 <div class="csharp section-example-container">
  <pre>var chart1 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x[spx].EndTime),
    history.Select(x =&gt; x[spx].Close - x[spx].Open),
    Name: $"{spx}"
);
var chart2 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x[usb].EndTime),
    history.Select(x =&gt; x[usb].Close - x[usb].Open),
    Name: $"{usb}"
);</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{spx} &amp; {usb} Daily Spread");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="csharp">
  Combine the charts and assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>var chart = Plotly.NET.Chart.Combine(new []{chart1, chart2});
chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Line charts display the value of the property you selected in a time series.
 </p>
</ol>
<img alt="Line chart of CFDs close price return%" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-cfd-plot.jpg"/>
<img alt="Line chart of CFDs daily price spread" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-cfd-plot-csharp.png"/>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.11"><h3>3.11 Indices</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical Index data.
</p>

<h3>Create Subscriptions</h3>
<p>
 Follow these steps to subscribe to an Index security:
</p>
<ol>
 <li class="csharp">
  Load the required assembly files and data types.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Algorithm;
using QuantConnect.Research;
using Microsoft.Data.Analysis;</pre>
 </div>
 <li>
  Create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Call the
  <code>
   AddIndex
  </code>
  method with a ticker and then save a reference to the Index
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var spx = qb.AddIndex("SPX").Symbol;
var vix = qb.AddIndex("VIX").Symbol;</pre>
  <pre class="python">spx = qb.AddIndex("SPX").Symbol
vix = qb.AddIndex("VIX").Symbol</pre>
 </div>
</ol>
<p>
 To view all of the available indices, see
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/datasets/tickdata/us-cash-indices#05-Supported-Indices">
  Supported Indices
 </a>
 .
</p>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/indices#03-Create-Subscriptions">
  subscription
 </a>
 before you can request historical data for a security. On the time dimension, you can request an amount of historical data based on a trailing number of bars, a trailing period of time, or a defined period of time. On the security dimension, you can request historical data for a single Index, a subset of the Indices you created subscriptions for in your notebook, or all of the Indices in your notebook.
</p>
<h4>
 Trailing Number of Bars
 <br/>
</h4>
<p>
 To get historical data for a number of trailing bars, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s) and an integer.
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(spx, 10);
var subsetHistorySlice = qb.History(new[] {spx, vix}, 10);
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(spx, 10);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {spx, vix}, 10);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, 10);</pre>
 <pre class="python"># DataFrame
single_history_df = qb.History(spx, 10)
single_history_trade_bar_df = qb.History(TradeBar, spx, 10)
subset_history_df = qb.History([spx, vix], 10)
subset_history_trade_bar_df = qb.History(TradeBar, [spx, vix], 10)
all_history_df = qb.History(qb.Securities.Keys, 10)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, 10)

# Slice objects
all_history_slice = qb.History(10)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](spx, 10)
subset_history_trade_bars = qb.History[TradeBar]([spx, vix], 10)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, 10)</pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Trailing Period of Time
 <br/>
</h4>
<p>
 To get historical data for a trailing period of time, call the
 <code>
  History
 </code>
 method with the
 <code style="font-size: 15px; background-color: rgb(255, 255, 255);">
  Symbol
 </code>
 object(s) and a
 <code class="csharp">
  TimeSpan
 </code>
 <code class="python">
  timedelta
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(spx, TimeSpan.FromDays(3));
var subsetHistorySlice = qb.History(new[] {spx, vix}, TimeSpan.FromDays(3));
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(spx, TimeSpan.FromDays(3));
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {spx, vix}, TimeSpan.FromDays(3));
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(TimeSpan.FromDays(3));

// Tick objects
var singleHistoryTicks = qb.History&lt;Tick&gt;(spx, TimeSpan.FromDays(3), Resolution.Tick);
var subsetHistoryTicks = qb.History&lt;Tick&gt;(new[] {spx, vix}, TimeSpan.FromDays(3), Resolution.Tick);<br/>var allHistoryTicks = qb.History&lt;Tick&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Tick);<br/></pre>
 <pre class="python"># DataFrame of trade data (indices don't have quote data)
single_history_df = qb.History(spx, timedelta(days=3))
subset_history_df = qb.History([spx, vix], timedelta(days=3))
all_history_df = qb.History(qb.Securities.Keys, timedelta(days=3))

# DataFrame of tick data
single_history_tick_df = qb.History(spx, timedelta(days=3), Resolution.Tick)
subset_history_tick_df = qb.History([spx, usb], timedelta(days=3), Resolution.Tick)
all_history_tick_df = qb.History(qb.Securities.Keys, timedelta(days=3), Resolution.Tick)

# Slice objects
all_history_slice = qb.History(timedelta(days=3))

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](spx, timedelta(days=3))
subset_history_trade_bars = qb.History[TradeBar]([spx, vix], timedelta(days=3))
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, timedelta(days=3))

# Tick objects
single_history_ticks = qb.History[Tick](spx, timedelta(days=3), Resolution.Tick)
subset_history_ticks = qb.History[Tick]([spx, vix], timedelta(days=3), Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, timedelta(days=3), Resolution.Tick)</pre>
</div>
<p>
 The preceding calls return the most recent bars or ticks, excluding periods of time when the exchange was closed.
</p>
<h4>
 Defined Period of Time
 <br/>
</h4>
<p>
 To get historical data for a specific period of time, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s), a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 . The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2021, 1, 1);
var endTime = new DateTime(2021, 2, 1);

// Slice objects
var singleHistorySlice = qb.History(spx, startTime, endTime);
var subsetHistorySlice = qb.History(new[] {spx, vix}, startTime, endTime);
var allHistorySlice = qb.History(qb.Securities.Keys, startTime, endTime);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;(spx, startTime, endTime);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {spx, vix}, startTime, endTime);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, startTime, endTime);

// Tick objects
var singleHistoryTicks = qb.History&lt;Tick&gt;(spx, startTime, endTime, Resolution.Tick);
var subsetHistoryTicks = qb.History&lt;Tick&gt;(new[] {spx, vix}, startTime, endTime, Resolution.Tick);
var allHistoryTicks = qb.History&lt;Tick&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Tick);</pre>
 <pre class="python">start_time = datetime(2021, 1, 1)
end_time = datetime(2021, 2, 1)

# DataFrame of trade data (indices don't have quote data)
single_history_df = qb.History(spx, start_time, end_time)
subset_history_df = qb.History([spx, vix], start_time, end_time)
all_history_df = qb.History(qb.Securities.Keys, start_time, end_time)

# DataFrame of tick data
single_history_tick_df = qb.History(spx, start_time, end_time, Resolution.Tick)
subset_history_tick_df = qb.History([spx, vix], start_time, end_time, Resolution.Tick)
all_history_tick_df = qb.History(qb.Securities.Keys, start_time, end_time, Resolution.Tick)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar](spx, start_time, end_time)
subset_history_trade_bars = qb.History[TradeBar]([spx, vix], start_time, end_time)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, start_time, end_time)

# Tick objects
single_history_ticks = qb.History[Tick](spx, start_time, end_time, Resolution.Tick)
subset_history_ticks = qb.History[Tick]([spx, vix], start_time, end_time, Resolution.Tick)
all_history_ticks = qb.History[Tick](qb.Securities.Keys, start_time, end_time, Resolution.Tick)</pre>
</div>
<p>
 The preceding calls return the bars or ticks that have a timestamp within the defined period of time.
</p>

<h3>Resolutions</h3>
<p>
 The following table shows the available resolutions and data formats for Index subscriptions:
</p>
<table class="qc-table table" id="resolution-and-data-formats">
 <thead>
  <tr>
   <th>
    Resolution
   </th>
   <th>
    TradeBar
   </th>
   <th>
    QuoteBar
   </th>
   <th>
    Trade Tick
   </th>
   <th>
    Quote Tick
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <code>
     Tick
    </code>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <br/>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Second
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <br/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Minute
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <br/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Hour
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Daily
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
 </tbody>
</table>
<style>
 #resolution-and-data-formats td:nth-child(2), 
#resolution-and-data-formats th:nth-child(2), 
#resolution-and-data-formats td:nth-child(3), 
#resolution-and-data-formats th:nth-child(3), 
#resolution-and-data-formats td:nth-child(4), 
#resolution-and-data-formats th:nth-child(4), 
#resolution-and-data-formats td:last-child, 
#resolution-and-data-formats th:last-child {
    text-align: center;
}
</style>

<h3>Markets</h3>
<p>
 The only market available for Indices is
 <code>
  Market.USA
 </code>
 .
</p>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/indices#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. The process to manipulate the historical data depends on its data type. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/indices#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data. The process to manipulate the historical data depends on its data type.
</p>
<h4>
 DataFrame Objects
</h4>
<p class="python">
 If the
 <code>
  History
 </code>
 method returns a
 <code>
  DataFrame
 </code>
 , the first level of the
 <code>
  DataFrame
 </code>
 index is the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/security-identifiers#02-Encoding-Symbols">
  encoded Index Symbol
 </a>
 and the second level is the
 <code>
  EndTime
 </code>
 of the data sample. The columns of the
 <code>
  DataFrame
 </code>
 are the data properties.
</p>
<img alt="DataFrame of two Indices" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/index-research-data-1.jpg"/>
<p class="python">
 To select the historical data of a single Index, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the Index
 <code>
  Symbol
 </code>
 .
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[spx]  # or all_history_df.loc['SPX']
</pre>
</div>
<img alt="DataFrame of one Index" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/index-research-data-2.jpg"/>
<p class="python">
 To select a column of the
 <code>
  DataFrame
 </code>
 , index it with the column name.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[spx]['close']
</pre>
</div>
<img alt="Series of close values" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/index-research-data-3.jpg"/>
<p class="python">
 If you request historical data for multiple Indices, you can transform the
 <code>
  DataFrame
 </code>
 so that it's a time series of close values for all of the Indices. To transform the
 <code>
  DataFrame
 </code>
 , select the column you want to display for each Index and then call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html" rel="nofollow" target="_blank">
  unstack
 </a>
 method.
</p>
<div class="section-example-container python">
 <pre class="python">all_history_df['close'].unstack(level=0)</pre>
</div>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 is transformed so that the column indices are the
 <code>
  Symbol
 </code>
 of each Index and each row contains the close value.
</p>
<img alt="DataFrame of one Index" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/index-research-data-4.jpg"/>
<p class="csharp">
 The historical data methods don't return DataFrame objects, but you can create one for efficient vectorized data wrangling.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">using Microsoft.Data.Analysis; 

var columns = new DataFrameColumn[] {
    new PrimitiveDataFrameColumn<datetime>("Time", history.Select(x =&gt; x[spx].EndTime)),
    new DecimalDataFrameColumn("SPX Open", history.Select(x =&gt; x[spx].Open)),
    new DecimalDataFrameColumn("SPX High", history.Select(x =&gt; x[spx].High)),
    new DecimalDataFrameColumn("SPX Low", history.Select(x =&gt; x[spx].Low)),
    new DecimalDataFrameColumn("SPX Close", history.Select(x =&gt; x[spx].Close))
};
var df = new DataFrame(columns);
df</datetime></pre>
</div>
<img alt="Historical C# dataframe" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/index-research-data-c-1.png"/>
<p class="csharp">
 To select a particular column of the DataFrame, index it with the column name.
</p>
<div class="section-example-container">
 <pre class="csharp">df["SPX close"]</pre>
</div>
<img alt="Historical C# dataframe column" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/index-research-data-c-2.png"/>
<h4>
 Slice Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Slice
 </code>
 objects, iterate through the
 <code>
  Slice
 </code>
 objects to get each one. The
 <code>
  Slice
 </code>
 objects may not have data for all of your Index subscriptions. To avoid issues, check if the
 <code>
  Slice
 </code>
 contains data for your Index before you index it with the Index
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice) {
    if (slice.Bars.ContainsKey(spx))
    {
        var tradeBar = slice.Bars[spx];
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
        if slice.Bars.ContainsKey(spx):
        trade_bar = slice.Bars[spx]
</pre>
</div>
<!---- ----->
<p>
 You can also iterate through each
 <code>
  TradeBar
 </code>
 in the
 <code>
  Slice
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice)
{
    foreach (var kvp in slice.Bars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
    for kvp in slice.Bars:
        symbol = kvp.Key
        trade_bar = kvp.Value
</pre>
</div>
<p class="csharp">
 You can also use LINQ to select each
 <code>
  TradeBar
 </code>
 in the
 <code>
  Slice
 </code>
 for a given
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">
var tradeBars = allHistorySlice.Where(slice =&gt; slice.Bars.ContainsKey(spx)).Select(slice =&gt; slice.Bars[spx]);
</pre>
</div>
<!---- ----->
<h4>
 TradeBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBar
 </code>
 objects, iterate through the
 <code>
  TradeBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBar in singleHistoryTradeBars)
{
    Console.WriteLine(tradeBar);
}</pre>
 <pre class="python">for trade_bar in single_history_trade_bars:
    print(trade_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBars
 </code>
 , iterate through the
 <code>
  TradeBars
 </code>
 to get the
 <code>
  TradeBar
 </code>
 of each Index. The
 <code>
  TradeBars
 </code>
 may not have data for all of your Index subscriptions. To avoid issues, check if the
 <code>
  TradeBars
 </code>
 object contains data for your security before you index it with the Index
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    if (tradeBars.ContainsKey(spx))
    {
        var tradeBar = tradeBars[spx];
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    if trade_bars.ContainsKey(spx):
        trade_bar = trade_bars[spx]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  TradeBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    foreach (var kvp in tradeBars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    for kvp in trade_bars:
        symbol = kvp.Key
        trade_bar = kvp.Value<br/></pre>
</div>
<!---- ----->
<!---- ----->
<h4>
 Tick Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Tick
 </code>
 objects, iterate through the
 <code>
  Tick
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tick in singleHistoryTicks)
{
    Console.WriteLine(tick);
}</pre>
 <pre class="python">for tick in single_history_ticks:
    print(tick)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Ticks
 </code>
 , iterate through the
 <code>
  Ticks
 </code>
 to get the
 <code>
  Tick
 </code>
 of each Index. The
 <code>
  Ticks
 </code>
 may not have data for all of your Index subscriptions. To avoid issues, check if the
 <code>
  Ticks
 </code>
 object contains data for your security before you index it with the Index
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    if (ticks.ContainsKey(spx))
    {
        var tick = ticks[spx];
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    if ticks.ContainsKey(spx):
        ticks = ticks[spx]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  Ticks
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var ticks in allHistoryTicks)
{
    foreach (var kvp in ticks)
    {
        var symbol = kvp.Key;
        var tick = kvp.Value;
    }
}</pre>
 <pre class="python">for ticks in all_history_ticks:
    for kvp in ticks:
        symbol = kvp.Key
        tick = kvp.Value</pre>
</div>
<!---- ----->
<!---- ----->
<!---- ----->

<h3>Plot Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/indices#04-Get-Historical-Data">
  historical Indices data
 </a>
 to produce plots. You can use
 <span class="python">
  many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
 </span>
 <span class="csharp">
  <code>
   Plot.NET
  </code>
  package
 </span>
 to visualize data in various formats. For example, you can plot candlestick and line charts.
</p>
<h4>
 Candlestick Chart
 <br/>
</h4>
<p>
 Follow these steps to plot candlestick charts:
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(spx, datetime(2021, 11, 24), datetime(2021, 12, 8), Resolution.Daily).loc[spx]</pre>
  <pre class="csharp">var history = qb.History&lt;TradeBar&gt;(spx, new DateTime(2021, 11, 24), new DateTime(2021, 12, 8), Resolution.Daily);</pre>
 </div>
 <li>
  Import the
  <code class="python">
   plotly
  </code>
  <code class="csharp">
   Plotly.NET
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">import plotly.graph_objects as go</pre>
  <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
 <li>
  Create a
  <code>
   Candlestick
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">candlestick = go.Candlestick(x=history.index,
                             open=history['open'],
                             high=history['high'],
                             low=history['low'],
                             close=history['close'])</pre>
  <pre class="csharp">var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    history.Select(x =&gt; x.Open),
    history.Select(x =&gt; x.High),
    history.Select(x =&gt; x.Low),
    history.Select(x =&gt; x.Close),
    history.Select(x =&gt; x.EndTime)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">layout = go.Layout(title=go.layout.Title(text='SPX OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{spx} OHLC");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="python">
  Create a
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="python section-example-container">
  <pre>fig = go.Figure(data=[candlestick], layout=layout)</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Candlestick charts display the open, high, low, and close prices of the security.
 </p>
</ol>
<img alt="Candlestick plot of SPX OHLC" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/researchhistoryindexonesecuritycandlestickplot.png"/>
<img alt="Candlestick plot of SPX OHLC" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/researchhistoryindexonesecuritycandlestickplotcsharp.png"/>
<h4>
 Line Chart
</h4>
<p>
 Follow these steps to plot line charts using
 <span class="python">
  built-in methods
 </span>
 <span class="csharp">
  <code>
   Plotly.NET
  </code>
  package
 </span>
 :
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History([spx, vix], datetime(2021, 11, 24), datetime(2021, 12, 8), Resolution.Daily)</pre>
  <pre class="csharp">var history = qb.History&lt;TradeBar&gt;(new [] {spx, vix}, new DateTime(2021, 11, 24), new DateTime(2021, 12, 8), Resolution.Daily);</pre>
 </div>
 <li class="python">
  Select the data to plot.
 </li>
 <div class="python section-example-container">
  <pre>pct_change = history['close'].unstack(0).pct_change().dropna()</pre>
 </div>
 <li class="python">
  Call the
  <code>
   plot
  </code>
  method on the
  <code>
   pandas
  </code>
  object.
 </li>
 <div class="python section-example-container">
  <pre>pct_change.plot(title="Close Price %Change", figsize=(15, 10))</pre>
 </div>
 <li class="csharp">
  Create
  <code>
   Line
  </code>
  charts.
 </li>
 <div class="csharp section-example-container">
  <pre>var chart1 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x[spx].EndTime),
    history.Select(x =&gt; x[spx].Close - x[spx].Open),
    Name: $"{spx}"
);
var chart2 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x[vix].EndTime),
    history.Select(x =&gt; x[vix].Close - x[vix].Open),
    Name: $"{vix}"
);</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{spx} &amp; {vix} Daily Spread");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="csharp">
  Combine the charts and assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>var chart = Plotly.NET.Chart.Combine(new []{chart1, chart2});
chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Line charts display the value of the property you selected in a time series.
 </p>
</ol>
<img alt="Line chart of indices %chg" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-index-plot.jpg"/>
<img alt="Line chart of indices daily spread" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-index-plot-csharp.png"/>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.12"><h3>3.12 Index Options</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical Index Options data.
</p>

<h3>Create Subscriptions</h3>
<p>
 Follow these steps to subscribe to an Index Option security:
</p>
<ol>
 <li class="csharp">
  Load the required assembly files and data types.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Data.Market;
using QuantConnect.Algorithm;
using QuantConnect.Securities;
using QuantConnect.Securities.Index;
using QuantConnect.Securities.Option;
using QuantConnect.Research;
using Microsoft.Data.Analysis;</pre>
 </div>
 <li>
  Instantiate a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Call the
  <code>
   AddIndex
  </code>
  method with a ticker and resolution.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var indexSymbol = qb.AddIndex("SPX", Resolution.Minute).Symbol;</pre>
  <pre class="python">index_symbol = qb.AddIndex("SPX", Resolution.Minute).Symbol</pre>
 </div>
 <p>
  To view the available indices, see
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/datasets/algoseek/us-index-options#05-Supported-Assets">
   Supported Assets
  </a>
  .
 </p>
 <p>
  If you do not pass a resolution argument,
  <code>
   Resolution.Minute
  </code>
  is used by default.
  <br/>
 </p>
 <li>
  Call the
  <code>
   AddIndexOption
  </code>
  method with the underlying
  <code>
   Index
  </code>
  <code>
   Symbol
  </code>
  and, if you want non-standard Index Options, the
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/datasets/algoseek/us-index-options#05-Supported-Assets">
   target Option ticker
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var option = qb.AddIndexOption(indexSymbol);</pre>
  <pre class="python">option = qb.AddIndexOption(index_symbol)</pre>
 </div>
 <li>
  <i>
   (Optional)
  </i>
  Set a
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/universes/index-options#03-Filter-Contracts">
   contract filter
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">option.SetFilter(-1, 1, 0, 90);</pre>
  <pre class="python">option.SetFilter(-1, 1, 0, 90)</pre>
 </div>
 <p>
  The filter determines which contracts the
  <code>
   GetOptionHistory
  </code>
  method returns. If you don't set a filter, the default filter selects the contracts that have the following characteristics:
 </p>
 <ul>
  <li>
   Standard type (exclude weeklys)
  </li>
  <li>
   Within 1 strike price of the underlying asset price
  </li>
  <li>
   Expire within 31 days
  </li>
 </ul>
</ol>
<p>
 If you want historical data on individual contracts and their
 <code>
  OpenInterest
 </code>
 , follow these steps to subscribe to individual Index Option contracts:
</p>
<ol>
 <li>
  Call the
  <code>
   GetOptionsContractList
  </code>
  method with the underlying
  <code>
   Index
  </code>
  <code>
   Symbol
  </code>
  and a
  <code class="python">
   datetime
  </code>
  <code class="csharp">
   DateTime
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var startDate = new DateTime(2021, 12, 31);

// Standard contracts
var canonicalSymbol = QuantConnect.Symbol.CreateCanonicalOption(indexSymbol, Market.USA, "?SPX");
var contractSymbols = qb.OptionChainProvider.GetOptionContractList(canonicalSymbol, startDate);
            
// Weekly contracts
var weeklyCanonicalSymbol = QuantConnect.Symbol.CreateCanonicalOption(indexSymbol, "SPXW", Market.USA, "?SPXW");
var weeklyContractSymbols = qb.OptionChainProvider.GetOptionContractList(weeklyCanonicalSymbol, startDate)
    .Where(s =&gt; OptionSymbol.IsWeekly(s));</pre>
  <pre class="python">start_date = datetime(2021, 12, 31)

# Standard contracts
canonical_symbol = Symbol.CreateCanonicalOption(index_symbol, Market.USA, "?SPX")
contract_symbols = qb.OptionChainProvider.GetOptionContractList(canonical_symbol, start_date)

# Weekly contracts
weekly_canonical_symbol = Symbol.CreateCanonicalOption(index_symbol, "SPXW", Market.USA, "?SPXW")
weekly_contract_symbols = qb.OptionChainProvider.GetOptionContractList(weekly_canonical_symbol, start_date)
weekly_contract_symbols = [s for s in weekly_contract_symbols if OptionSymbol.IsWeekly(s)]</pre>
 </div>
 <p>
  This method returns a list of
  <code>
   Symbol
  </code>
  objects that reference the Option contracts that were trading at the given time. If you set a contract filter with
  <code>
   SetFilter
  </code>
  , it doesn't affect the results of
  <code>
   GetOptionContractList
  </code>
  .
 </p>
 <li>
  Select the
  <code>
   Symbol
  </code>
  of the
  <code>
   OptionContract
  </code>
  object(s) for which you want to get historical data.
 </li>
 <p>
  To filter and select contracts, you can use the following properties of each
  <code>
   Symbol
  </code>
  object:
 </p>
 <table class="qc-table table">
  <thead>
   <tr>
    <th>
     Property
    </th>
    <th>
     Description
    </th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>
     <code>
      ID.Date
     </code>
    </td>
    <td>
     The expiration date of the contract.
    </td>
   </tr>
   <tr>
    <td>
     <code>
      ID.StrikePrice
     </code>
    </td>
    <td>
     The strike price of the contract.
    </td>
   </tr>
   <tr>
    <td>
     <code>
      ID.OptionRight
     </code>
    </td>
    <td>
     The contract type. The
     <code>
      OptionRight
     </code>
     enumeration has the following members:
     <div data-tree="QuantConnect.OptionRight">
     </div>
    </td>
   </tr>
   <tr>
    <td>
     <code>
      ID.OptionStyle
     </code>
    </td>
    <td>
     The contract style. The
     <code>
      OptionStyle
     </code>
     enumeration has the following members:
     <div data-tree="QuantConnect.OptionStyle">
     </div>
    </td>
   </tr>
  </tbody>
 </table>
 <div class="section-example-container">
  <pre class="csharp">// Standard contracts
var contractSymbol = contractSymbols.Where(s =&gt; 
    s.ID.OptionRight == OptionRight.Call &amp;&amp;
    s.ID.StrikePrice == 4460 &amp;&amp;
    s.ID.Date == new DateTime(2022, 4, 14)).First();

// Weekly contracts
var weeklyContractSymbol = weeklyContractSymbols.Where(s =&gt; 
    s.ID.OptionRight == OptionRight.Call &amp;&amp;
    s.ID.StrikePrice == 4460 &amp;&amp;
    s.ID.Date == new DateTime(2021, 12, 31)).First();</pre>
  <pre class="python"># Standard contracts
contract_symbol = [s for s in contract_symbols 
    if s.ID.OptionRight == OptionRight.Call 
        and s.ID.StrikePrice == 4460 
        and s.ID.Date == datetime(2022, 4, 14)][0]

# Weekly contracts
weekly_contract_symbol = [s for s in weekly_contract_symbols 
    if s.ID.OptionRight == OptionRight.Call 
        and s.ID.StrikePrice == 4460 
        and s.ID.Date == datetime(2021, 12, 31)][0]</pre>
 </div>
 <li>
  Call the
  <code>
   AddIndexOptionContract
  </code>
  method with an
  <code>
   OptionContract
  </code>
  <code>
   Symbol
  </code>
  and disable fill-forward.
 </li>
 <div class="section-example-container">
  <pre class="csharp">qb.AddIndexOptionContract(contractSymbol, fillForward: false);</pre>
  <pre class="python">qb.AddIndexOptionContract(contract_symbol, fillForward = False)</pre>
 </div>
 <p>
  Disable fill-forward because there are only a few
  <code>
   OpenInterest
  </code>
  data points per day.
 </p>
</ol>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/index-options#03-Create-Subscriptions">
  subscription
 </a>
 before you can request historical data for Index Option contracts. On the time dimension, you can request an amount of historical data based on a trailing number of bars, a trailing period of time, or a defined period of time. On the contract dimension, you can request historical data for a single contract, a subset of the contracts you created subscriptions for in your notebook, or all of the contracts in your notebook.
</p>
<p>
 Before you request historical data, call the
 <code>
  SetStartDate
 </code>
 method with a
 <code class="python">
  datetime
 </code>
 <code class="csharp">
  DateTime
 </code>
 to reduce the risk of
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/glossary#16-look-ahead-bias">
  look-ahead bias
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">qb.SetStartDate(startDate);</pre>
 <pre class="python">qb.SetStartDate(start_date)</pre>
</div>
<p>
 If you call the
 <code>
  SetStartDate
 </code>
 method, the date that you pass to the method is the latest date for which your history requests will return data.
</p>
<h4>
 Trailing Number of Bars
</h4>
<p>
 To get historical data for a number of trailing bars, call the
 <code>
  History
 </code>
 method with the contract
 <code>
  Symbol
 </code>
 object(s) and an integer.
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History("SPX", 10);
var subsetHistorySlice = qb.History(new[] {"SPX"}, 10);
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;("SPX", 10);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {"SPX"}, 10);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, 10);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;("SPX", 10);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {"SPX"}, 10);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, 10);

// OpenInterest objects
var singleHistoryOpenInterest = qb.History&lt;OpenInterest&gt;("SPX", 400);
var subsetHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(new[] {"SPX"}, 400);
var allHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(qb.Securities.Keys, 400);</pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History("SPX", 10)
subset_history_df = qb.History(["SPX"], 10)
all_history_df = qb.History(qb.Securities.Keys, 10)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, "SPX", 10)
subset_history_trade_bar_df = qb.History(TradeBar, ["SPX"], 10)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, 10)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, "SPX", 10)
subset_history_quote_bar_df = qb.History(QuoteBar, ["SPX"], 10)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, 10)

# DataFrame of open interest data
single_history_open_interest_df = qb.History(OpenInterest, "SPX", 400)
subset_history_open_interest_df = qb.History(OpenInterest, ["SPX"], 400)
all_history_open_interest_df = qb.History(OpenInterest, qb.Securities.Keys, 400)

# Slice objects
all_history_slice = qb.History(10)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar]("SPX", 10)
subset_history_trade_bars = qb.History[TradeBar](["SPX"], 10)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, 10)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar]("SPX", 10)
subset_history_quote_bars = qb.History[QuoteBar](["SPX"], 10)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, 10)

# OpenInterest objects
single_history_open_interest = qb.History[OpenInterest]("SPX", 400)
subset_history_open_interest = qb.History[OpenInterest](["SPX"], 400)
all_history_open_interest = qb.History[OpenInterest](qb.Securities.Keys, 400)</pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Trailing Period of Time
</h4>
<p>
 To get historical data for a trailing period of time, call the
 <code>
  History
 </code>
 method with the contract
 <code>
  Symbol
 </code>
 object(s) and a
 <code class="csharp">
  TimeSpan
 </code>
 <code class="python">
  timedelta
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History("SPX", TimeSpan.FromDays(3));
var subsetHistorySlice = qb.History(new[] {"SPX"}, TimeSpan.FromDays(3));
var allHistorySlice = qb.History(10);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;("SPX", TimeSpan.FromDays(3));
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {"SPX"}, TimeSpan.FromDays(3));
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(TimeSpan.FromDays(3));

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;("SPX", TimeSpan.FromDays(3), Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {"SPX"}, TimeSpan.FromDays(3), Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, TimeSpan.FromDays(3), Resolution.Minute);


// OpenInterest objects
var singleHistoryOpenInterest = qb.History&lt;OpenInterest&gt;("SPX", TimeSpan.FromDays(2));
var subsetHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(new[] {"SPX"}, TimeSpan.FromDays(2));
var allHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(qb.Securities.Keys, TimeSpan.FromDays(2));</pre>
 <pre class="python"># DataFrame of trade and quote data
single_history_df = qb.History("SPX", timedelta(days=3))
subset_history_df = qb.History(["SPX"], timedelta(days=3))
all_history_df = qb.History(qb.Securities.Keys, timedelta(days=3))

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, "SPX", timedelta(days=3))
subset_history_trade_bar_df = qb.History(TradeBar, ["SPX"], timedelta(days=3))
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, "SPX", timedelta(days=3))
subset_history_quote_bar_df = qb.History(QuoteBar, ["SPX"], timedelta(days=3))
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, timedelta(days=3))

# DataFrame of open interest data
single_history_open_interest_df = qb.History(OpenInterest, "SPX", timedelta(days=3))
subset_history_open_interest_df = qb.History(OpenInterest, ["SPX"], timedelta(days=3))
all_history_open_interest_df = qb.History(OpenInterest, qb.Securities.Keys, timedelta(days=3))

# Slice objects
all_history_slice = qb.History(timedelta(days=3))

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar]("SPX", timedelta(days=3))
subset_history_trade_bars = qb.History[TradeBar](["SPX"], timedelta(days=3))
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, timedelta(days=3))

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar]("SPX", timedelta(days=3), Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar](["SPX"], timedelta(days=3), Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, timedelta(days=3), Resolution.Minute) 


# OpenInterest objects
single_history_open_interest = qb.History[OpenInterest]("SPX", timedelta(days=2))
subset_history_open_interest = qb.History[OpenInterest](["SPX"], timedelta(days=2))
all_history_open_interest = qb.History[OpenInterest](qb.Securities.Keys, timedelta(days=2))</pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Defined Period of Time
</h4>
<p>
 To get historical data for individual Index Option contracts during a specific period of time, call the
 <code>
  History
 </code>
 method with the Index Option contract
 <code>
  Symbol
 </code>
 object(s), a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 .  The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2021, 12, 1);
var endTime = new DateTime(2021, 12, 31);

// Slice objects
var singleHistorySlice = qb.History("SPX", startTime, endTime);
var subsetHistorySlice = qb.History(new[] {"SPX"}, startTime, endTime);
var allHistorySlice = qb.History(startTime, endTime);

// TradeBar objects
var singleHistoryTradeBars = qb.History&lt;TradeBar&gt;("SPX", startTime, endTime);
var subsetHistoryTradeBars = qb.History&lt;TradeBar&gt;(new[] {"SPX"}, startTime, endTime);
var allHistoryTradeBars = qb.History&lt;TradeBar&gt;(qb.Securities.Keys, startTime, endTime);

// QuoteBar objects
var singleHistoryQuoteBars = qb.History&lt;QuoteBar&gt;("SPX", startTime, endTime, Resolution.Minute);
var subsetHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(new[] {"SPX"}, startTime, endTime, Resolution.Minute);
var allHistoryQuoteBars = qb.History&lt;QuoteBar&gt;(qb.Securities.Keys, startTime, endTime, Resolution.Minute);


// OpenInterest objects
var singleHistoryOpenInterest = qb.History&lt;OpenInterest&gt;("SPX", startTime, endTime);
var subsetHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(new[] {"SPX"}, startTime, endTime);
var allHistoryOpenInterest = qb.History&lt;OpenInterest&gt;(qb.Securities.Keys, startTime, endTime);</pre>
 <pre class="python">start_time = datetime(2021, 12, 1)
end_time = datetime(2021, 12, 31)

# DataFrame of trade and quote data
single_history_df = qb.History("SPX", start_time, end_time)
subset_history_df = qb.History(["SPX"], start_time, end_time)
all_history_df = qb.History(qb.Securities.Keys, start_time, end_time)

# DataFrame of trade data
single_history_trade_bar_df = qb.History(TradeBar, "SPX", start_time, end_time)
subset_history_trade_bar_df = qb.History(TradeBar, ["SPX"], start_time, end_time)
all_history_trade_bar_df = qb.History(TradeBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of quote data
single_history_quote_bar_df = qb.History(QuoteBar, "SPX", start_time, end_time)
subset_history_quote_bar_df = qb.History(QuoteBar, ["SPX"], start_time, end_time)
all_history_quote_bar_df = qb.History(QuoteBar, qb.Securities.Keys, start_time, end_time)

# DataFrame of open interest data
single_history_open_interest_df = qb.History(OpenInterest, "SPX", start_time, end_time)
subset_history_open_interest_df = qb.History(OpenInterest, ["SPX"], start_time, end_time)
all_history_trade_open_interest_df = qb.History(OpenInterest, qb.Securities.Keys, start_time, end_time)

# TradeBar objects
single_history_trade_bars = qb.History[TradeBar]("SPX", start_time, end_time)
subset_history_trade_bars = qb.History[TradeBar](["SPX"], start_time, end_time)
all_history_trade_bars = qb.History[TradeBar](qb.Securities.Keys, start_time, end_time)

# QuoteBar objects
single_history_quote_bars = qb.History[QuoteBar]("SPX", start_time, end_time, Resolution.Minute)
subset_history_quote_bars = qb.History[QuoteBar](["SPX"], start_time, end_time, Resolution.Minute)
all_history_quote_bars = qb.History[QuoteBar](qb.Securities.Keys, start_time, end_time, Resolution.Minute)


# OpenInterest objects
single_history_open_interest = qb.History[OpenInterest]("SPX", start_time, end_time)
subset_history_open_interest = qb.History[OpenInterest](["SPX"], start_time, end_time)
all_history_open_interest = qb.History[OpenInterest](qb.Securities.Keys, start_time, end_time)</pre>
</div>
<p>
 To get historical data for all of the Index Option contracts that pass your
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/index-options#03-Create-Subscriptions">
  filter
 </a>
 during a specific period of time, call the
 <code>
  GetOptionHistory
 </code>
 method with the canonical Index Option
 <code>
  Symbol
 </code>
 object, a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">option_history = qb.GetOptionHistory(option.Symbol, end_time-timedelta(days=2), end_time, Resolution.Minute, fillForward=False, extendedMarketHours=False)</pre>
 <pre class="csharp">var optionHistory = qb.GetOptionHistory(option.Symbol, endTime-TimeSpan.FromDays(2), endTime, Resolution.Minute, fillForward: False, extendedMarketHours: False);</pre>
</div>
<p>
 The preceding calls return data that have a timestamp within the defined period of time.
</p>

<h3>Resolutions</h3>
<p>
 The following table shows the available resolutions and data formats for Index Option contract subscriptions:
</p>
<table class="qc-table table" id="resolution-and-data-formats">
 <thead>
  <tr>
   <th>
    Resolution
   </th>
   <th>
    TradeBar
   </th>
   <th>
    QuoteBar
   </th>
   <th>
    Trade Tick
   </th>
   <th>
    Quote Tick
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <code>
     Tick
    </code>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <br/>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Second
    </code>
   </td>
   <td>
    <br/>
   </td>
   <td>
    <br/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Minute
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Hour
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    <code>
     Daily
    </code>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
    <img alt="green check" src="https://cdn.quantconnect.com/i/tu/check.png" width="15px;"/>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
 </tbody>
</table>
<style>
 #resolution-and-data-formats td:nth-child(2), 
#resolution-and-data-formats th:nth-child(2), 
#resolution-and-data-formats td:nth-child(3), 
#resolution-and-data-formats th:nth-child(3), 
#resolution-and-data-formats td:nth-child(4), 
#resolution-and-data-formats th:nth-child(4), 
#resolution-and-data-formats td:last-child, 
#resolution-and-data-formats th:last-child {
    text-align: center;
}
</style>

<h3>Markets</h3>
<p>
 The following
 <code>
  Market
 </code>
 enumeration members are available for Index Options:
</p>
<div data-fields="USA" data-tree="QuantConnect.Market">
</div>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/index-options#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. The process to manipulate the historical data depends on its data type. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/index-options#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data. The process to manipulate the historical data depends on its data type.
</p>
<h4>
 DataFrame Objects
</h4>
<p class="python">
 If your history request returns a
 <code>
  DataFrame
 </code>
 , the
 <code>
  DataFrame
 </code>
 has the following index levels:
</p>
<ol class="python">
 <li>
  Contract expiry
 </li>
 <li>
  Contract strike price
 </li>
 <li>
  Contract type (call or put)
 </li>
 <li>
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/security-identifiers#02-Encoding-Symbols">
   Encoded contract Symbol
  </a>
 </li>
 <li>
  The
  <code>
   EndTime
  </code>
  of the data sample
 </li>
</ol>
<p class="python">
 The columns of the
 <code>
  DataFrame
 </code>
 are the data properties. Depending on how you request data, the
 <code>
  DataFrame
 </code>
 may contain data for the underlying security, which causes some of the index levels to be an empty string for the corresponding rows.
</p>
<img alt="Historical data dataframe" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/index-option-research-data-1.jpg"/>
<p class="python">
 To select the rows of the contract(s) that expire at a specific time, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the expiry time.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[datetime(2022, 4, 14)]</pre>
</div>
<img alt="Historical data dataframe of selected date" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/index-option-research-data-2.jpg"/>
<p class="python">
 If you remove the first three index levels, you can index the
 <code>
  DataFrame
 </code>
 with just the contract
 <code>
  Symbol
 </code>
 , similiar to how you would with non-derivative asset classes. To remove the first three index levels, call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.droplevel.html" rel="nofollow" target="_blank">
  droplevel
 </a>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.index = all_history_df.index.droplevel([0,1,2])</pre>
</div>
<img alt="Historical data dataframe of dropped first column" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/index-option-research-data-3.jpg"/>
<p class="python">
 To select the historical data of a single Index Options contract, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the contract
 <code>
  Symbol
 </code>
 .
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[contract_symbol]
</pre>
</div>
<img alt="DataFrame of one Index Options" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/index-option-research-data-4.jpg"/>
<p class="python">
 To select a column of the
 <code>
  DataFrame
 </code>
 , index it with the column name.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[contract_symbol]['close']
</pre>
</div>
<img alt="Series of close values" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/index-option-research-data-5.jpg"/>
<p class="python">
 If you request historical data for multiple Index Option contracts, you can transform the
 <code>
  DataFrame
 </code>
 so that it's a time series of close values for all of the Index Option contracts. To transform the
 <code>
  DataFrame
 </code>
 , select the column you want to display for each Index Option contract and then call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html" rel="nofollow" target="_blank">
  unstack
 </a>
 method.
</p>
<div class="section-example-container python">
 <pre class="python">all_history_df['close'].unstack(level=0)</pre>
</div>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 is transformed so that the column indices are the
 <code>
  Symbol
 </code>
 of each security and each row contains the close  value.
</p>
<img alt="Historical data dataframe with column indexed by symbols" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/index-option-research-data-6.jpg"/>
<p class="csharp">
 The historical data methods don't return DataFrame objects, but you can create one for efficient vectorized data wrangling.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">using Microsoft.Data.Analysis; 

var columns = new DataFrameColumn[] {
    new PrimitiveDataFrameColumn<datetime>("Time", history.Select(x =&gt; x[contractSymbol].EndTime)),
    new DecimalDataFrameColumn(" Open", history.Select(x =&gt; x[contractSymbol].Open)),
    new DecimalDataFrameColumn(" High", history.Select(x =&gt; x[contractSymbol].High)),
    new DecimalDataFrameColumn(" Low", history.Select(x =&gt; x[contractSymbol].Low)),
    new DecimalDataFrameColumn(" Close", history.Select(x =&gt; x[contractSymbol].Close))
};
var df = new DataFrame(columns);
df</datetime></pre>
</div>
<img alt="Historical C# dataframe" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/index-option-research-data-c-1.png"/>
<p class="csharp">
 To select a particular column of the DataFrame, index it with the column name.
</p>
<div class="section-example-container">
 <pre class="csharp">df[" close"]</pre>
</div>
<img alt="Historical C# dataframe column" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/index-option-research-data-c-2.png"/>
<h4>
 Slice Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Slice
 </code>
 objects, iterate through the
 <code>
  Slice
 </code>
 objects to get each one. The
 <code>
  Slice
 </code>
 objects may not have data for all of your Index Options subscriptions. To avoid issues, check if the
 <code>
  Slice
 </code>
 contains data for your Index Option contract before you index it with the Index Options
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice) {
    if (slice.Bars.ContainsKey(contractSymbol))
    {
        var tradeBar = slice.Bars[contractSymbol];
    }
    if (slice.QuoteBars.ContainsKey(contractSymbol))
    {
        var quoteBar = slice.QuoteBars[contractSymbol];
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
        if slice.Bars.ContainsKey(contract_symbol):
        trade_bar = slice.Bars[contract_symbol]
    if slice.QuoteBars.ContainsKey(contract_symbol):
        quote_bar = slice.QuoteBars[contract_symbol]
</pre>
</div>
<!---- ----->
<p>
 You can also iterate through each
 <code>
  TradeBar
 </code>
 and
 <code>
  QuoteBar
 </code>
 in the
 <code>
  Slice
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice)
{
    foreach (var kvp in slice.Bars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
    foreach (var kvp in slice.QuoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
    for kvp in slice.Bars:
        symbol = kvp.Key
        trade_bar = kvp.Value
    for kvp in slice.QuoteBars:
        symbol = kvp.Key
        quote_bar = kvp.Value
</pre>
</div>
<p class="csharp">
 You can also use LINQ to select each
 <code>
  TradeBar
 </code>
 in the
 <code>
  Slice
 </code>
 for a given
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">
var tradeBars = allHistorySlice.Where(slice =&gt; slice.Bars.ContainsKey(contractSymbol)).Select(slice =&gt; slice.Bars[contractSymbol]);
</pre>
</div>
<!---- ----->
<h4>
 TradeBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBar
 </code>
 objects, iterate through the
 <code>
  TradeBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBar in singleHistoryTradeBars)
{
    Console.WriteLine(tradeBar);
}</pre>
 <pre class="python">for trade_bar in single_history_trade_bars:
    print(trade_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  TradeBars
 </code>
 , iterate through the
 <code>
  TradeBars
 </code>
 to get the
 <code>
  TradeBar
 </code>
 of each Index Option contract. The
 <code>
  TradeBars
 </code>
 may not have data for all of your Index Options subscriptions. To avoid issues, check if the
 <code>
  TradeBars
 </code>
 object contains data for your security before you index it with the Index Options
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    if (tradeBars.ContainsKey(contractSymbol))
    {
        var tradeBar = tradeBars[contractSymbol];
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    if trade_bars.ContainsKey(contract_symbol):
        trade_bar = trade_bars[contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  TradeBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var tradeBars in allHistoryTradeBars)
{
    foreach (var kvp in tradeBars)
    {
        var symbol = kvp.Key;
        var tradeBar = kvp.Value;
    }
}</pre>
 <pre class="python">for trade_bars in all_history_trade_bars:
    for kvp in trade_bars:
        symbol = kvp.Key
        trade_bar = kvp.Value<br/></pre>
</div>
<!---- ----->
<h4>
 QuoteBar Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBar
 </code>
 objects, iterate through the
 <code>
  QuoteBar
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBar in singleHistoryQuoteBars)
{
    Console.WriteLine(quoteBar);
}</pre>
 <pre class="python">for quote_bar in single_history_quote_bars:
    print(quote_bar)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  QuoteBars
 </code>
 , iterate through the
 <code>
  QuoteBars
 </code>
 to get the
 <code>
  QuoteBar
 </code>
 of each Index Option contract. The
 <code>
  QuoteBars
 </code>
 may not have data for all of your Index Options subscriptions. To avoid issues, check if the
 <code>
  QuoteBars
 </code>
 object contains data for your security before you index it with the Index Options
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    if (quoteBars.ContainsKey(contractSymbol))
    {
        var quoteBar = quoteBars[contractSymbol];
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    if quote_bars.ContainsKey(contract_symbol):
        quote_bar = quote_bars[contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  QuoteBars
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var quoteBars in allHistoryQuoteBars)
{
    foreach (var kvp in quoteBars)
    {
        var symbol = kvp.Key;
        var quoteBar = kvp.Value;
    }
}</pre>
 <pre class="python">for quote_bars in all_history_quote_bars:
    for kvp in quote_bars:
        symbol = kvp.Key
        quote_bar = kvp.Value</pre>
</div>
<!---- ----->
<!---- ----->
<h4>
 OpenInterest Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  OpenInterest
 </code>
 objects, iterate through the
 <code>
  OpenInterest
 </code>
 objects to get each one.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var openInterest in singleHistoryOpenInterest)
{
    Console.WriteLine(openInterest);
}</pre>
 <pre class="python">for open_interest in single_history_open_interest:
    print(open_interest)</pre>
</div>
<p>
 If the
 <code>
  History
 </code>
 method returns a dictionary of
 <code>
  OpenInterest
 </code>
 objects, iterate through the dictionary to get the
 <code>
  OpenInterest
 </code>
 of each Index Option contract. The dictionary of
 <code>
  OpenInterest
 </code>
 objects may not have data for all of your Index Options contract subscriptions. To avoid issues, check if the dictionary contains data for your contract before you index it with the Index Options contract
 <code>
  Symbol
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var openInterestDict in allHistoryOpenInterest)
{
    if (openInterestDict.ContainsKey(contractSymbol))
    {
        var openInterest = openInterestDict[contractSymbol];
    }
}</pre>
 <pre class="python">for open_interest_dict in all_history_open_interest:
    if open_interest_dict.ContainsKey(contract_symbol):
        open_interest = open_interest_dict[contract_symbol]</pre>
</div>
<p>
 You can also iterate through each of the
 <code>
  OpenInterest
 </code>
 dictionaries.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var openInterestDict in allHistoryOpenInterest)
{
    foreach (var kvp in openInterestDict)
    {
        var symbol = kvp.Key;
        var openInterest = kvp.Value;
    }
}</pre>
 <pre class="python">for open_interest_dict in all_history_open_interest:
    for kvp in open_interest_dict:
        symbol = kvp.Key
        open_interest = kvp.Value</pre>
</div>
<!---- ----->
<h4>
 OptionHistory Objects
</h4>
<p>
 The
 <code>
  GetOptionHistory
 </code>
 method returns an
 <code>
  OptionHistory
 </code>
 object. To get each
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/time-modeling/timeslices">
  slice
 </a>
 in the
 <code>
  OptionHistory
 </code>
 object, iterate through it.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var slice in optionHistory)
{
    foreach (var kvp in slice.OptionChains)
    {
        var canonicalSymbol = kvp.Key;
        var chain = kvp.Value;
        foreach (var contract in chain)
        {
            
        }
    }
}</pre>
 <pre class="python">for slice in option_history:
    for canonical_symbol, chain in slice.OptionChains.items(): 
        for contract in chain:
            pass</pre>
</div>
<p class="python">
 To convert the
 <code>
  OptionHistory
 </code>
 object to a
 <code>
  DataFrame
 </code>
 that contains the trade and quote information of each contract and the underlying, call the
 <code>
  GetAllData
 </code>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">option_history.GetAllData()</pre>
</div>
<p class="python">
 To get the expiration dates of all the contracts in an
 <code>
  OptionHistory
 </code>
 object, call the
 <code>
  GetExpiryDates
 </code>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">option_history.GetExpiryDates()</pre>
</div>
<p class="python">
 To get the strike prices of all the contracts in an
 <code>
  OptionHistory
 </code>
 object, call the
 <code>
  GetStrikes
 </code>
 method.
</p>
<div class="python section-example-container">
 <pre class="python">option_history.GetStrikes()</pre>
</div>
<!---- ----->

<h3>Plot Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/index-options#04-Get-Historical-Data">
  historical Index Options data
 </a>
 to produce plots. You can use
 <span class="python">
  many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
 </span>
 <span class="csharp">
  <code>
   Plot.NET
  </code>
  package
 </span>
 to visualize data in various formats. For example, you can plot candlestick and line charts.
</p>
<h4>
 Candlestick Chart
 <br/>
</h4>
<p>
 Follow these steps to plot candlestick charts:
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(contract_symbol, datetime(2021, 12, 30), datetime(2021, 12, 31))</pre>
  <pre class="csharp">var history = qb.History&lt;QuoteBar&gt;(contractSymbol, new DateTime(2021, 12, 30), new DateTime(2021, 12, 30));</pre>
 </div>
 <li class="python">
  Drop the first four index levels of
  <code>
   DataFrame
  </code>
  that returns.
  <br/>
 </li>
 <div class="python section-example-container">
  <pre>history.index = history.index.droplevel([0,1,2,3])</pre>
 </div>
 <li>
  Import the
  <code class="python">
   plotly
  </code>
  <code class="csharp">
   Plotly.NET
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">import plotly.graph_objects as go</pre>
  <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
 <li>
  Create a
  <code>
   Candlestick
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">candlestick = go.Candlestick(x=history.index,
                             open=history['open'],
                             high=history['high'],
                             low=history['low'],
                             close=history['close'])</pre>
  <pre class="csharp">var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    history.Select(x =&gt; x.Open),
    history.Select(x =&gt; x.High),
    history.Select(x =&gt; x.Low),
    history.Select(x =&gt; x.Close),
    history.Select(x =&gt; x.EndTime)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">layout = go.Layout(title=go.layout.Title(text=f'{symbol.Value} OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{contractSymbol} OHLC");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="python">
  Create a
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="python section-example-container">
  <pre>fig = go.Figure(data=[candlestick], layout=layout)</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  The Jupyter Notebook displays a candlestick chart of the Option contract's price.
 </p>
</ol>
<img alt="Candlestick plot of SPX option contract OHLC" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/index-option-research-candlestick-chart.jpg"/>
<img alt="Candlestick plot of SPX option contract OHLC" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/index-option-research-candlestick-chart-csharp.png"/>
<h4>
 Line Chart
</h4>
<p>
 Follow these steps to plot line charts using
 <span class="python">
  built-in methods
 </span>
 <span class="csharp">
  <code>
   Plotly.NET
  </code>
  package
 </span>
 :
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(OpenInterest, contract_symbol, datetime(2021, 12, 1), datetime(2021, 12, 31))</pre>
  <pre class="csharp">var history = qb.History&lt;OpenInterest&gt;(contractSymbol, new DateTime(2021, 12, 1), new DateTime(2021, 12, 31));</pre>
 </div>
 <li class="python">
  Drop the first three index levels of the
  <code>
   DataFrame
  </code>
  that returns.
 </li>
 <div class="python section-example-container">
  <pre>history.index = history.index.droplevel([0,1,2])</pre>
 </div>
 <li class="python">
  Select the open interest data.
 </li>
 <div class="python section-example-container">
  <pre>history = history['openinterest'].unstack(level=0).ffill()</pre>
 </div>
 <li class="python">
  Rename the column to be the
  <code>
   Symbol
  </code>
  of each contract.
 </li>
 <div class="python section-example-container">
  <pre>history.columns = [
    Symbol.GetAlias(SecurityIdentifier.Parse(x), index_symbol)
        for x in history.columns]</pre>
 </div>
 <li class="python">
  Call the
  <code>
   plot
  </code>
  method with a title and figure size.
 </li>
 <div class="python section-example-container">
  <pre>history.plot(title="Open Interest", figsize=(16, 8))</pre>
 </div>
 <li class="csharp">
  Create
  <code>
   Line
  </code>
  charts.
 </li>
 <div class="csharp section-example-container">
  <pre>var chart = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x.EndTime),
    history.Select(x =&gt; x.Value)
);</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Open Interest");
Title title = Title.init($"{contractSymbol} Open Interest");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  The Jupyter Notebook displays a line chart of open interest data.
 </p>
</ol>
<img alt="Line chart of SPX option contract open interest" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/index-option-research-line-chart.jpg"/>
<img alt="Line chart of SPX option contract open interest" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/index-option-research-line-chart-csharp.png"/>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.13"><h3>3.13 Alternative Data</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical alternative data. This tutorial uses the
 <a href="https://www.quantconnect.com/datasets/cboe-vix-daily">
  VIX Daily Price
 </a>
 dataset from the CBOE as the example dataset.
</p>

<h3>Create Subscriptions</h3>
<p>
 Follow these steps to subscribe to an alternative dataset from the
 <a href="/https://www.quantconnect.com/docs/v2/datasets/">
  Dataset Market
 </a>
 :
</p>
<ol>
 <li class="csharp">
  Load the required assembly files and data types.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Algorithm;
using QuantConnect.Research;
using QuantConnect.DataSource;
using Microsoft.Data.Analysis;</pre>
 </div>
 <li class="csharp">
  Load the dynamic link library (DLL) of the dataset.
 </li>
 <p class="csharp">
  To load the DLL of any dataset, type:
 </p>
 <div class="csharp section-example-container">
  <pre class="csharp">#r "../QuantConnect.DataSource.&lt;nameOfAlternativeDatasetClass&gt;.dll"</pre>
 </div>
 <p class="csharp">
  For example, to load the DLL of the CBOE dataset, type:
 </p>
 <div class="csharp section-example-container">
  <pre class="csharp">#r "../QuantConnect.DataSource.CBOE.dll"</pre>
 </div>
 <li>
  Create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Call the
  <code>
   AddData
  </code>
  method with the dataset class, a ticker, and a resolution and then save a reference to the alternative data
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var vix = qb.AddData&lt;CBOE&gt;("VIX", Resolution.Daily).Symbol;
var v3m = qb.AddData&lt;CBOE&gt;("VIX3M", Resolution.Daily).Symbol;</pre>
  <pre class="python">vix = qb.AddData(CBOE, "VIX", Resolution.Daily).Symbol
v3m = qb.AddData(CBOE, "VIX3M", Resolution.Daily).Symbol</pre>
 </div>
 <p>
  To view the arguments that the
  <code>
   AddData
  </code>
  method accepts for each dataset, see the
  <a href="/https://www.quantconnect.com/docs/v2/datasets">
   dataset listing
  </a>
  .
 </p>
 <p>
  If you don't pass a resolution argument, the default resolution of the dataset is used by default. To view the supported resolutions and the default resolution of each dataset, see the
  <a href="/https://www.quantconnect.com/docs/v2/datasets">
   dataset listing
  </a>
  .
 </p>
</ol>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/alternative-data#03-Create-Subscriptions">
  subscription
 </a>
 before you can request historical data for a dataset. On the time dimension, you can request an amount of historical data based on a trailing number of bars, a trailing period of time, or a defined period of time. On the dataset dimension, you can request historical data for a single dataset subscription, a subset of the dataset subscriptions you created in your notebook, or all of the dataset subscriptions in your notebook.
</p>
<h4>
 Trailing Number of Bars
 <br/>
</h4>
<p>
 To get historical data for a number of trailing bars, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s) and an integer.
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(vix, 10);
var subsetHistorySlice = qb.History(new[] {vix, v3m}, 10);
var allHistorySlice = qb.History(10);

// CBOE objects
var singleHistoryDataObjects = qb.History&lt;CBOE&gt;(vix, 10);
var subsetHistoryDataObjects = qb.History&lt;CBOE&gt;(new[] {vix, v3m}, 10);
var allHistoryDataObjects = qb.History&lt;CBOE&gt;(qb.Securities.Keys, 10);</pre>
 <pre class="python"># DataFrame
single_history_df = qb.History(vix, 10)
subset_history_df = qb.History([vix, v3m], 10)
all_history_df = qb.History(qb.Securities.Keys, 10)

# Slice objects
all_history_slice = qb.History(10)

# CBOE objects
single_history_data_objects = qb.History[CBOE](vix, 10)
subset_history_data_objects = qb.History[CBOE]([vix, v3m], 10)<br/>all_history_data_objects = qb.History[CBOE](qb.Securities.Keys, 10)<br/></pre>
</div>
<p>
 The preceding calls return the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Trailing Period of Time
 <br/>
</h4>
<p>
 To get historical data for a trailing period of time, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s) and a
 <code class="csharp">
  TimeSpan
 </code>
 <code class="python">
  timedelta
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">// Slice objects
var singleHistorySlice = qb.History(vix, TimeSpan.FromDays(3));
var subsetHistorySlice = qb.History(new[] {vix, v3m}, TimeSpan.FromDays(3));
var allHistorySlice = qb.History(10);

// CBOE objects
var singleHistoryDataObjects = qb.History&lt;CBOE&gt;(vix, TimeSpan.FromDays(3));<br/>var subsetHistoryDataObjects = qb.History&lt;CBOE&gt;(new[] {vix, v3m}, TimeSpan.FromDays(3));<br/>var allHistoryDataObjects = qb.History&lt;CBOE&gt;(TimeSpan.FromDays(3));<br/></pre>
 <pre class="python"># DataFrame
single_history_df = qb.History(vix, timedelta(days=3))
subset_history_df = qb.History([vix, v3m], timedelta(days=3))
all_history_df = qb.History(qb.Securities.Keys, timedelta(days=3))

# Slice objects
all_history_slice = qb.History(timedelta(days=3))

# CBOE objects
single_history_data_objects = qb.History[CBOE](vix, timedelta(days=3))<br/>subset_history_data_objects = qb.History[CBOE]([vix, v3m], timedelta(days=3))<br/>all_history_data_objects = qb.History[CBOE](qb.Securities.Keys, timedelta(days=3))<br/></pre>
</div>
<p>
 The preceding calls return the most recent bars or ticks, excluding periods of time when the exchange was closed.
</p>
<h4>
 Defined Period of Time
 <br/>
</h4>
<p>
 To get historical data for a specific period of time, call the
 <code>
  History
 </code>
 method with the
 <code>
  Symbol
 </code>
 object(s), a start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and an end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 . The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2021, 1, 1);
var endTime = new DateTime(2021, 3, 1);

// Slice objects
var singleHistorySlice = qb.History(vix, startTime, endTime);
var subsetHistorySlice = qb.History(new[] {vix, v3m}, startTime, endTime);
var allHistorySlice = qb.History(startTime, endTime);

// CBOE objects
var singleHistoryDataObjects = qb.History&lt;CBOE&gt;(vix, startTime, endTime);<br/>var subsetHistoryDataObjects = qb.History&lt;CBOE&gt;(new[] {vix, v3m}, startTime, endTime);<br/>var allHistoryDataObjects = qb.History&lt;CBOE&gt;(qb.Securities.Keys, startTime, endTime);<br/></pre>
 <pre class="python">start_time = datetime(2021, 1, 1)
end_time = datetime(2021, 3, 1)

# DataFrame
single_history_df = qb.History(vix, start_time, end_time)
subset_history_df = qb.History([vix, v3m], start_time, end_time)
all_history_df = qb.History(qb.Securities.Keys, start_time, end_time)

# Slice objects
all_history_slice = qb.History(start_time, end_time)

# CBOE objects
single_history_data_objects = qb.History[CBOE](vix, start_time, end_time)<br/>subset_history_data_objects = qb.History[CBOE]([vix, v3m], start_time, end_time)<br/>all_history_data_objects = qb.History[CBOE](qb.Securities.Keys, start_time, end_time)<br/></pre>
</div>
<p>
 The preceding calls return the bars or ticks that have a timestamp within the defined period of time.
</p>
<p>
 If you do not pass a resolution to the
 <code>
  History
 </code>
 method, the
 <code>
  History
 </code>
 method uses the resolution that the
 <code>
  AddData
 </code>
 method used when you created the
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/alternative-data#03-Create-Subscriptions">
  subscription
 </a>
 .
</p>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/alternative-data#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. The process to manipulate the historical data depends on its data type. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/alternative-data#04-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data. The process to manipulate the historical data depends on its data type.
</p>
<h4>
 DataFrame Objects
</h4>
<p class="python">
 If the
 <code>
  History
 </code>
 method returns a
 <code>
  DataFrame
 </code>
 , the first level of the
 <code>
  DataFrame
 </code>
 index is the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/security-identifiers#02-Encoding-Symbols">
  encoded dataset Symbol
 </a>
 and the second level is the
 <code>
  EndTime
 </code>
 of the data sample. The columns of the
 <code>
  DataFrame
 </code>
 are the data properties.
</p>
<img alt="DataFrame of two tickers" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/alt-data-research-data-1.jpg"/>
<p class="python">
 To select the historical data of a single dataset, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the dataset
 <code>
  Symbol
 </code>
 .
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[vix]  # or all_history_df.loc['VIX']
</pre>
</div>
<img alt="DataFrame of one dataset" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/alt-data-research-data-2.jpg"/>
<p class="python">
 To select a column of the
 <code>
  DataFrame
 </code>
 , index it with the column name.
</p>
<div class="python section-example-container">
 <pre class="python">all_history_df.loc[vix]['close']
</pre>
</div>
<img alt="Series of close values" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/alt-data-research-data-3.jpg"/>
<p class="python">
 If you request historical data for multiple tickers, you can transform the
 <code>
  DataFrame
 </code>
 so that it's a time series of close values for all of the tickers. To transform the
 <code>
  DataFrame
 </code>
 , select the column you want to display for each ticker and then call the
 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.unstack.html" rel="nofollow" target="_blank">
  unstack
 </a>
 method.
</p>
<div class="section-example-container python">
 <pre class="python">all_history_df['close'].unstack(level=0)</pre>
</div>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 is transformed so that the column indices are the
 <code>
  Symbol
 </code>
 of each ticker and each row contains the close value.
</p>
<img alt="DataFrame of one dataset" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/alt-data-research-data-4.jpg"/>
<p class="csharp">
 The historical data methods don't return DataFrame objects, but you can create one for efficient vectorized data wrangling.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">using Microsoft.Data.Analysis; 

var columns = new DataFrameColumn[] {
    new PrimitiveDataFrameColumn<datetime>("Time", history.Select(x =&gt; x[vix].EndTime)),
    new DecimalDataFrameColumn("VIX Open", history.Select(x =&gt; x[vix].Open)),
    new DecimalDataFrameColumn("VIX High", history.Select(x =&gt; x[vix].High)),
    new DecimalDataFrameColumn("VIX Low", history.Select(x =&gt; x[vix].Low)),
    new DecimalDataFrameColumn("VIX Close", history.Select(x =&gt; x[vix].Close))
};
var df = new DataFrame(columns);
df</datetime></pre>
</div>
<img alt="Historical C# dataframe" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/alt-data-research-data-c-1.png"/>
<p class="csharp">
 To select a particular column of the DataFrame, index it with the column name.
</p>
<div class="section-example-container">
 <pre class="csharp">df["VIX close"]</pre>
</div>
<img alt="Historical C# dataframe column" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/alt-data-research-data-c-2.png"/>
<h4>
 Slice Objects
</h4>
<p>
 If the
 <code>
  History
 </code>
 method returns
 <code>
  Slice
 </code>
 objects, iterate through the
 <code>
  Slice
 </code>
 objects to get each one. The
 <code>
  Slice
 </code>
 objects may not have data for all of your dataset subscriptions. To avoid issues, check if the
 <code>
  Slice
 </code>
 contains data for your ticker before you index it with the dataset
 <code>
  Symbol
 </code>
 .
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach (var slice in allHistorySlice) {
    if (slice.ContainsKey(vix))
    {
        var data = slice[vix];
    }
}</pre>
 <pre class="python">for slice in all_history_slice:
        if slice.ContainsKey(vix):
        data = slice[vix]
</pre>
</div>
<!---- ----->
<!---- ----->
<!---- ----->
<!---- ----->
<!---- ----->
<!---- ----->
<!---- ----->

<h3>Plot Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/alternative-data#04-Get-Historical-Data">
  historical alternative data
 </a>
 to produce plots. You can use
 <span class="python">
  many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
 </span>
 <span class="csharp">
  <code>
   Plot.NET
  </code>
  package
 </span>
 to visualize data in various formats. For example, you can plot candlestick and line charts.
</p>
<h4>
 Candlestick Chart
 <br/>
</h4>
<p>
 You can only create candlestick charts for alternative datasets that have open, high, low, and close properties.
</p>
<p>
 Follow these steps to plot candlestick charts:
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(vix, datetime(2021, 1, 1), datetime(2021, 2, 1)).loc[vix]</pre>
  <pre class="csharp">var history = qb.History&lt;CBOE&gt;(vix, new DateTime(2021, 12, 1), new DateTime(2021, 12, 31));</pre>
 </div>
 <li>
  Import the
  <code class="python">
   plotly
  </code>
  <code class="csharp">
   Plotly.NET
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">import plotly.graph_objects as go</pre>
  <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
 <li>
  Create a
  <code>
   Candlestick
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">candlestick = go.Candlestick(x=history.index,
                             open=history['open'],
                             high=history['high'],
                             low=history['low'],
                             close=history['close'])</pre>
  <pre class="csharp">var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    history.Select(x =&gt; x.Open),
    history.Select(x =&gt; x.High),
    history.Select(x =&gt; x.Low),
    history.Select(x =&gt; x.Close),
    history.Select(x =&gt; x.EndTime)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">layout = go.Layout(title=go.layout.Title(text='VIX from CBOE OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{vix} OHLC");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="python">
  Create a
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="python section-example-container">
  <pre>fig = go.Figure(data=[candlestick], layout=layout)</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Candlestick charts display the open, high, low, and close prices of the alternative data.
 </p>
</ol>
<img alt="Candlestick plot of VIX from CBOE dataset OHLC" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-alternative-onesecurity-candlestickplot.png"/>
<img alt="Candlestick plot of VIX from CBOE dataset OHLC" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-alternative-onesecurity-candlestickplot-csharp.png"/>
<h4>
 Line Chart
</h4>
<p>
 Follow these steps to plot line charts using
 <span class="python">
  built-in methods
 </span>
 <span class="csharp">
  <code>
   Plotly.NET
  </code>
  package
 </span>
 :
</p>
<ol>
 <li>
  Get some historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History([vix, v3m], datetime(2021, 1, 1), datetime(2021, 2, 1))</pre>
  <pre class="csharp">var history = qb.History&lt;CBOE&gt;(new [] {vix, v3x}, new DateTime(2021, 1, 1), new DateTime(2021, 2, 1));</pre>
 </div>
 <li class="python">
  Select the data to plot.
 </li>
 <div class="python section-example-container">
  <pre>values = history['close'].unstack(0)</pre>
 </div>
 <li class="python">
  Call the
  <code>
   plot
  </code>
  method on the
  <code>
   pandas
  </code>
  object.
 </li>
 <div class="python section-example-container">
  <pre>values.plot(title = 'Close', figsize=(15, 10))</pre>
 </div>
 <li class="csharp">
  Create
  <code>
   Line
  </code>
  charts.
 </li>
 <div class="csharp section-example-container">
  <pre>var chart1 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x[vix].EndTime),
    history.Select(x =&gt; x[vix].Close),
    Name: $"{vix}"
);
var chart2 = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x[v3m].EndTime),
    history.Select(x =&gt; x[v3m].Close),
    Name: $"{v3m}"
);</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{vix} &amp; {v3m} Close Price");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="csharp">
  Combine the charts and assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>var chart = Plotly.NET.Chart.Combine(new []{chart1, chart2});
chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Line charts display the value of the property you selected in a time series.
 </p>
</ol>
<img alt="Line chart of VIX closes from CBOE dataset" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-alt-data-vix-plot.jpg"/>
<img alt="Line chart of VIX closes from CBOE dataset" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-alt-data-vix-plot-csharp.png"/>

<p style="page-break-after: always;">&nbsp;</p>
<section id="3.14"><h3>3.14 Custom Data</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to request, manipulate, and visualize historical user-defined custom data.
</p>

<h3>Define Custom Data</h3>
<p>
 You must format the data file into chronological order before you define the custom data class.
</p>
<p>
 To define a custom data class, extend the
 <code class="csharp">
  BaseData
 </code>
 <code class="python">
  PythonData
 </code>
 class and override the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/importing-data/streaming-data/key-concepts#04-Set-Data-Sources">
  GetSource
 </a>
 and
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/importing-data/streaming-data/key-concepts#05-Parse-Custom-Data">
  Reader
 </a>
 methods.
</p>
<div class="section-example-container">
 <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"
#r "../Microsoft.Data.Analysis.dll"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Algorithm;
using QuantConnect.Research;
using Microsoft.Data.Analysis;

public class Nifty : BaseData
{
    public decimal Open;
    public decimal High;
    public decimal Low;
    public decimal Close;

    public Nifty()
    {
    }

    public override SubscriptionDataSource GetSource(SubscriptionDataConfig config, DateTime date, bool isLiveMode)
    {
        var url = "http://cdn.quantconnect.com.s3.us-east-1.amazonaws.com/uploads/CNXNIFTY.csv";
        return new SubscriptionDataSource(url, SubscriptionTransportMedium.RemoteFile);
    }

    public override BaseData Reader(SubscriptionDataConfig config, string line, DateTime date, bool isLiveMode)
    {
        var index = new Nifty();
        index.Symbol = config.Symbol;

        try
        {
            //Example File Format:
            //Date,       Open       High        Low       Close     Volume      Turnover
            //2011-09-13  7792.9    7799.9     7722.65    7748.7    116534670    6107.78
            var data = line.Split(',');
            index.Time = DateTime.Parse(data[0], CultureInfo.InvariantCulture);
            index.EndTime = index.Time.AddDays(1);
            index.Open = Convert.ToDecimal(data[1], CultureInfo.InvariantCulture);
            index.High = Convert.ToDecimal(data[2], CultureInfo.InvariantCulture);
            index.Low = Convert.ToDecimal(data[3], CultureInfo.InvariantCulture);
            index.Close = Convert.ToDecimal(data[4], CultureInfo.InvariantCulture);
            index.Value = index.Close;
        }
        catch
        {
             // Do nothing
        }
        return index;
    }
}</pre>
 <pre class="python">
class Nifty(PythonData):
    '''NIFTY Custom Data Class'''
    def GetSource(self, config: SubscriptionDataConfig, date: datetime, isLiveMode: bool) -&gt; SubscriptionDataSource:
        url = "http://cdn.quantconnect.com.s3.us-east-1.amazonaws.com/uploads/CNXNIFTY.csv"
        return SubscriptionDataSource(url, SubscriptionTransportMedium.RemoteFile)

    def Reader(self, config: SubscriptionDataConfig, line: str, date: datetime, isLiveMode: bool) -&gt; BaseData:
        if not (line.strip() and line[0].isdigit()): return None

        # New Nifty object
        index = Nifty()
        index.Symbol = config.Symbol

        try:
            # Example File Format:
            # Date,       Open       High        Low       Close     Volume      Turnover
            # 2011-09-13  7792.9    7799.9     7722.65    7748.7    116534670    6107.78
            data = line.split(',')
            index.Time = datetime.strptime(data[0], "%Y-%m-%d")
            index.EndTime = index.Time + timedelta(days=1)
            index.Value = data[4]
            index["Open"] = float(data[1])
            index["High"] = float(data[2])
            index["Low"] = float(data[3])
            index["Close"] = float(data[4])

        except:
            pass

        return index</pre>
</div>

<h3>Create Subscriptions</h3>
<p>
 You need to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/custom-data#03-Define-Custom-Data">
  define a custom data class
 </a>
 before you can subscribe to it.
</p>
<p>
 Follow these steps to subscribe to custom dataset:
</p>
<ol>
 <li>
  Create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Call the
  <code>
   AddData
  </code>
  method with a ticker and then save a reference to the data
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var symbol = qb.AddData&lt;Nifty&gt;("NIFTY").Symbol;</pre>
  <pre class="python">symbol = qb.AddData(Nifty, "NIFTY").Symbol</pre>
 </div>
 <p>
  Custom data has its own resolution, so you don't need to specify it.
 </p>
</ol>

<h3>Get Historical Data</h3>
<p>
 You need a
 <a href="#04-Create-Subscriptions">
  subscription
 </a>
 before you can request historical data for a security. You can request an amount of historical data based on a trailing number of bars, a trailing period of time, or a defined period of time.
</p>
<p>
 Before you request data, call
 <code>
  SetStartDate
 </code>
 method with a
 <code class="python">
  datetime
 </code>
 <code class="csharp">
  DateTime
 </code>
 to reduce the risk of
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/glossary#16-look-ahead-bias">
  look-ahead bias
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">qb.SetStartDate(2014, 7, 29);</pre>
 <pre class="python">qb.SetStartDate(2014, 7, 29)</pre>
</div>
<p>
 If you call the
 <code>
  SetStartDate
 </code>
 method, the date that you pass to the method is the latest date for which your history requests will return data.
</p>
<h4>
 Trailing Number of Bars
 <br/>
</h4>
<p>
 Call the
 <code>
  History
 </code>
 method with a symbol, integer, and resolution to request historical data based on the given number of trailing bars and resolution.
</p>
<div class="section-example-container">
 <pre class="csharp">var history = qb.History(symbol, 10);</pre>
 <pre class="python">history = qb.History(symbol, 10)</pre>
</div>
<p>
 This method returns the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Trailing Period of Time
 <br/>
</h4>
<p>
 Call the
 <code>
  History
 </code>
 method with a symbol,
 <code class="csharp">
  TimeSpan
 </code>
 <code class="python">
  timedelta
 </code>
 , and resolution to request historical data based on the given trailing period of time and resolution.
</p>
<div class="section-example-container">
 <pre class="csharp">var history = qb.History(symbol, TimeSpan.FromDays(10));</pre>
 <pre class="python">history = qb.History(symbol, timedelta(days=10))</pre>
</div>
<p>
 This method returns the most recent bars, excluding periods of time when the exchange was closed.
</p>
<h4>
 Defined Period of Time
 <br/>
</h4>
<p>
 Call the
 <code>
  History
 </code>
 method with a symbol, start
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , end
 <code class="csharp">
  DateTime
 </code>
 <code class="python">
  datetime
 </code>
 , and resolution to request historical data based on the defined period of time and resolution. The start and end times you provide are based in the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/initialization#04-Set-Time-Zone">
  notebook time zone
 </a>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">var startTime = new DateTime(2013, 7, 29);
var endTime = new DateTime(2014, 7, 29);
var history = qb.History(symbol, startTime, endTime);</pre>
 <pre class="python">start_time = datetime(2013, 7, 29)
end_time = datetime(2014, 7, 29)
history = qb.History(symbol, start_time, end_time)</pre>
</div>
<p>
 This method returns the bars that are timestamped within the defined period of time.
</p>
<p class="python">
 In all of the cases above, the
 <code>
  History
 </code>
 method returns a
 <code>
  DataFrame
 </code>
 with a
 <code>
  MultiIndex
 </code>
 .
</p>
<img alt="Dataframe of custom NIFTY data from history call" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-custom-full.png"/>
<p class="csharp">
 In all of the cases above, the
 <code>
  History
 </code>
 method returns an
 <code>
  IEnumerable&lt;Nifty&gt;
 </code>
 for single-security requests.
</p>
<h4>
 Download Method
 <br/>
</h4>
<p>
 To download the data directly from the remote file location instead of using your custom data class, call the
 <code>
  Download
 </code>
 method with the data URL.
</p>
<div class="section-example-container">
 <pre class="csharp">var content = qb.Download("http://cdn.quantconnect.com.s3.us-east-1.amazonaws.com/uploads/CNXNIFTY.csv");</pre>
 <pre class="python">content = qb.Download("http://cdn.quantconnect.com.s3.us-east-1.amazonaws.com/uploads/CNXNIFTY.csv")</pre>
</div>
<p class="python">
 Follow these steps to convert the content to a
 <code>
  DataFrame
 </code>
 :
</p>
<ol class="python">
 <li>
  Import the
  <code>
   StringIO
  </code>
  from the
  <code>
   io
  </code>
  library.
 </li>
 <div class="python section-example-container">
  <pre class="python">from io import StringIO</pre>
 </div>
 <li>
  Create a
  <code>
   StringIO
  </code>
  .
 </li>
 <div class="python section-example-container">
  <pre class="python">data = StringIO(content)</pre>
 </div>
 <li>
  Call the
  <code>
   read_csv
  </code>
  method.
 </li>
 <div class="python section-example-container">
  <pre class="python">dataframe = pd.read_csv(data, index_col=0)</pre>
 </div>
</ol>
<img alt="Dataframe of custom NIFTY data from io read csv" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-custom-download.png"/>

<h3>Wrangle Data</h3>
<p class="python">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/custom-data#05-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. To display
 <code>
  pandas
 </code>
 objects, run a cell in a notebook with the
 <code>
  pandas
 </code>
 object as the last line. To display other data formats, call the
 <code>
  print
 </code>
 method.
</p>
<p class="csharp">
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/custom-data#05-Get-Historical-Data">
  historical data
 </a>
 to perform wrangling operations. Use LINQ to wrangle the data and then call the
 <code>
  Console.WriteLine
 </code>
 method in a Jupyter Notebook to display the data.
</p>
<p class="python">
 The
 <code>
  DataFrame
 </code>
 that the
 <code>
  History
 </code>
 method returns has the following index levels:
</p>
<ol class="python">
 <li>
  Dataset
  <code>
   Symbol
  </code>
 </li>
 <li>
  The
  <code>
   EndTime
  </code>
  of the data sample
 </li>
</ol>
<p class="python">
 The columns of the
 <code>
  DataFrame
 </code>
 are the data properties.
</p>
<img alt="Dataframe of custom NIFTY data" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/custom-research-data-1.jpg"/>
<p class="python">
 To select the data of a single dataset, index the
 <code>
  loc
 </code>
 property of the
 <code>
  DataFrame
 </code>
 with the data
 <code>
  Symbol
 </code>
 .
</p>
<div class="python section-example-container">
 <pre class="python">history.loc[symbol]
</pre>
</div>
<img alt="Dataframe of custom NIFTY data with symbol selected" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/custom-research-data-2.jpg"/>
<p class="python">
 To select a column of the
 <code>
  DataFrame
 </code>
 , index it with the column name.
</p>
<div class="python section-example-container">
 <pre class="python">history.loc[symbol]['close']
</pre>
</div>
<img alt="Close price series of custom NIFTY data" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/custom-research-data-3.jpg"/>
<p class="csharp">
 To get each custom data object, iterate through the result of the history request.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">foreach(var nifty in history)
{
    Console.WriteLine($"{nifty} EndTime: {nifty.EndTime}");
}
</pre>
</div>

<h3>Plot Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/custom-data#05-Get-Historical-Data">
  historical custom data
 </a>
 to produce plots. You can use
 <span class="python">
  many of the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
   supported plotting libraries
  </a>
 </span>
 <span class="csharp">
  <code>
   Plot.NET
  </code>
  package
 </span>
 to visualize data in various formats. For example, you can plot candlestick and line charts.
</p>
<h4>
 Candlestick Chart
 <br/>
</h4>
<p>
 Follow these steps to plot candlestick charts:
</p>
<ol>
 <li>
  Import the
  <code class="python">
   plotly
  </code>
  <code class="csharp">
   Plotly.NET
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">import plotly.graph_objects as go</pre>
  <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
 <li>
  Select the data:
 </li>
 <div class="section-example-container">
  <pre class="python">history = history.loc[symbol]</pre>
  <pre class="csharp">var history = qb.History&lt;Nifty&gt;(symbol, new DateTime(2013, 7, 1), new DateTime(2014, 7, 31));</pre>
 </div>
 <li>
  Create a
  <code>
   Candlestick
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">candlestick = go.Candlestick(x=history.index,
                             open=history['open'],
                             high=history['high'],
                             low=history['low'],
                             close=history['close'])</pre>
  <pre class="csharp">var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    history.Select(x =&gt; x.Open),
    history.Select(x =&gt; x.High),
    history.Select(x =&gt; x.Low),
    history.Select(x =&gt; x.Close),
    history.Select(x =&gt; x.EndTime)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">layout = go.Layout(title=go.layout.Title(text=f'{symbol} OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{symbol} OHLC");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="python">
  Create a
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="python section-example-container">
  <pre>fig = go.Figure(data=[candlestick], layout=layout)</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the
  <code>
   Figure
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Candlestick charts display the open, high, low, and close prices of the security.
 </p>
</ol>
<img alt="Candlestick plot of custom NIFTY OHLC" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-custom-candlestick.png"/>
<img alt="Candlestick plot of custom NIFTY OHLC" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-custom-candlestick-csharp.png"/>
<h4>
 Line Chart
</h4>
<p>
 Follow these steps to plot line charts using
 <span class="python">
  built-in methods
 </span>
 <span class="csharp">
  <code>
   Plotly.NET
  </code>
  package
 </span>
 :
</p>
<ol>
 <li class="python">
  Select data to plot.
 </li>
 <div class="python section-example-container">
  <pre>values = history['value'].unstack(level=0)</pre>
 </div>
 <li class="python">
  Call the
  <code>
   plot
  </code>
  method on the
  <code>
   pandas
  </code>
  object.
 </li>
 <div class="python section-example-container">
  <pre>values.plot(title="Value", figsize=(15, 10))</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Line
  </code>
  chart.
 </li>
 <div class="csharp section-example-container">
  <pre>var chart = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    history.Select(x =&gt; x.EndTime),
    history.Select(x =&gt; x.Close)
);</pre>
 </div>
 <li class="csharp">
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{symbol} Close");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li class="csharp">
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="csharp section-example-container">
  <pre>chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.show()</pre>
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart))</pre>
 </div>
 <p>
  Line charts display the value of the property you selected in a time series.
 </p>
</ol>
<img alt="Line chart of custom NIFTY value" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-custom-lineplot.png"/>
<img alt="Line chart of custom NIFTY value" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/research-history-custom-lineplot-csharp.png"/>

<p style="page-break-after: always;">&nbsp;</p>
<section id="4"><h3>4 Charting</h3></section>

<div class="sub-heading-landing">
 <div class="internal-content">
  <p>
   The Research Environment is centered around analyzing and understanding data. One way to gain a more intuitive understanding of the existing relationships in our data is to visualize it using charts. There are many different libraries that allow you to chart our data in different ways. Sometimes the right chart can illuminate an interesting relationship in the data. Click one of the following libraries to learn more about it:
  </p>
 </div>
 <div class="docs-landing-links">
  <div class="col-md-6 col-sm-12 docs-landing-link-wrap">
   <div class="content clickable" onclick="window.location.href = '/docs/v2/research-environment/charting/bokeh'">
    <div class="docs-internal-link">
     <h4>
      Bokeh
     </h4>
    </div>
   </div>
  </div>
  <div class="col-md-6 col-sm-12 docs-landing-link-wrap">
   <div class="content clickable" onclick="window.location.href = '/docs/v2/research-environment/charting/matplotlib'">
    <div class="docs-internal-link">
     <h4>
      Matplotlib
     </h4>
    </div>
   </div>
  </div>
  <div class="col-md-6 col-sm-12 docs-landing-link-wrap">
   <div class="content clickable" onclick="window.location.href = '/docs/v2/research-environment/charting/plotly'">
    <div class="docs-internal-link">
     <h4>
      Plotly
     </h4>
    </div>
   </div>
  </div>
  <div class="col-md-6 col-sm-12 docs-landing-link-wrap">
   <div class="content clickable" onclick="window.location.href = '/docs/v2/research-environment/charting/seaborn'">
    <div class="docs-internal-link">
     <h4>
      Seaborn
     </h4>
    </div>
   </div>
  </div>
  <div class="col-md-6 col-sm-12 docs-landing-link-wrap">
   <div class="content clickable" onclick="window.location.href = '/docs/v2/research-environment/charting/plotly-net'">
    <div class="docs-internal-link">
     <h4>
      Plotly NET
     </h4>
    </div>
   </div>
  </div>
 </div>
 <div class="see-also">
  <h3>
   See Also
  </h3>
  <a href="/docs/v2/writing-algorithms/key-concepts/libraries">
   Supported Libraries
  </a>
  <br/>
  <a href="/docs/v2/writing-algorithms/charting">
   Algorithm Charting
  </a>
  <br/>
 </div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="4.1"><h3>4.1 Bokeh</h3></section>

<h3>Introduction</h3>
<p>
 <code>
  bokeh
 </code>
 is a Python library you can use to create interactive visualizations. It helps you build beautiful graphics, ranging from simple plots to complex dashboards with streaming datasets. With
 <code>
  bokeh
 </code>
 , you can create JavaScript-powered visualizations without writing any JavaScript.
</p>

<h3>Import Libraries</h3>
<p>
 Follow these steps to import the libraries that you need:
</p>
<ol>
 <li>
  Import the
  <code>
   bokeh
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">from bokeh.plotting import figure, show
from bokeh.models import BasicTicker, ColorBar, ColumnDataSource, LinearColorMapper
from bokeh.palettes import Category20c
from bokeh.transform import cumsum, transform
from bokeh.io import output_notebook</pre>
 </div>
 <li>
  Call the
  <code>
   output_notebook
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">output_notebook()</pre>
 </div>
 <li>
  Import the
  <code>
   numpy
  </code>
  library.
 </li>
 <div class="section-example-container">
  <pre class="python">import numpy as np</pre>
 </div>
</ol>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to produce the plots. For example, to get data for a bank sector ETF and some banking companies over 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
tickers = ["XLF",   # Financial Select Sector SPDR Fund
           "COF",   # Capital One Financial Corporation
           "GS",    # Goldman Sachs Group, Inc.
           "JPM",   # J P Morgan Chase &amp; Co
           "WFC"]   # Wells Fargo &amp; Company   
symbols = [qb.AddEquity(ticker, Resolution.Daily).Symbol for ticker in tickers]
history = qb.History(symbols, datetime(2021, 1, 1), datetime(2022, 1, 1))</pre>
</div>

<h3>Create Candlestick Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create candlestick charts.
</p>
<p>
 In this example, you create a candlestick chart that shows the open, high, low, and close prices of one of the banking securities. Follow these steps to create the candlestick chart:
</p>
<ol>
 <li>
  Select a
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">symbol = symbols[0]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  <code>
   DataFrame
  </code>
  with the
  <code>
   symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">data = history.loc[symbol]</pre>
 </div>
 <li>
  Divide the
  <code>
   data
  </code>
  into days with positive returns and days with negative returns.
 </li>
 <div class="section-example-container">
  <pre class="python">up_days = data[data['close'] &gt; data['open']]
down_days = data[data['open'] &gt; data['close']]</pre>
 </div>
 <li>
  Call the
  <code>
   figure
  </code>
  function with a title, axis labels and x-axis type.
 </li>
 <div class="section-example-container">
  <pre class="python">plot = figure(title=f"{symbol} OHLC", x_axis_label='Date', y_axis_label='Price', x_axis_type='datetime')</pre>
 </div>
 <li>
  Call the
  <code>
   segment
  </code>
  method with the
  <code>
   data
  </code>
  timestamps, high prices, low prices, and a color.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.segment(data.index, data['high'], data.index, data['low'], color="black")</pre>
 </div>
 <p>
  This method call plots the candlestick wicks.
 </p>
 <li>
  Call the
  <code>
   vbar
  </code>
  method for the up and down days with the
  <code>
   data
  </code>
  timestamps, open prices, close prices, and a color.
 </li>
 <div class="section-example-container">
  <pre class="python">width = 12*60*60*1000
plot.vbar(up_days.index, width, up_days['open'], up_days['close'], <br/>          fill_color="green", line_color="green")
plot.vbar(down_days.index, width, down_days['open'], down_days['close'],<br/>          fill_color="red", line_color="red")</pre>
 </div>
 <p>
  This method call plots the candlestick bodies.
 </p>
 <li>
  Call the
  <code>
   show
  </code>
  function.
 </li>
 <div class="section-example-container">
  <pre class="python">show(plot)</pre>
 </div>
 <p>
  The Jupyter Notebook displays the candlestick chart.
 </p>
 <img alt="Bokeh candlestick plot" class="docs-image" src="https://cdn.quantconnect.com/i/tu/bokeh-plot.png"/>
</ol>

<h3>Create Line Plot</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create line charts.
</p>
<p>
 In this example, you create a line chart that shows the closing price for one of the banking securities. Follow these steps to create the line chart:
</p>
<ol>
 <li>
  Select a
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">symbol = symbols[0]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  DataFrame with the
  <code>
   symbol
  </code>
  and then select the close column.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history.loc[symbol]['close']</pre>
 </div>
 <li>
  Call the
  <code>
   figure
  </code>
  function with title, axis labels and x-axis type..
 </li>
 <div class="section-example-container">
  <pre class="python">plot = figure(title=f"{symbol} Close Price", x_axis_label='Date', y_axis_label='Price', x_axis_type='datetime')</pre>
 </div>
 <li>
  Call the
  <code>
   line
  </code>
  method with the timestamps,
  <code>
   close_prices
  </code>
  , and some design settings.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.line(close_prices.index, close_prices, 
          legend_label=symbol.Value, color="blue", line_width=2)</pre>
 </div>
 <li>
  Call the
  <code>
   show
  </code>
  function.
 </li>
 <div class="section-example-container">
  <pre class="python">show(plot)</pre>
 </div>
 <p>
  The Jupyter Notebook displays the line plot.
 </p>
 <img alt="Bokeh line plot" class="docs-image" src="https://cdn.quantconnect.com/i/tu/bokeh-line-new.png"/>
</ol>

<h3>Create Scatter Plot</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create scatter plots.
</p>
<p>
 In this example, you create a scatter plot that shows the relationship between the daily returns of two banking securities. Follow these steps to create the scatter plot:
</p>
<ol>
 <li>
  Select 2
  <code>
   Symbol
  </code>
  s.
 </li>
 <p>
  For example, to select the
  <code>
   Symbol
  </code>
  s of the first 2 bank stocks, run:
 </p>
 <div class="section-example-container">
  <pre class="python">symbol1 = symbols[1]
symbol2 = symbols[2]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  DataFrame with each
  <code>
   Symbol
  </code>
  and then select the close column.
 </li>
 <div class="section-example-container">
  <pre class="python">close_price1 = history.loc[symbol1]['close']
close_price2 = history.loc[symbol2]['close']</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  and
  <code>
   dropna
  </code>
  methods on each
  <code>
   Series
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">daily_return1 = close_price1.pct_change().dropna()
daily_return2 = close_price2.pct_change().dropna()</pre>
 </div>
 <li>
  Call the
  <code>
   polyfit
  </code>
  method with the
  <code>
   daily_returns1
  </code>
  ,
  <code>
   daily_returns2
  </code>
  , and a degree.
 </li>
 <div class="section-example-container">
  <pre class="python">m, b = np.polyfit(daily_returns1, daily_returns2, deg=1)</pre>
 </div>
 <p>
  This method call returns the slope and intercept of the ordinary least squares regression line.
 </p>
 <li>
  Call the
  <code>
   linspace
  </code>
  method with the minimum and maximum values on the x-axis.
 </li>
 <div class="section-example-container">
  <pre class="python">x = np.linspace(daily_returns1.min(), daily_returns1.max())</pre>
 </div>
 <li>
  Calculate the y-axis coordinates of the regression line.
 </li>
 <div class="section-example-container">
  <pre class="python">y = m*x + b</pre>
 </div>
 <li>
  Call the
  <code>
   figure
  </code>
  function with a title and axis labels.
 </li>
 <div class="section-example-container">
  <pre class="python">plot = figure(title=f"{symbol1} vs {symbol2} Daily Return", 
              x_axis_label=symbol1.Value, y_axis_label=symbol2.Value)</pre>
 </div>
 <li>
  Call the
  <code>
   line
  </code>
  method with x- and y-axis values, a color, and a line width.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.line(x, y, color="red", line_width=2)</pre>
 </div>
 <p>
  This method call plots the regression line.
 </p>
 <li>
  Call the
  <code>
   dot
  </code>
  method with the
  <code>
   daily_returns1
  </code>
  ,
  <code>
   daily_returns2
  </code>
  , and some design settings.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.dot(daily_returns1, daily_returns2, size=20, color="navy", alpha=0.5)</pre>
 </div>
 <p>
  This method call plots the scatter plot dots.
 </p>
 <li>
  Call the
  <code>
   show
  </code>
  function.
 </li>
 <div class="section-example-container">
  <pre class="python">show(plot)</pre>
 </div>
 <p>
  The Jupyter Notebook displays the scatter plot.
 </p>
 <img alt="Bokeh scatter plot" class="docs-image" src="https://cdn.quantconnect.com/i/tu/bokeh-scatter.png"/>
</ol>

<h3>Create Histogram</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create histograms.
</p>
<p>
 In this example, you create a histogram that shows the distribution of the daily percent returns of the bank sector ETF. In addition to the bins in the histogram, you overlay a normal distribution curve for comparison. Follow these steps to create the histogram:
</p>
<ol>
 <li>
  Select the
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">symbol = symbols[0]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  DataFrame with the
  <code>
   symbol
  </code>
  and then select the close column.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history.loc[symbol]['close']</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method and then call the
  <code>
   dropna
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change().dropna()</pre>
 </div>
 <li>
  Call the
  <code>
   histogram
  </code>
  method with the
  <code>
   daily_returns
  </code>
  , the density argument enabled, and a number of bins.
 </li>
 <div class="section-example-container">
  <pre class="python">hist, edges = np.histogram(daily_returns, density=True, bins=20)</pre>
 </div>
 <p>
  This method call returns the following objects:
 </p>
 <ul>
  <li>
   <code>
    hist
   </code>
   : The value of the probability density function at each bin, normalized such that the integral over the range is 1.
  </li>
  <li>
   <code>
    edges
   </code>
   : The x-axis value of the edges of each bin.
  </li>
 </ul>
 <li>
  Call the
  <code>
   figure
  </code>
  method with a title and axis labels.
 </li>
 <div class="section-example-container">
  <pre class="python">plot = figure(title=f"{symbol} Daily Return Distribution", 
              x_axis_label='Return', y_axis_label='Frequency')</pre>
 </div>
 <li>
  Call the
  <code>
   quad
  </code>
  method with the coordinates of the bins and some design settings.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.quad(top=hist, bottom=0, left=edges[:-1], right=edges[1:],
          fill_color="navy", line_color="white", alpha=0.5)</pre>
 </div>
 <p>
  This method call plots the histogram bins.
 </p>
 <li>
  Call the
  <code>
   mean
  </code>
  and
  <code>
   std
  </code>
  methods.
 </li>
 <div class="section-example-container">
  <pre class="python">mean = daily_returns.mean()
std = daily_returns.std()</pre>
 </div>
 <li>
  Call the
  <code>
   linspace
  </code>
  method with the lower limit, upper limit, and number data points for the x-axis of the normal distribution curve.
 </li>
 <div class="section-example-container">
  <pre class="python">x = np.linspace(-3*std, 3*std, 1000)</pre>
 </div>
 <li>
  Calculate the y-axis values of the normal distribution curve.
 </li>
 <div class="section-example-container">
  <pre class="python">pdf = 1/(std * np.sqrt(2*np.pi)) * np.exp(-(x-mean)**2 / (2*std**2))</pre>
 </div>
 <li>
  Call the
  <code>
   line
  </code>
  method with the data and style of the normal distribution PDF curve.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.line(x, pdf, color="red", line_width=4, 
          alpha=0.7, legend_label="Normal Distribution PDF")</pre>
 </div>
 <p>
  This method call plots the normal distribution PDF curve.
 </p>
 <li>
  Call
  <code>
   show
  </code>
  to show the plot.
 </li>
 <div class="section-example-container">
  <pre class="python">show(plot)</pre>
 </div>
 <p>
  The Jupyter Notebook displays the histogram.
 </p>
 <img alt="Bokeh histogram" class="docs-image" src="https://cdn.quantconnect.com/i/tu/bokeh-histogram.png"/>
</ol>

<h3>Create Bar Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create bar charts.
</p>
<p>
 In this example, you create a bar chart that shows the average daily percent return of the banking securities. Follow these steps to create the bar chart:
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method and then multiply by 100.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change() * 100</pre>
 </div>
 <li>
  Call the
  <code>
   mean
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">avg_daily_returns = daily_returns.mean()</pre>
 </div>
 <li>
  Call the
  <code>
   DataFrame
  </code>
  constructor with the
  <code>
   data Series
  </code>
  and then call the
  <code>
   reset_index
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">avg_daily_returns = pd.DataFrame(avg_daily_returns, columns=['avg_return']).reset_index()</pre>
 </div>
 <li>
  Call the
  <code>
   figure
  </code>
  function with a title, x-axis values, and axis labels.
 </li>
 <div class="section-example-container">
  <pre class="python">plot = figure(title='Banking Stocks Average Daily % Returns', x_range=avg_daily_returns['symbol'], 
              x_axis_label='%', y_axis_label='Stocks')</pre>
 </div>
 <li>
  Call the
  <code>
   vbar
  </code>
  method with the
  <code>
   avg_daily_returns
  </code>
  , x- and y-axis column names, and a bar width.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.vbar(source=avg_daily_returns, x='symbol', top='avg_return', width=0.8)</pre>
 </div>
 <li>
  Rotate the x-axis label and then call the
  <code>
   show
  </code>
  function.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">plot.xaxis.major_label_orientation = 0.6
show(plot)</pre>
 </div>
 <p>
  The Jupyter Notebook displays the bar chart.
 </p>
 <img alt="Bokeh bar chart" class="docs-image" src="https://cdn.quantconnect.com/i/tu/bokeh-bar.png"/>
</ol>

<h3>Create Heat Map</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create heat maps.
</p>
<p>
 In this example, you create a heat map that shows the correlation between the daily returns of the banking securities. Follow these steps to create the heat map:
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change()</pre>
 </div>
 <li>
  Call the
  <code>
   corr
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">corr_matrix = daily_returns.corr()</pre>
 </div>
 <li>
  Set the index and columns of the
  <code>
   corr_matrix
  </code>
  to the ticker of each security and then set the name of the column and row indices.
 </li>
 <div class="section-example-container">
  <pre class="python">corr_matrix.index = corr_matrix.columns = [symbol.Value for symbol in symbols]
corr_matrix.index.name = 'symbol'
corr_matrix.columns.name = "stocks"</pre>
 </div>
 <li>
  Call the
  <code>
   stack
  </code>
  ,
  <code>
   rename
  </code>
  , and
  <code>
   reset_index
  </code>
  methods.
 </li>
 <div class="section-example-container">
  <pre class="python">corr_matrix = corr_matrix.stack().rename("value").reset_index()</pre>
 </div>
 <li>
  Call the
  <code>
   figure
  </code>
  function with a title, axis ticks, and some design settings.
 </li>
 <div class="section-example-container">
  <pre class="python">plot = figure(title=f"Banking Stocks and Bank Sector ETF Correlation Heat Map",
              x_range=list(corr_matrix.symbol.drop_duplicates()),
              y_range=list(corr_matrix.stocks.drop_duplicates()),
              toolbar_location=None,
              tools="",
              x_axis_location="above")</pre>
 </div>
 <li>
  Select a color palette and then call the
  <code>
   LinearColorMapper
  </code>
  constructor with the color pallet, the minimum correlation, and the maximum correlation.
 </li>
 <div class="section-example-container">
  <pre class="python">colors = Category20c[len(corr_matrix.columns)]
mapper = LinearColorMapper(palette=colors, low=corr_matrix.value.min(), 
                           high=corr_matrix.value.max())</pre>
 </div>
 <li>
  Call the
  <code>
   rect
  </code>
  method with the correlation plot data and design setting.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.rect(source=ColumnDataSource(corr_matrix), 
          x="stocks", 
          y="symbol",
          width=1,
          height=1,
          line_color=None,
          fill_color=transform('value', mapper))</pre>
 </div>
 <li>
  Call the
  <code>
   ColorBar
  </code>
  constructor with the
  <code>
   mapper
  </code>
  , a location, and a
  <code>
   BaseTicker
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">color_bar = ColorBar(color_mapper=mapper,
                    location=(0, 0),
                    ticker=BasicTicker(desired_num_ticks=len(colors)))</pre>
 </div>
 <p>
  This snippet creates a color bar to represent the correlation coefficients of the heat map cells.
 </p>
 <li>
  Call the
  <code>
   add_layout
  </code>
  method with the
  <code>
   color_bar
  </code>
  and a location.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.add_layout(color_bar, 'right')</pre>
 </div>
 <p>
  This method call plots the color bar to the right of the heat map.
 </p>
 <li>
  Call the
  <code>
   show
  </code>
  function.
 </li>
 <div class="section-example-container">
  <pre class="python">show(plot)</pre>
 </div>
 <p>
  The Jupyter Notebook displays the heat map.
 </p>
 <img alt="Bokeh heat map" class="docs-image" src="https://cdn.quantconnect.com/i/tu/bokeh-heatmap-2.jpeg"/>
</ol>

<h3>Create Pie Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create pie charts.
</p>
<p>
 In this example, you create a pie chart that shows the weights of the banking securities in a portfolio if you allocate to them based on their inverse volatility. Follow these steps to create the pie chart:
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change()</pre>
 </div>
 <li>
  Call the
  <code>
   var
  </code>
  method, take the inverse, and then normalize the result.
 </li>
 <div class="section-example-container">
  <pre class="python">inverse_variance = 1 / daily_returns.var()
inverse_variance /= np.sum(inverse_variance)   # Normalization
inverse_variance *= np.pi*2    # For a full circle circumference in radian</pre>
 </div>
 <li>
  Call the
  <code>
   DataFrame
  </code>
  constructor with the
  <code>
   inverse_variance Series
  </code>
  and then call the
  <code>
   reset_index
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">inverse_variance = pd.DataFrame(inverse_variance, columns=["inverse variance"]).reset_index()</pre>
 </div>
 <li>
  Add a color column to the
  <code>
   inverse_variance DataFrame
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">inverse_variance['color'] = Category20c[len(inverse_variance.index)]</pre>
 </div>
 <li>
  Call the
  <code>
   figure
  </code>
  function with a title.
 </li>
 <div class="section-example-container">
  <pre class="python">plot = figure(title=f"Banking Stocks and Bank Sector ETF Allocation")</pre>
 </div>
 <li>
  Call the
  <code>
   wedge
  </code>
  method with design settings and the
  <code>
   inverse_variance DataFrame
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">plot.wedge(x=0, y=1, radius=0.6, start_angle=cumsum('inverse variance', include_zero=True), 
           end_angle=cumsum('inverse variance'), line_color="white", fill_color='color', 
           legend_field='symbol', source=inverse_variance)</pre>
 </div>
 <li>
  Call the
  <code>
   show
  </code>
  function.
 </li>
 <div class="section-example-container">
  <pre class="python">show(plot)</pre>
 </div>
 <p>
  The Jupyter Notebook displays the pie chart.
 </p>
 <img alt="Bokeh pie chart" class="docs-image" src="https://cdn.quantconnect.com/i/tu/bokeh-pie.png"/>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="4.2"><h3>4.2 Matplotlib</h3></section>

<h3>Introduction</h3>
<p>
 <code>
  matplotlib
 </code>
 is the most popular 2d-charting library for python. It allows you to easily create histograms, scatter plots, and various other charts. In addition,
 <code>
  pandas
 </code>
 is integrated with
 <code>
  matplotlib
 </code>
 , so you can seamlessly move between data manipulation and data visualization. This makes
 <code>
  matplotlib
 </code>
 great for quickly producing a chart to visualize your data.
</p>

<h3>Import Libraries</h3>
<p>
 Follow these steps to import the libraries that you need:
</p>
<ol>
 <li>
  Import the
  <code>
   matplotlib
  </code>
  ,
  <code>
   mplfinance
  </code>
  , and
  <code>
   numpy
  </code>
  libraries.
 </li>
 <div class="section-example-container">
  <pre class="python">import matplotlib.pyplot as plt
import mplfinance
import numpy as np</pre>
 </div>
 <li>
  Import, and then call, the
  <code>
   register_matplotlib_converters
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()</pre>
 </div>
</ol>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to produce the plots. For example, to get data for a bank sector ETF and some banking companies over 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
tickers = ["XLF",   # Financial Select Sector SPDR Fund
           "COF",   # Capital One Financial Corporation
           "GS",    # Goldman Sachs Group, Inc.
           "JPM",   # J P Morgan Chase &amp; Co
           "WFC"]   # Wells Fargo &amp; Company   
symbols = [qb.AddEquity(ticker, Resolution.Daily).Symbol for ticker in tickers]
history = qb.History(symbols, datetime(2021, 1, 1), datetime(2022, 1, 1))</pre>
</div>

<h3>Create Candlestick Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create candlestick charts.
</p>
<p>
 In this example, we'll create a candlestick chart that shows the open, high, low, and close prices of one of the banking securities. Follow these steps to create the candlestick chart:
</p>
<ol>
 <li>
  Select a
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">symbol = symbols[0]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  <code>
   DataFrame
  </code>
  with the
  <code>
   symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">data = history.loc[symbol]</pre>
 </div>
 <li>
  Rename the columns.
 </li>
 <div class="section-example-container">
  <pre class="python">data.columns = ['Close', 'High', 'Low', 'Open', 'Volume']</pre>
 </div>
 <li>
  Call the
  <code>
   plot
  </code>
  method with the
  <code>
   data
  </code>
  , chart type, style, title, y-axis label, and figure size.
 </li>
 <div class="section-example-container">
  <pre class="python">mplfinance.plot(data,
                type='candle',
                style='charles',
                title=f'{symbol.Value} OHLC',
                ylabel='Price ($)',
                figratio=(15, 10))</pre>
 </div>
 <p>
  The Jupyter Notebook displays the candlestick chart.
 </p>
 <img alt="Matplotlib candlestick plot" class="docs-image" src="https://cdn.quantconnect.com/i/tu/matplotlib-candlestick.png"/>
</ol>

<h3>Create Line Plot</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create line charts.
</p>
<p>
 In this example, you create a line chart that shows the closing price for one of the banking securities. Follow these steps to create the line chart:
</p>
<ol>
 <li>
  Select a
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">symbol = symbols[0]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  DataFrame with
  <code>
   symbol
  </code>
  and then select the close column.
 </li>
 <div class="section-example-container">
  <pre class="python">data = history.loc[symbol]['close']</pre>
 </div>
 <li>
  Call the
  <code>
   plot
  </code>
  method with a title and figure size.
 </li>
 <div class="section-example-container">
  <pre class="python">data.plot(title=f"{symbol} Close Price", figsize=(15, 10));</pre>
 </div>
 <p>
  The Jupyter Notebook displays the line plot.
 </p>
 <img alt="Matplotlib line plot" class="docs-image" src="https://cdn.quantconnect.com/i/tu/matplotlib-line-4.png"/>
</ol>

<h3>Create Scatter Plot</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create scatter plots.
</p>
<p>
 In this example, you create a scatter plot that shows the relationship between the daily returns of two banking securities. Follow these steps to create the scatter plot:
</p>
<ol>
 <li>
  Select the 2
  <code>
   Symbol
  </code>
  s.
 </li>
 <p>
  For example, to select the
  <code>
   Symbol
  </code>
  s of the first 2 bank stocks, run:
 </p>
 <div class="section-example-container">
  <pre class="python">symbol1 = symbols[1]
symbol2 = symbols[2]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  DataFrame with each
  <code>
   Symbol
  </code>
  and then select the close column.
 </li>
 <div class="section-example-container">
  <pre class="python">close_price1 = history.loc[symbol1]['close']
close_price2 = history.loc[symbol2]['close']</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  and
  <code>
   dropna
  </code>
  methods on each
  <code>
   Series
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns1 = close_price1.pct_change().dropna()
daily_returns2 = close_price2.pct_change().dropna()</pre>
 </div>
 <li>
  Call the
  <code>
   polyfit
  </code>
  method with the
  <code>
   daily_returns1
  </code>
  ,
  <code>
   daily_returns2
  </code>
  , and a degree.
 </li>
 <div class="section-example-container">
  <pre class="python">m, b = np.polyfit(daily_returns1, daily_returns2, deg=1)</pre>
 </div>
 <p>
  This method call returns the slope and intercept of the ordinary least squares regression line.
 </p>
 <li>
  Call the
  <code>
   linspace
  </code>
  method with the minimum and maximum values on the x-axis.
 </li>
 <div class="section-example-container">
  <pre class="python">x = np.linspace(daily_returns1.min(), daily_returns1.max())</pre>
 </div>
 <li>
  Calculate the y-axis coordinates of the regression line.
 </li>
 <div class="section-example-container">
  <pre class="python">y = m*x + b</pre>
 </div>
 <li>
  Call the
  <code>
   plot
  </code>
  method with the coordinates and color of the regression line.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.plot(x, y, color='red')</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   plot
  </code>
  method, call the
  <code>
   scatter
  </code>
  method with the 2 daily return series.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.scatter(daily_returns1, daily_returns2)</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   scatter
  </code>
  method, call the
  <code>
   title
  </code>
  ,
  <code>
   xlabel
  </code>
  , and
  <code>
   ylabel
  </code>
  methods with a title and axis labels.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.title(f'{symbol1} vs {symbol2} daily returns Scatter Plot')
plt.xlabel(symbol1.Value)
plt.ylabel(symbol2.Value);</pre>
 </div>
 <p>
  The Jupyter Notebook displays the scatter plot.
 </p>
 <img alt="Matplotlib scatter plot" class="docs-image" src="https://cdn.quantconnect.com/i/tu/matplotlib-scatter-plot.png"/>
</ol>

<h3>Create Histogram</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create histograms.
</p>
<p>
 In this example, you create a histogram that shows the distribution of the daily percent returns of the bank sector ETF. In addition to the bins in the histogram, you overlay a normal distribution curve for comparison. Follow these steps to create the histogram:
</p>
<ol>
 <li>
  Select the
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">symbol = symbols[0]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  DataFrame with the
  <code>
   symbol
  </code>
  and then select the close column.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history.loc[symbol]['close']</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method and then call the
  <code>
   dropna
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change().dropna()</pre>
 </div>
 <li>
  Call the
  <code>
   mean
  </code>
  and
  <code>
   std
  </code>
  methods.
 </li>
 <div class="section-example-container">
  <pre class="python">mean = daily_returns.mean()
std = daily_returns.std()</pre>
 </div>
 <li>
  Call the
  <code>
   linspace
  </code>
  method with the lower limit, upper limit, and number data points for the x-axis of the normal distribution curve.
 </li>
 <div class="section-example-container">
  <pre class="python">x = np.linspace(-3*std, 3*std, 1000)</pre>
 </div>
 <li>
  Calculate the y-axis values of the normal distribution curve.
 </li>
 <div class="section-example-container">
  <pre class="python">pdf = 1/(std * np.sqrt(2*np.pi)) * np.exp(-(x-mean)**2 / (2*std**2))</pre>
 </div>
 <li>
  Call the
  <code>
   plot
  </code>
  method with the data for the normal distribution curve.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.plot(x, pdf, label="Normal Distribution")</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   plot
  </code>
  method, call the
  <code>
   hist
  </code>
  method with the daily return data and the number of bins.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.hist(daily_returns, bins=20)</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   hist
  </code>
  method, call the
  <code>
   title
  </code>
  ,
  <code>
   xlabel
  </code>
  , and
  <code>
   ylabel
  </code>
  methods with a title and the axis labels.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.title(f'{symbol} Return Distribution')
plt.xlabel('Daily Return')
plt.ylabel('Count');</pre>
 </div>
 <p>
  The Jupyter Notebook displays the histogram.
 </p>
 <img alt="Matplotlib histogram" class="docs-image" src="https://cdn.quantconnect.com/i/tu/matplotlib-hist-4.png"/>
</ol>

<h3>Create Bar Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create bar charts.
</p>
<p>
 In this example, you create a bar chart that shows the average daily percent return of the banking securities. Follow these steps to create the bar chart:
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method and then multiply by 100.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change() * 100</pre>
 </div>
 <li>
  Call the
  <code>
   mean
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">avg_daily_returns = daily_returns.mean()</pre>
 </div>
 <li>
  Call the
  <code>
   figure
  </code>
  method with a figure size.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.figure(figsize=(15, 10))</pre>
 </div>
 <li>
  Call the
  <code>
   bar
  </code>
  method with the x-axis and y-axis values.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.bar(avg_daily_returns.index, avg_daily_returns)</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   bar
  </code>
  method, call the
  <code>
   title
  </code>
  ,
  <code>
   xlabel
  </code>
  , and
  <code>
   ylabel
  </code>
  methods with a title and the axis labels.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.title('Banking Stocks Average Daily % Returns')
plt.xlabel('Tickers')
plt.ylabel('%');</pre>
 </div>
 <p>
  The Jupyter Notebook displays the bar chart.
 </p>
 <img alt="Matplotlib bar chart" class="docs-image" src="https://cdn.quantconnect.com/i/tu/matplotlib-bar.png"/>
</ol>

<h3>Create Heat Map</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create heat maps.
</p>
<p>
 In this example, you create a heat map that shows the correlation between the daily returns of the banking securities. Follow these steps to create the heat map:
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change()</pre>
 </div>
 <li>
  Call the
  <code>
   corr
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">corr_matrix = daily_returns.corr()</pre>
 </div>
 <li>
  Call the
  <code>
   imshow
  </code>
  method with the correlation matrix, a color map, and an interpolation method.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.imshow(corr_matrix, cmap='hot', interpolation='nearest')</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   imshow
  </code>
  method, call the
  <code>
   title
  </code>
  ,
  <code>
   xticks
  </code>
  , and
  <code>
   yticks
  </code>
  , methods with a title and the axis tick labels.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.title('Banking Stocks and Bank Sector ETF Correlation Heat Map')
plt.xticks(np.arange(len(tickers)), labels=tickers)
plt.yticks(np.arange(len(tickers)), labels=tickers)</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   imshow
  </code>
  method, call the
  <code>
   colorbar
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.colorbar();</pre>
 </div>
 <p>
  The Jupyter Notebook displays the heat map.
 </p>
 <img alt="Matplotlib heat map" class="docs-image" src="https://cdn.quantconnect.com/i/tu/matplotlib-heatmap-3.png"/>
</ol>

<h3>Create Pie Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create pie charts.
</p>
<p>
 In this example, you create a pie chart that shows the weights of the banking securities in a portfolio if you allocate to them based on their inverse volatility. Follow these steps to create the pie chart:
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change()</pre>
 </div>
 <li>
  Call the
  <code>
   var
  </code>
  method and then take the inverse.
 </li>
 <div class="section-example-container">
  <pre class="python">inverse_variance = 1 / daily_returns.var()</pre>
 </div>
 <li>
  Call the
  <code>
   pie
  </code>
  method with the
  <code>
   inverse_variance Series
  </code>
  , the plot labels, and a display format.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.pie(inverse_variance, labels=inverse_variance.index, autopct='%1.1f%%')</pre>
 </div>
 <li>
  In the cell that you called the
  <code>
   pie
  </code>
  method, call the
  <code>
   title
  </code>
  method with a title.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.title('Banking Stocks and Bank Sector ETF Allocation');</pre>
 </div>
 <p>
  The Jupyter Notebook displays the pie chart.
 </p>
 <img alt="Matplotlib pie chart" class="docs-image" src="https://cdn.quantconnect.com/i/tu/matplotlib-pie-3.png"/>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="4.3"><h3>4.3 Plotly</h3></section>

<h3>Introduction</h3>
<p>
 <code>
  plotly
 </code>
 is an online charting tool with a python API. It offers the ability to create rich and interactive graphs.
</p>

<h3>Import Libraries</h3>
<p>
 Import the
 <code>
  plotly
 </code>
 library.
</p>
<div class="section-example-container">
 <pre class="python">import plotly.express as px
import plotly.graph_objects as go</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to produce the plots. For example, to get data for a bank sector ETF and some banking companies over 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
tickers = ["XLF",   # Financial Select Sector SPDR Fund
           "COF",   # Capital One Financial Corporation
           "GS",    # Goldman Sachs Group, Inc.
           "JPM",   # J P Morgan Chase &amp; Co
           "WFC"]   # Wells Fargo &amp; Company   
symbols = [qb.AddEquity(ticker, Resolution.Daily).Symbol for ticker in tickers]
history = qb.History(symbols, datetime(2021, 1, 1), datetime(2022, 1, 1))</pre>
</div>

<h3>Create Candlestick Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create candlestick charts.
</p>
<p>
 In this example, you create a candlestick chart that shows the open, high, low, and close prices of one of the banking securities. Follow these steps to create the candlestick chart:
</p>
<ol>
 <li>
  Select a
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">symbol = symbols[0]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  <code>
   DataFrame
  </code>
  with the
  <code>
   symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">data = history.loc[symbol]</pre>
 </div>
 <li>
  Call the
  <code>
   Candlestick
  </code>
  constructor with the time and open, high, low, and close price
  <code>
   Series
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">candlestick = go.Candlestick(x=data.index,
                             open=data['open'],
                             high=data['high'],
                             low=data['low'],
                             close=data['close'])</pre>
 </div>
 <li>
  Call the
  <code>
   Layout
  </code>
  constructor with a title and axes labels.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">layout = go.Layout(title=go.layout.Title(text=f'{symbol.Value} OHLC'),
                   xaxis_title='Date',
                   yaxis_title='Price',
                   xaxis_rangeslider_visible=False)</pre>
 </div>
 <li>
  Call the
  <code>
   Figure
  </code>
  constructor with the
  <code>
   candlestick
  </code>
  and
  <code>
   layout
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">fig = go.Figure(data=[candlestick], layout=layout)</pre>
 </div>
 <li>
  Call the
  <code>
   show
  </code>
  method.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
 </div>
 <p>
  The Jupyter Notebook displays the candlestick chart.
 </p>
 <img alt="Plotly candlestick plot" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plotly-candle-3.png"/>
</ol>

<h3>Create Line Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create line charts.
</p>
<p>
 In this example, you create a line chart that shows the closing price for one of the banking securities. Follow these steps to create the line chart:
</p>
<ol>
 <li>
  Select a
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">symbol = symbols[0]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  DataFrame with the
  <code>
   symbol
  </code>
  and then select the close column.
 </li>
 <div class="section-example-container">
  <pre class="python">data = history.loc[symbol]['close']</pre>
 </div>
 <li>
  Call the
  <code>
   DataFrame
  </code>
  constructor with the
  <code>
   data Series
  </code>
  and then call the
  <code>
   reset_index
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">data = pd.DataFrame(data).reset_index()</pre>
 </div>
 <li>
  Call the
  <code>
   line
  </code>
  method with
  <code>
   data
  </code>
  , the column names of the x- and y-axis in
  <code>
   data
  </code>
  , and the plot title.
 </li>
 <div class="section-example-container">
  <pre class="python">fig = px.line(data, x='time', y='close', title=f'{symbol} Close price')</pre>
 </div>
 <li>
  Call the
  <code>
   show
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
 </div>
 <p>
  The Jupyter Notebook displays the line chart.
 </p>
 <img alt="Plotly line plot" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plotly-line-3.png"/>
</ol>

<h3>Create Scatter Plot</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create scatter plots.
</p>
<p>
 In this example, you create a scatter plot that shows the relationship between the daily returns of two banking securities. Follow these steps to create the scatter plot:
</p>
<ol>
 <li>
  Select 2
  <code>
   Symbol
  </code>
  s.
 </li>
 <p>
  For example, to select the
  <code>
   Symbol
  </code>
  s of the first 2 bank stocks, run:
 </p>
 <div class="section-example-container">
  <pre class="python">symbol1 = symbols[1]
symbol2 = symbols[2]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  DataFrame with each
  <code>
   Symbol
  </code>
  and then select the close column.
 </li>
 <div class="section-example-container">
  <pre class="python">close_price1 = history.loc[symbol1]['close']
close_price2 = history.loc[symbol2]['close']</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  and
  <code>
   dropna
  </code>
  methods on each
  <code>
   Series
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">daily_return1 = close_price1.pct_change().dropna()
daily_return2 = close_price2.pct_change().dropna()</pre>
 </div>
 <li>
  Call the
  <code>
   scatter
  </code>
  method with the 2 return
  <code>
   Series
  </code>
  , the trendline option, and axes labels.
 </li>
 <div class="section-example-container">
  <pre class="python">fig = px.scatter(x=daily_return1, y=daily_return2, trendline='ols', 
                 labels={'x': symbol1.Value, 'y': symbol2.Value}) </pre>
 </div>
 <li>
  Call the
  <code>
   update_layout
  </code>
  method with a title.
 </li>
 <div class="section-example-container">
  <pre class="python">fig.update_layout(title=f'{symbol1.Value} vs {symbol2.Value} Daily % Returns');</pre>
 </div>
 <li>
  Call the
  <code>
   show
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
 </div>
 <p>
  The Jupyter Notebook displays the scatter plot.
 </p>
 <img alt="Plotly scatter plot" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plotly-scatter-3.png"/>
</ol>

<h3>Create Histogram</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create histograms.
</p>
<p>
 In this example, you create a histogram that shows the distribution of the daily percent returns of the bank sector ETF. Follow these steps to create the histogram:
</p>
<ol>
 <li>
  Select the
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">symbol = symbols[0]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  DataFrame with the
  <code>
   symbol
  </code>
  and then select the close column.
 </li>
 <div class="section-example-container">
  <pre class="python">data = history.loc[symbol]['close']</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method and then call the
  <code>
   dropna
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = data.pct_change().dropna()</pre>
 </div>
 <li>
  Call the
  <code>
   DataFrame
  </code>
  constructor with the
  <code>
   data Series
  </code>
  and then call the
  <code>
   reset_index
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = pd.DataFrame(daily_returns).reset_index()</pre>
 </div>
 <li>
  Call the
  <code>
   histogram
  </code>
  method with the
  <code>
   daily_returns
  </code>
  DataFrame, the x-axis label, a title, and the number of bins.
 </li>
 <div class="section-example-container">
  <pre class="python">fig = px.histogram(daily_returns, x='close', 
                   title=f'{symbol} Daily Return of Close Price Distribution', 
                   nbins=20)</pre>
 </div>
 <li>
  Call the
  <code>
   show
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
 </div>
 <p>
  The Jupyter Notebook displays the histogram.
 </p>
 <img alt="Plotly histogram" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plotly-histogram.png"/>
</ol>

<h3>Create Bar Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create bar charts.
</p>
<p>
 In this example, you create a bar chart that shows the average daily percent return of the banking securities. Follow these steps to create the bar chart:
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method and then multiply by 100.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change() * 100</pre>
 </div>
 <li>
  Call the
  <code>
   mean
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">avg_daily_returns = daily_returns.mean()</pre>
 </div>
 <li>
  Call the
  <code>
   DataFrame
  </code>
  constructor with the
  <code>
   avg_daily_returns
  </code>
  <code>
   Series
  </code>
  and then call the
  <code>
   reset_index
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">avg_daily_returns = pd.DataFrame(avg_daily_returns, columns=["avg_daily_ret"]).reset_index()</pre>
 </div>
 <li>
  Call the
  <code>
   bar
  </code>
  method with the
  <code>
   avg_daily_returns
  </code>
  and the axes column names.
 </li>
 <div class="section-example-container">
  <pre class="python">fig = px.bar(avg_daily_returns, x='symbol', y='avg_daily_ret')</pre>
 </div>
 <li>
  Call the
  <code>
   update_layout
  </code>
  method with a title.
 </li>
 <div class="section-example-container">
  <pre class="python">fig.update_layout(title='Banking Stocks Average Daily % Returns');</pre>
 </div>
 <li>
  Call the
  <code>
   show
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
 </div>
 <p>
  The Jupyter Notebook displays the bar plot.
 </p>
 <img alt="Plotly bar chart" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plotly-bar-3.png"/>
</ol>

<h3>Create Heat Map</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create heat maps.
</p>
<p>
 In this example, you create a heat map that shows the correlation between the daily returns of the banking securities. Follow these steps to create the heat map:
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change()</pre>
 </div>
 <li>
  Call the
  <code>
   corr
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">corr_matrix = daily_returns.corr()</pre>
 </div>
 <li>
  Call the
  <code>
   imshow
  </code>
  method with the
  <code>
   corr_matrix
  </code>
  and the axes labels.
 </li>
 <div class="section-example-container">
  <pre class="python">fig = px.imshow(corr_matrix, x=tickers, y=tickers)</pre>
 </div>
 <li>
  Call the
  <code>
   update_layout
  </code>
  method with a title.
 </li>
 <div class="section-example-container">
  <pre class="python">fig.update_layout(title='Banking Stocks and bank sector ETF Correlation Heat Map');</pre>
 </div>
 <li>
  Call the
  <code>
   show
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
 </div>
 <p>
  The Jupyter Notebook displays the heat map.
 </p>
 <img alt="Plotly heat map" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plotly-heatmap-3.png"/>
</ol>

<h3>Create Pie Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create pie charts.
</p>
<p>
 In this example, you create a pie chart that shows the weights of the banking securities in a portfolio if you allocate to them based on their inverse volatility. Follow these steps to create the pie chart:
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change()</pre>
 </div>
 <li>
  Call the
  <code>
   var
  </code>
  method and then take the inverse.
 </li>
 <div class="section-example-container">
  <pre class="python">inverse_variance = 1 / daily_returns.var()</pre>
 </div>
 <li>
  Call the
  <code>
   DataFrame
  </code>
  constructor with the
  <code>
   inverse_variance Series
  </code>
  and then call the
  <code>
   reset_index
  </code>
  method.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">inverse_variance = pd.DataFrame(inverse_variance, columns=["inverse variance"]).reset_index()</pre>
 </div>
 <li>
  Call the
  <code>
   pie
  </code>
  method with the
  <code>
   inverse_variance DataFrame
  </code>
  , the column name of the values, and the column name of the names.
 </li>
 <div class="section-example-container">
  <pre class="python">fig = px.pie(inverse_variance, values='inverse variance', names='symbol')</pre>
 </div>
 <li>
  Call the
  <code>
   update_layout
  </code>
  method with a title.
 </li>
 <div class="section-example-container">
  <pre class="python">fig.update_layout(title='Asset Allocation of bank stocks and bank sector ETF');</pre>
 </div>
 <li>
  Call the
  <code>
   show
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">fig.show()</pre>
 </div>
 <p>
  The Jupyter Notebook displays the pie chart.
 </p>
 <img alt="Plotly pie chart" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plotly-pie-3.png"/>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="4.4"><h3>4.4 Seaborn</h3></section>

<h3>Introduction</h3>
<p>
 <code>
  seaborn
 </code>
 is a data visualization library based on
 <code>
  matplotlib
 </code>
 . It makes it easier to create more complicated plots and allows us to create much more visually-appealing charts than
 <code>
  matplotlib
 </code>
 charts.
</p>

<h3>Import Libraries</h3>
<p>
 Follow these steps to import the libraries that you need:
</p>
<ol>
 <li>
  Import the
  <code>
   seaborn
  </code>
  and
  <code>
   matplotlib
  </code>
  libraries.
 </li>
 <div class="section-example-container">
  <pre class="python">import seaborn as sns
import matplotlib.pyplot as plt</pre>
 </div>
 <li>
  Import, and then call, the
  <code>
   register_matplotlib_converters
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()</pre>
 </div>
</ol>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to produce the plots. For example, to get data for a bank sector ETF and some banking companies over 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
tickers = ["XLF",   # Financial Select Sector SPDR Fund
           "COF",   # Capital One Financial Corporation
           "GS",    # Goldman Sachs Group, Inc.
           "JPM",   # J P Morgan Chase &amp; Co
           "WFC"]   # Wells Fargo &amp; Company   
symbols = [qb.AddEquity(ticker, Resolution.Daily).Symbol for ticker in tickers]
history = qb.History(symbols, datetime(2021, 1, 1), datetime(2022, 1, 1))</pre>
</div>

<h3>Create Candlestick Chart</h3>
<p>
 Seaborn does not currently support candlestick charts. Use one of
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting">
  the other plotting libraries
 </a>
 to create candlestick charts.
</p>

<h3>Create Line Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create line charts.
</p>
<p>
 In this example, you create a line chart that shows the closing price for one of the banking securities. Follow these steps to create the chart:
</p>
<ol>
 <li>
  Select a
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">symbol = symbols[0]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  DataFrame with the
  <code>
   symbol
  </code>
  and then select the close column.
 </li>
 <div class="section-example-container">
  <pre class="python">data = history.loc[symbol]['close']</pre>
 </div>
 <li>
  Call the
  <code>
   DataFrame
  </code>
  constructor with the
  <code>
   data Series
  </code>
  and then call the
  <code>
   reset_index
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">data = pd.DataFrame(data).reset_index()</pre>
 </div>
 <li>
  Call the
  <code>
   lineplot
  </code>
  method with the
  <code>
   data Series
  </code>
  and the column name of each axis.
 </li>
 <div class="section-example-container">
  <pre class="python">plot = sns.lineplot(data=data,
                    x='time', 
                    y='close')</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   lineplot
  </code>
  method, call the
  <code>
   set
  </code>
  method with the y-axis label and a title.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.set(ylabel="price", title=f"{symbol} Price Over Time");</pre>
 </div>
 <p>
  The Jupyter Notebook displays the line chart.
 </p>
 <img alt="Seaborn line plot" class="docs-image" src="https://cdn.quantconnect.com/i/tu/seaborn-line-3.png"/>
</ol>

<h3>Create Scatter Plot</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create scatter plots.
</p>
<p>
 In this example, you create a scatter plot that shows the relationship between the daily returns of two banking securities. Follow these steps to create the scatter plot:
</p>
<ol>
 <li>
  Select 2
  <code>
   Symbol
  </code>
  s.
 </li>
 <p>
  For example, to select the
  <code>
   Symbol
  </code>
  s of the first 2 bank stocks, run:
 </p>
 <div class="section-example-container">
  <pre class="python">symbol1 = symbols[1]
symbol2 = symbols[2]</pre>
 </div>
 <li>
  Select the close column of the
  <code>
   history
  </code>
  DataFrame, call the
  <code>
   unstack
  </code>
  method, and then select the
  <code>
   symbol1
  </code>
  and
  <code>
   symbol2
  </code>
  columns.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(0)[[symbol1, symbol2]]</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method and then call the
  <code>
   dropna
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change().dropna()</pre>
 </div>
 <li>
  Call the
  <code>
   regplot
  </code>
  method with the
  <code>
   daily_returns DataFrame
  </code>
  and the column names.
 </li>
 <div class="section-example-container">
  <pre class="python">plot = sns.regplot(data=daily_returns, 
                   x=daily_returns.columns[0], 
                   y=daily_returns.columns[1])</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   regplot
  </code>
  method, call the
  <code>
   set
  </code>
  method with the axis labels and a title.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.set(xlabel=f'{daily_returns.columns[0]} % Returns', 
         ylabel=f'{daily_returns.columns[1]} % Returns', 
         title=f'{symbol1} vs {symbol2} Daily % Returns');</pre>
 </div>
 <p>
  The Jupyter Notebook displays the scatter plot.
 </p>
 <img alt="Seaborn scatter plot" class="docs-image" src="https://cdn.quantconnect.com/i/tu/seaborn-scatter-3.png"/>
</ol>

<h3>Create Histogram</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create histograms.
</p>
<p>
 In this example, you create a histogram that shows the distribution of the daily percent returns of the bank sector ETF. Follow these steps to create the histogram:
</p>
<ol>
 <li>
  Select the
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">symbol = symbols[0]</pre>
 </div>
 <li>
  Slice the
  <code>
   history
  </code>
  DataFrame with the
  <code>
   symbol
  </code>
  and then select the close column.
 </li>
 <div class="section-example-container">
  <pre class="python">data = history.loc[symbol]['close']</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method and then call the
  <code>
   dropna
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = data.pct_change().dropna()</pre>
 </div>
 <li>
  Call the
  <code>
   DataFrame
  </code>
  constructor with the
  <code>
   daily_returns Series
  </code>
  and then call the
  <code>
   reset_index
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = pd.DataFrame(daily_returns).reset_index()</pre>
 </div>
 <li>
  Call the
  <code>
   histplot
  </code>
  method with the
  <code>
   daily_returns
  </code>
  , the close column name, and the number of bins.
 </li>
 <div class="section-example-container">
  <pre class="python">plot = sns.histplot(daily_returns, x='close', bins=20)</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   histplot
  </code>
  method, call the
  <code>
   set
  </code>
  method with the axis labels and a title.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.set(xlabel='Return', 
         ylabel='Frequency', 
         title=f'{symbol} Daily Return of Close Price Distribution');</pre>
 </div>
 <p>
  The Jupyter Notebook displays the histogram.
 </p>
 <img alt="Seaborn heat map" class="docs-image" src="https://cdn.quantconnect.com/i/tu/seaborn-histogram.png"/>
</ol>

<h3>Create Bar Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create bar charts.
</p>
<p>
 In this example, you create a bar chart that shows the average daily percent return of the banking securities. Follow these steps to create the bar chart:
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method and then multiply by 100.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change() * 100</pre>
 </div>
 <li>
  Call the
  <code>
   mean
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">avg_daily_returns = daily_returns.mean()</pre>
 </div>
 <li>
  Call the
  <code>
   DataFrame
  </code>
  constructor with the
  <code>
   avg_daily_returns
  </code>
  <code>
   Series
  </code>
  and then call the
  <code>
   reset_index
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">avg_daily_returns = pd.DataFrame(avg_daily_returns, columns=["avg_daily_ret"]).reset_index()</pre>
 </div>
 <li>
  Call
  <code>
   barplot
  </code>
  method with the
  <code>
   avg_daily_returns
  </code>
  <code>
  </code>
  <code>
   Series
  </code>
  and the axes column names.
 </li>
 <div class="section-example-container">
  <pre class="python">plot = sns.barplot(data=avg_daily_returns, x='symbol', y='avg_daily_ret')</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   barplot
  </code>
  method, call the
  <code>
   set
  </code>
  method with the axis labels and a title.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.set(xlabel='Tickers', 
         ylabel='%', 
         title='Banking Stocks Average Daily % Returns')</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   set
  </code>
  method, call the
  <code>
   tick_params
  </code>
  method to rotate the x-axis labels.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.tick_params(axis='x', rotation=90)</pre>
 </div>
 <p>
  The Jupyter Notebook displays the bar chart.
 </p>
 <img alt="Seaborn bar chart" class="docs-image" src="https://cdn.quantconnect.com/i/tu/seaborn-bar-plot.png"/>
</ol>

<h3>Create Heat Map</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create heat maps.
</p>
<p>
 In this example, you create a heat map that shows the correlation between the daily returns of the banking securities. Follow these steps to create the heat map:
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change()</pre>
 </div>
 <li>
  Call the
  <code>
   corr
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">corr_matrix = daily_returns.corr()</pre>
 </div>
 <li>
  Call the
  <code>
   heatmap
  </code>
  method with the
  <code>
   corr_matrix
  </code>
  and the annotation argument enabled.
 </li>
 <div class="section-example-container">
  <pre class="python">plot = sns.heatmap(corr_matrix, annot=True)</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   heatmap
  </code>
  method, call the
  <code>
   set
  </code>
  method with a title.
 </li>
 <div class="section-example-container">
  <pre class="python">plot.set(title='Bank Stocks and Bank Sector ETF Correlation Coefficients');</pre>
 </div>
 <p>
  The Jupyter Notebook displays the heat map.
 </p>
 <img alt="Seaborn heat map" class="docs-image" src="https://cdn.quantconnect.com/i/tu/seaborn-heatmap-3.png"/>
</ol>

<h3>Create Pie Chart</h3>
<p>
 You must
 <a href="#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="#04-Get-Historical-Data">
  get some historical data
 </a>
 to create pie charts.
</p>
<p>
 In this example, you create a pie chart that shows the weights of the banking securities in a portfolio if you allocate to them based on their inverse volatility. Follow these steps to create the pie chart:
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_prices = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = close_prices.pct_change()</pre>
 </div>
 <li>
  Call
  <code>
   var
  </code>
  method and then take the inverse.
 </li>
 <div class="section-example-container">
  <pre class="python">inverse_variance = 1 / daily_returns.var()</pre>
 </div>
 <li>
  Call the
  <code>
   color_palette
  </code>
  method with a palette name and then truncate the returned colors to so that you have one color for each security.
 </li>
 <div class="section-example-container">
  <pre class="python">colors = sns.color_palette('pastel')[:len(inverse_variance.index)]</pre>
 </div>
 <li>
  Call the
  <code>
   pie
  </code>
  method with the security weights, labels, and colors.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.pie(inverse_variance, labels=inverse_variance.index, colors=colors, autopct='%1.1f%%')</pre>
 </div>
 <li>
  In the same cell that you called the
  <code>
   pie
  </code>
  method, call the
  <code>
   title
  </code>
  method with a title.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.title(title='Banking Stocks and Bank Sector ETF Allocation');</pre>
 </div>
 <p>
  The Jupyter Notebook displays the pie chart.
 </p>
 <img alt="Seaborn pie chart" class="docs-image" src="https://cdn.quantconnect.com/i/tu/seaborn-pie-3.png"/>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="4.5"><h3>4.5 Plotly NET</h3></section>

<h3>Introduction</h3>
<p>
 <code>
  Plotly.NET
 </code>
 provides functions for generating and rendering plotly.js charts in
 <code>
  .NET
 </code>
 programming languages. Our .NET interactive notebooks support its C# implementation.
</p>

<h3>Import Libraries</h3>
<p>
 Follow these steps to import the libraries that you need:
</p>
<ol>
 <li>
  Load the necessary assembly files.
 </li>
 <div class="section-example-container">
  <pre class="csharp">#r "../Plotly.NET.dll"</pre>
 </div>
 <li>
  Import the
  <code>
   Plotly.NET
  </code>
  and
  <code>
   Plotly.NET.LayoutObjects
  </code>
  packages.
 </li>
 <div class="section-example-container">
  <pre class="csharp">using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
</ol>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to produce the plots. For example, to get data for a bank sector ETF and some banking companies over 2021, run:
</p>
<div class="section-example-container">
 <pre class="csharp">var qb = new QuantBook();
var tickers = new[] 
{
    "XLF",  // Financial Select Sector SPDR Fund
    "COF",  // Capital One Financial Corporation
    "GS",   // Goldman Sachs Group, Inc.
    "JPM",  // J P Morgan Chase &amp; Co
    "WFC"   // Wells Fargo &amp; Company   
}
var symbols = tickers.Select(ticker =&gt; qb.AddEquity(ticker, Resolution.Daily).Symbol);
var history = qb.History(symbols, new DateTime(2021, 1, 1), new DateTime(2022, 1, 1));</pre>
</div>

<h3>Create Candlestick Chart</h3>
<p>
 You must
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting/plotly-net#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting/plotly-net#04-Get-Historical-Data">
  get some historical data
 </a>
 to create candlestick charts.
</p>
<p>
 In this example, you create a candlestick chart that shows the open, high, low, and close prices of one of the banking securities. Follow these steps to create the candlestick chart:
</p>
<ol>
 <li>
  Select a
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var symbol = symbols.First();</pre>
 </div>
 <li>
  Call the
  <code>
   Chart2D.Chart.Candlestick
  </code>
  constructor with the time and open, high, low, and close price
  <code>
   IEnumerable
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var bars = history.Select(slice =&gt; slice.Bars[symbol]);
var chart = Chart2D.Chart.Candlestick&lt;decimal, decimal, decimal, decimal, DateTime, string&gt;(
    bars.Select(x =&gt; x.Open),
    bars.Select(x =&gt; x.High),
    bars.Select(x =&gt; x.Low),
    bars.Select(x =&gt; x.Close),
    bars.Select(x =&gt; x.EndTime)
);</pre>
 </div>
 <li>
  Call the
  <code>
   Layout
  </code>
  constructor and set the
  <code>
   title
  </code>
  ,
  <code>
   xaxis
  </code>
  , and
  <code>
   yaxis
  </code>
  properties as the title and axes label objects.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Price ($)");
Title title = Title.init($"{symbol} OHLC");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li>
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="csharp">chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="csharp">HTML(GenericChart.toChartHTML(chart));</pre>
 </div>
 <p>
  The Jupyter Notebook displays the candlestick chart.
 </p>
</ol>
<img alt="Candlestick plot of XLF OHLC" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plotly-net-candlestick-plot.png"/>

<h3>Create Line Chart</h3>
<p>
 You must
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting/plotly-net#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting/plotly-net#04-Get-Historical-Data">
  get some historical data
 </a>
 to create line charts.
</p>
<p>
 In this example, you create a line chart that shows the volume of a security. Follow these steps to create the chart:
</p>
<ol>
 <li>
  Select a
  <code>
   Symbol
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var symbol = symbols.First();</pre>
 </div>
 <li>
  Call the
  <code>
   Chart2D.Chart.Line
  </code>
  constructor with the timestamps and volumes.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var bars = history.Select(slice =&gt; slice.Bars[symbol]);
var chart = Chart2D.Chart.Line&lt;DateTime, decimal, string&gt;(
    bars.Select(x =&gt; x.EndTime),
    bars.Select(x =&gt; x.Volume)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "Volume");
Title title = Title.init($"{symbol} Volume");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li>
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="csharp">chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="csharp section-example-container">
  <pre>HTML(GenericChart.toChartHTML(chart));</pre>
 </div>
 <p>
  The Jupyter Notebook displays the line chart.
 </p>
</ol>
<img class="docs-image" rel="Line chart of volume for XLF" src="https://cdn.quantconnect.com/i/tu/plotly-net-line-plot.png"/>

<h3>Create Scatter Plot</h3>
<p>
 You must
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting/plotly-net#03-Import-Libraries">
  import the plotting libraries
 </a>
 and
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/charting/plotly-net#04-Get-Historical-Data">
  get some historical data
 </a>
 to create scatter plots.
</p>
<p>
 In this example, you create a scatter plot that shows the relationship between the daily price of two securities. Follow these steps to create the scatter plot:
</p>
<ol>
 <li>
  Select two
  <code>
   Symbol
  </code>
  objects.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var symbol1 = symbols.First();
var symbol2 = symbols.Last();</pre>
 </div>
 <li>
  Call the
  <code>
   Chart2D.Chart.Point
  </code>
  constructor with the closing prices of both securities.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var chart = Chart2D.Chart.Point&lt;decimal, decimal, string&gt;(
    history.Select(slice =&gt; slice.Bars[symbol1].Close),
    history.Select(slice =&gt; slice.Bars[symbol2].Close)
);</pre>
 </div>
 <li>
  Create a
  <code>
   Layout
  </code>
  .
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="csharp">LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", $"{symbol1} Price ($)");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", $"{symbol2} Price ($)");
Title title = Title.init($"{symbol1} vs {symbol2}");

Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);</pre>
 </div>
 <li>
  Assign the
  <code>
   Layout
  </code>
  to the chart.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="csharp">chart.WithLayout(layout);</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="csharp section-example-container">
  <pre>HTML(GenericChart.toChartHTML(chart));</pre>
 </div>
 <p>
  The Jupyter Notebook displays the scatter plot.
 </p>
 <img alt="Plotly.NET scatter plot" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plotly-net-scatter-plot.png"/>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="5"><h3>5 Indicators</h3></section>

<div class="sub-heading-landing">
 <div class="internal-content">
  <p>
   Indicators let you analyze market data in an abstract form rather than in its raw form. For example, indicators like the RSI tell you, based on price and volume data, if the market is overbought or oversold. Because indicators can extract overall market trends from price data, sometimes, you may want to look for correlations between indicators and the market, instead of between raw price data and the market. To view all of the indicators and candlestick patterns we provide, see the
   <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/indicators/supported-indicators">
    Supported Indicators
   </a>
   .
  </p>
 </div>
 <div class="docs-landing-links">
  <div class="col-md-6 col-sm-12 docs-landing-link-wrap">
   <div class="content clickable" onclick="window.location.href = '/docs/v2/research-environment/indicators/data-point-indicators'">
    <div class="docs-internal-link">
     <h4>
      Data Point Indicators
     </h4>
    </div>
    Indicators that process
    <code>
     IndicatorDataPoint
    </code>
    objects
   </div>
  </div>
  <div class="col-md-6 col-sm-12 docs-landing-link-wrap">
   <div class="content clickable" onclick="window.location.href = '/docs/v2/research-environment/indicators/bar-indicators'">
    <div class="docs-internal-link">
     <h4>
      Bar Indicators
     </h4>
    </div>
    Indicators that process
    <code>
     Bar
    </code>
    objects
   </div>
  </div>
  <div class="col-md-6 col-sm-12 docs-landing-link-wrap">
   <div class="content clickable" onclick="window.location.href = '/docs/v2/research-environment/indicators/trade-bar-indicators'">
    <div class="docs-internal-link">
     <h4>
      Trade Bar Indicators
     </h4>
    </div>
    Indicators that process
    <code>
     TradeBar
    </code>
    objects
   </div>
  </div>
  <div class="col-md-6 col-sm-12 docs-landing-link-wrap">
   <div class="content clickable" onclick="window.location.href = '/docs/v2/research-environment/indicators/combining-indicators'">
    <div class="docs-internal-link">
     <h4>
      Combining Indicators
     </h4>
    </div>
    Chain indicators together
   </div>
  </div>
  <div class="col-md-6 col-sm-12 docs-landing-link-wrap">
   <div class="content clickable" onclick="window.location.href = '/docs/v2/research-environment/indicators/custom-indicators'">
    <div class="docs-internal-link">
     <h4>
      Custom Indicators
     </h4>
    </div>
    Create your own
   </div>
  </div>
  <div class="col-md-6 col-sm-12 docs-landing-link-wrap">
   <div class="content clickable" onclick="window.location.href = '/docs/v2/research-environment/indicators/custom-resolutions'">
    <div class="docs-internal-link">
     <h4>
      Custom Resolutions
     </h4>
    </div>
    Beyond the standard resolutions
   </div>
  </div>
 </div>
 <div class="see-also">
  <h3>
   See Also
  </h3>
  <a href="/docs/v2/writing-algorithms/indicators/key-concepts">
   Key Concepts
  </a>
  <br/>
 </div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="5.1"><h3>5.1 Data Point Indicators</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to create, update, and visualize LEAN data-point indicators.
</p>

<h3>Create Subscriptions</h3>
<p>
 You need to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#03-Create-Subscriptions">
  subscribe to some market data
 </a>
 in order to calculate indicator values.
</p>
<div class="section-example-container">
 <pre class="csharp">var qb = new QuantBook();
var symbol = qb.AddEquity("SPY").Symbol;</pre>
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY").Symbol</pre>
</div>

<h3>Create Indicator Timeseries</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/indicators/data-point-indicators#03-Create-Subscriptions">
  subscribe to some market data
 </a>
 and create an indicator in order to calculate a timeseries of indicator values. In this example, use a 20-period 2-standard-deviation
 <code>
  BollingerBands
 </code>
 indicator.
</p>
<div class="section-example-container">
 <pre class="csharp">var bb = new BollingerBands(20, 2);</pre>
 <pre class="python">bb = BollingerBands(20, 2)</pre>
</div>
<p>
 You can create the indicator timeseries with the
 <code>
  Indicator
 </code>
 helper method or you can manually create the timeseries.
</p>
<h4>
 Indicator Helper Method
</h4>
<p>
 To create an indicator timeseries with the helper method, call the
 <code>
  Indicator
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">var bbIndicator = qb.Indicator(bb, symbol, 50, Resolution.Daily);</pre>
 <pre class="python">bb_dataframe = qb.Indicator(bb, symbol, 50, Resolution.Daily)</pre>
</div>
<img alt="Historical bollinger band data" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-datapoint-py-helper-bb.png"/>
<h4>
 Manually Create the Indicator Timeseries
</h4>
<p>
 Follow these steps to manually create the indicator timeseries:
</p>
<ol>
 <li>
  Get some
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/key-concepts">
   historical data
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var history = qb.History(symbol, 70, Resolution.Daily);</pre>
  <pre class="python">history = qb.History[TradeBar](symbol, 70, Resolution.Daily)</pre>
 </div>
 <li>
  Create a
  <code>
   RollingWindow
  </code>
  for each attribute of the indicator to hold their values.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var time = new RollingWindow&lt;DateTime&gt;(50);
var window = new Dictionary&lt;string, RollingWindow&lt;decimal&gt;&gt;();
window["bollingerbands"] = new RollingWindow&lt;decimal&gt;(50);
window["lowerband"] = new RollingWindow&lt;decimal&gt;(50);
window["middleband"] = new RollingWindow&lt;decimal&gt;(50);
window["upperband"] = new RollingWindow&lt;decimal&gt;(50);
window["bandwidth"] = new RollingWindow&lt;decimal&gt;(50);
window["percentb"] = new RollingWindow&lt;decimal&gt;(50);
window["standarddeviation"] = new RollingWindow&lt;decimal&gt;(50);
window["price"] = new RollingWindow&lt;decimal&gt;(50);
</pre>
  <pre class="python">window = {}
window['time'] = RollingWindow[DateTime](50)
window["bollingerbands"] = RollingWindow[float](50)
window["lowerband"] = RollingWindow[float](50)
window["middleband"] = RollingWindow[float](50)
window["upperband"] = RollingWindow[float](50)
window["bandwidth"] = RollingWindow[float](50)
window["percentb"] = RollingWindow[float](50)
window["standarddeviation"] = RollingWindow[float](50)
window["price"] = RollingWindow[float](50)
</pre>
 </div>
 <li>
  Attach a handler method to the indicator that updates the
  <code>
   RollingWindow
  </code>
  objects.
 </li>
 <div class="section-example-container">
  <pre class="csharp">bb.Updated += (sender, updated) =&gt; 
{
    var indicator = (BollingerBands)sender;
    time.Add(updated.EndTime);
    window["bollingerbands"].Add(updated);
    window["lowerband"].Add(indicator.LowerBand);
    window["middleband"].Add(indicator.MiddleBand);
    window["upperband"].Add(indicator.UpperBand);
    window["bandwidth"].Add(indicator.BandWidth);
    window["percentb"].Add(indicator.PercentB);
    window["standarddeviation"].Add(indicator.StandardDeviation);
    window["price"].Add(indicator.Price);
};</pre>
  <pre class="python">def UpdateBollingerBandWindow(sender: object, updated: IndicatorDataPoint) -&gt; None:
    indicator = sender
    window['time'].Add(updated.EndTime)
    window["bollingerbands"].Add(updated.Value)
    window["lowerband"].Add(indicator.LowerBand.Current.Value)
    window["middleband"].Add(indicator.MiddleBand.Current.Value)
    window["upperband"].Add(indicator.UpperBand.Current.Value)
    window["bandwidth"].Add(indicator.BandWidth.Current.Value)
    window["percentb"].Add(indicator.PercentB.Current.Value)
    window["standarddeviation"].Add(indicator.StandardDeviation.Current.Value)
    window["price"].Add(indicator.Price.Current.Value)

bb.Updated += UpdateBollingerBandWindow</pre>
 </div>
 <p>
  When the indicator receives new data, the preceding handler method adds the new
  <code>
   IndicatorDataPoint
  </code>
  values into the respective
  <code>
   RollingWindow
  </code>
  .
 </p>
 <li>
  Iterate through the historical market data and update the indicator.
 </li>
 <div class="section-example-container">
  <pre class="csharp">foreach(var bar in history)
{
    bb.Update(bar.EndTime, bar.Close);
}</pre>
  <pre class="python">for bar in history:
    bb.Update(bar.EndTime, bar.Close)</pre>
 </div>
 <li class="csharp">
  Display the data.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">Console.WriteLine($"time,{string.Join(',', window.Select(kvp =&gt; kvp.Key))}");
foreach (var i in Enumerable.Range(0, 5).Reverse())
{
    var data = string.Join(", ", window.Select(kvp =&gt; Math.Round(kvp.Value[i],6)));
    Console.WriteLine($"{time[i]:yyyyMMdd}, {data}");
}</pre>
 </div>
 <img alt="Historical bollinger band data" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-datapoint-cs-classic-bb.png"/>
 <li class="python">
  Populate a
  <code>
   DataFrame
  </code>
  with the data in the
  <code>
   RollingWindow
  </code>
  objects.
 </li>
 <div class="python section-example-container">
  <pre class="python">bb_dataframe = pd.DataFrame(window).set_index('time')</pre>
 </div>
 <img alt="Historical bollinger band data" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-datapoint-py-classic-bb.png"/>
</ol>

<h3>Plot Indicators</h3>
<p class="csharp">
 Jupyter Notebooks don't currently support libraries to plot historical data, but we are working on adding the functionality. Until the functionality is added, use Python to plot data point indicators.
</p>
<p class="python">
 You need to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/indicators/data-point-indicators#04-Create-Indicator-Timeseries">
  create an indicator timeseries
 </a>
 to plot the indicator values.
</p>
<p class="python">
 Follow these steps to plot the indicator values:
</p>
<ol class="python">
 <li>
  Select the columns/features to plot.
 </li>
 <div class="python section-example-container">
  <pre class="python">bb_plot = bb_indicator[["upperband", "middleband", "lowerband", "price"]]</pre>
 </div>
 <li>
  Call the
  <code>
   plot
  </code>
  method.
 </li>
 <div class="python section-example-container">
  <pre class="python">bb_plot.plot(figsize=(15, 10), title="SPY BB(20,2)"))</pre>
 </div>
 <li>
  Show the plots.
 </li>
 <div class="python section-example-container">
  <pre class="python">plt.show()</pre>
 </div>
 <img alt="Line plot of bollinger band properties" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-datapoint-py-plot.png"/>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="5.2"><h3>5.2 Bar Indicators</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to create, update, and visualize LEAN bar indicators.
</p>

<h3>Create Subscriptions</h3>
<p>
 You need to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#03-Create-Subscriptions">
  subscribe to some market data
 </a>
 in order to calculate indicator values.
</p>
<div class="section-example-container">
 <pre class="csharp">var qb = new QuantBook();
var symbol = qb.AddEquity("SPY").Symbol;</pre>
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY").Symbol</pre>
</div>

<h3>Create Indicator Timeseries</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/indicators/bar-indicators#03-Create-Subscriptions">
  subscribe to some market data
 </a>
 and create an indicator in order to calculate a timeseries of indicator values. In this example, use a 20-period
 <code>
  AverageTrueRange
 </code>
 indicator.
</p>
<div class="section-example-container">
 <pre class="csharp">var atr = new AverageTrueRange(20);</pre>
 <pre class="python">atr = AverageTrueRange(20)</pre>
</div>
<p>
 You can create the indicator timeseries with the
 <code>
  Indicator
 </code>
 helper method or you can manually create the timeseries.
</p>
<h4>
 Indicator Helper Method
</h4>
<p>
 To create an indicator timeseries with the helper method, call the
 <code>
  Indicator
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">var atrIndicator = qb.Indicator(atr, symbol, 50, Resolution.Daily);</pre>
 <pre class="python">atr_dataframe = qb.Indicator(atr, symbol, 50, Resolution.Daily)</pre>
</div>
<img alt="Historical average true range data" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-bar-py-helper-atr.png"/>
<h4>
 Manually Create the Indicator Timeseries
</h4>
<p>
 Follow these steps to manually create the indicator timeseries:
</p>
<ol>
 <li>
  Get some
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/key-concepts">
   historical data
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var history = qb.History(symbol, 70, Resolution.Daily);</pre>
  <pre class="python">history = qb.History[TradeBar](symbol, 70, Resolution.Daily)</pre>
 </div>
 <li>
  Create a
  <code>
   RollingWindow
  </code>
  for each attribute of the indicator to hold their values.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var time = new RollingWindow&lt;DateTime&gt;(50);
var window = new Dictionary&lt;string, RollingWindow&lt;decimal&gt;&gt;();
window["averagetruerange"] = new RollingWindow&lt;decimal&gt;(50);
window["truerange"] = new RollingWindow&lt;decimal&gt;(50);
</pre>
  <pre class="python">window = {}
window['time'] = RollingWindow[DateTime](50)
window['averagetruerange'] = RollingWindow[float](50)
window["truerange"] = RollingWindow[float](50)
</pre>
 </div>
 <li>
  Attach a handler method to the indicator that updates the
  <code>
   RollingWindow
  </code>
  objects.
 </li>
 <div class="section-example-container">
  <pre class="csharp">atr.Updated += (sender, updated) =&gt; 
{
    var indicator = (AverageTrueRange)sender;
    time.Add(updated.EndTime);
    window["averagetruerange"].Add(updated);
    window["truerange"].Add(indicator.TrueRange);
};</pre>
  <pre class="python">def UpdateAverageTrueRangeWindow(sender: object, updated: IndicatorDataPoint) -&gt; None:
    indicator = sender
    window['time'].Add(updated.EndTime)
    window["averagetruerange"].Add(updated.Value)
    window["truerange"].Add(indicator.TrueRange.Current.Value)

atr.Updated += UpdateAverageTrueRangeWindow</pre>
 </div>
 <p>
  When the indicator receives new data, the preceding handler method adds the new
  <code>
   IndicatorDataPoint
  </code>
  values into the respective
  <code>
   RollingWindow
  </code>
  .
 </p>
 <li>
  Iterate through the historical market data and update the indicator.
 </li>
 <div class="section-example-container">
  <pre class="csharp">foreach(var bar in history){
    // Update the indicators with the whole bar.
    atr.Update(bar);
}</pre>
  <pre class="python">for bar in history:
    atr.Update(bar)</pre>
 </div>
 <li class="csharp">
  Display the data.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">Console.WriteLine($"time,{string.Join(',', window.Select(kvp =&gt; kvp.Key))}");
foreach (var i in Enumerable.Range(0, 5).Reverse())
{
    var data = string.Join(", ", window.Select(kvp =&gt; Math.Round(kvp.Value[i],6)));
    Console.WriteLine($"{time[i]:yyyyMMdd}, {data}");
}</pre>
 </div>
 <img alt="Historical average true range data" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-bar-cs-classic-atr.png"/>
 <li class="python">
  Populate a
  <code>
   DataFrame
  </code>
  with the data in the
  <code>
   RollingWindow
  </code>
  objects.
 </li>
 <div class="python section-example-container">
  <pre class="python">atr_dataframe = pd.DataFrame(window).set_index('time')</pre>
 </div>
 <img alt="Historical average true range data" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-bar-py-classic-atr.png"/>
</ol>

<h3>Plot Indicators</h3>
<p class="csharp">
 Jupyter Notebooks don't currently support libraries to plot historical data, but we are working on adding the functionality. Until the functionality is added, use Python to plot bar indicators.
</p>
<p class="python">
 You need to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/indicators/bar-indicators#04-Create-Indicator-Timeseries">
  create an indicator timeseries
 </a>
 to plot the indicator values.
</p>
<p class="python">
 Follow these steps to plot the indicator values:
</p>
<ol class="python">
 <li>
  Call the
  <code>
   plot
  </code>
  method.
 </li>
 <div class="python section-example-container">
  <pre class="python">atr_indicator.plot(title="SPY ATR(20)", figsize=(15, 10))</pre>
 </div>
 <li>
  Show the plots.
 </li>
 <div class="python section-example-container">
  <pre class="python">plt.show()</pre>
 </div>
 <img alt="Line plot of average true range properties" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-bar-py-plot.png"/>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="5.3"><h3>5.3 Trade Bar Indicators</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to create, update, and visualize LEAN
 <code>
  TradeBar
 </code>
 indicators.
</p>

<h3>Create Subscriptions</h3>
<p>
 You need to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#03-Create-Subscriptions">
  subscribe to some market data
 </a>
 in order to calculate indicator values.
</p>
<div class="section-example-container">
 <pre class="csharp">var qb = new QuantBook();
var symbol = qb.AddEquity("SPY").Symbol;</pre>
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY").Symbol</pre>
</div>

<h3>Create Indicator Timeseries</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/indicators/trade-bar-indicators#03-Create-Subscriptions">
  subscribe to some market data
 </a>
 and create an indicator in order to calculate a timeseries of indicator values. In this example, use a 20-period
 <code>
  VolumeWeightedAveragePriceIndicator
 </code>
 indicator.
</p>
<div class="section-example-container">
 <pre class="csharp">var vwap = new VolumeWeightedAveragePriceIndicator(20);</pre>
 <pre class="python">vwap = VolumeWeightedAveragePriceIndicator(20)</pre>
</div>
<p>
 You can create the indicator timeseries with the
 <code>
  Indicator
 </code>
 helper method or you can manually create the timeseries.
</p>
<h4>
 Indicator Helper Method
</h4>
<p>
 To create an indicator timeseries with the helper method, call the
 <code>
  Indicator
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">var vwapIndicator = qb.Indicator(vwap, symbol, 50, Resolution.Daily);</pre>
 <pre class="python">vwap_dataframe = qb.Indicator(vwap, symbol, 50, Resolution.Daily)</pre>
</div>
<img alt="Historical VWAP data" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-tradebar-py-helper-vwap.png"/>
<h4>
 Manually Create the Indicator Timeseries
</h4>
<p>
 Follow these steps to create an indicator timeseries:
</p>
<ol>
 <li>
  Get some
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/key-concepts">
   historical data
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var history = qb.History(symbol, 70, Resolution.Daily);</pre>
  <pre class="python">history = qb.History[TradeBar](symbol, 70, Resolution.Daily)</pre>
 </div>
 <li>
  Create a
  <code>
   RollingWindow
  </code>
  for each attribute of the indicator to hold their values.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var time = new RollingWindow&lt;DateTime&gt;(50);
var window = new Dictionary&lt;string, RollingWindow&lt;decimal&gt;&gt;();
window["volumeweightedaveragepriceindicator"] = new RollingWindow&lt;decimal&gt;(50);
</pre>
  <pre class="python">window = {}
window['time'] = RollingWindow[DateTime](50)
window['volumeweightedaveragepriceindicator'] = RollingWindow[float](50)
</pre>
 </div>
 <li>
  Attach a handler method to the indicator that updates the
  <code>
   RollingWindow
  </code>
  objects.
 </li>
 <div class="section-example-container">
  <pre class="csharp">vwap.Updated += (sender, updated) =&gt; 
{
    time.Add(updated.EndTime);
    window["volumeweightedaveragepriceindicator"].Add(updated);
};</pre>
  <pre class="python">def UpdateVWAPWindow(sender: object, updated: IndicatorDataPoint) -&gt; None:
    window['time'].Add(updated.EndTime)
    window["volumeweightedaveragepriceindicator"].Add(updated.Value)

vwap.Updated += UpdateVWAPWindow</pre>
 </div>
 <p>
  When the indicator receives new data, the preceding handler method adds the new
  <code>
   IndicatorDataPoint
  </code>
  values into the respective
  <code>
   RollingWindow
  </code>
  .
 </p>
 <li>
  Iterate through the historical market data and update the indicator.
 </li>
 <div class="section-example-container">
  <pre class="csharp">foreach(var bar in history){
    // Update the indicators with the whole TradeBar.
    vwap.Update(bar);
}</pre>
  <pre class="python">for bar in history:
    vwap.Update(bar)</pre>
 </div>
 <li class="csharp">
  Display the data.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">Console.WriteLine($"time,{string.Join(',', window.Select(kvp =&gt; kvp.Key))}");
foreach (var i in Enumerable.Range(0, 5).Reverse())
{
    var data = string.Join(", ", window.Select(kvp =&gt; Math.Round(kvp.Value[i],6)));
    Console.WriteLine($"{time[i]:yyyyMMdd}, {data}");
}</pre>
 </div>
 <img alt="Historical VWAP data" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-tradebar-cs-classic-vwap.png"/>
 <li class="python">
  Populate a
  <code>
   DataFrame
  </code>
  with the data in the
  <code>
   RollingWindow
  </code>
  objects.
 </li>
 <div class="python section-example-container">
  <pre class="python">vwap_dataframe = pd.DataFrame(window).set_index('time')</pre>
 </div>
 <img alt="Historical VWAP data" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-tradebar-py-classic-vwap.png"/>
</ol>

<h3>Plot Indicators</h3>
<p class="csharp">
 Jupyter Notebooks don't currently support libraries to plot historical data, but we are working on adding the functionality. Until the functionality is added, use Python to plot TradeBar indicators.
</p>
<p class="python">
 Follow these steps to plot the indicator values:
</p>
<ol class="python">
 <li>
  Call the
  <code>
   plot
  </code>
  method.
 </li>
 <div class="python section-example-container">
  <pre class="python">vwap_indicator.plot(title="SPY VWAP(20)", figsize=(15, 10))</pre>
 </div>
 <li>
  Show the plots.
 </li>
 <div class="python section-example-container">
  <pre class="python">plt.show()</pre>
 </div>
 <img alt="Line plot of VWAP" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-tradebar-py-plot.png"/>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="5.4"><h3>5.4 Combining Indicators</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to create, update, and visualize LEAN Composite indicators.
</p>

<h3>Create Subscriptions</h3>
<p>
 You need to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#03-Create-Subscriptions">
  subscribe to some market data
 </a>
 in order to calculate indicator values.
</p>
<div class="section-example-container">
 <pre class="csharp">var qb = new QuantBook();
var symbol = qb.AddEquity("SPY").Symbol;</pre>
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY").Symbol</pre>
</div>

<h3>Create Indicator Timeseries</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/indicators/combining-indicators#03-Create-Subscriptions">
  subscribe to some market data
 </a>
 and create a composite indicator in order to calculate a timeseries of indicator values. In this example, use a 10-period
 <code>
  SimpleMovingAverage
 </code>
 of a 10-period
 <code>
  RelativeStrengthIndex
 </code>
 indicator.
</p>
<div class="section-example-container">
 <pre class="csharp">var rsi = new RelativeStrengthIndex(10);
var sma = new SimpleMovingAverage(10);
var smaOfRsi = IndicatorExtensions.Of(sma, rsi);</pre>
 <pre class="python">rsi = RelativeStrengthIndex(10)
sma = SimpleMovingAverage(10)
sma_of_rsi = IndicatorExtensions.Of(sma, rsi)</pre>
</div>
<p>
 Follow these steps to create an indicator timeseries:
</p>
<ol>
 <li>
  Get some
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/key-concepts">
   historical data
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var history = qb.History(symbol, 70, Resolution.Daily);</pre>
  <pre class="python">history = qb.History[TradeBar](symbol, 70, Resolution.Daily)</pre>
 </div>
 <li>
  Create a
  <code>
   RollingWindow
  </code>
  for each attribute of the indicator to hold their values.
 </li>
 <p>
  In this example, save 50 data points.
 </p>
 <div class="section-example-container">
  <pre class="csharp">var time = new RollingWindow&lt;DateTime&gt;(50);
var window = new Dictionary&lt;string, RollingWindow&lt;decimal&gt;&gt;();
window["SMA Of RSI"] = new RollingWindow&lt;decimal&gt;(50);
window["rollingsum"] = new RollingWindow&lt;decimal&gt;(50);
</pre>
  <pre class="python">window = {}
window['time'] = RollingWindow[DateTime](50)
window["SMA Of RSI"] = RollingWindow[float](50)
window["rollingsum"] = RollingWindow[float](50)(50)
</pre>
 </div>
 <li>
  Attach a handler method to the indicator that updates the
  <code>
   RollingWindow
  </code>
  objects.
 </li>
 <div class="section-example-container">
  <pre class="csharp">smaOfRsi.Updated += (sender, updated) =&gt; 
{
    var indicator = (SimpleMovingAverage)sender;    // Use terminal indicator class.
    time.Add(updated.EndTime);
    window["SMA Of RSI"].Add(updated);
    window["rollingsum"].Add(indicator.RollingSum);
};</pre>
  <pre class="python">def UpdateSmaOfRsiWindow(sender: object, updated: IndicatorDataPoint) -&gt; None:
    indicator = sender
    window['time'].Add(updated.EndTime)
    window["SMA Of RSI"].Add(updated.Value)
    window["rollingsum"].Add(indicator.RollingSum.Current.Value)

sma_of_rsi.Updated += UpdateSmaOfRsiWindow</pre>
 </div>
 <p>
  When the indicator receives new data, the preceding handler method adds the new
  <code>
   IndicatorDataPoint
  </code>
  values into the respective
  <code>
   RollingWindow
  </code>
  .
 </p>
 <li>
  Iterate the
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/key-concepts#03-Request-Data">
   historical market data
  </a>
  to update the indicators and the
  <code>
   RollingWindow
  </code>
  s.
 </li>
 <div class="section-example-container">
  <pre class="csharp">foreach(var bar in history){
    // Update the base indicators, the composite indicator will update automatically when the base indicator is updated.
    rsi.Update(bar.EndTime, bar.Close);
}</pre>
  <pre class="python">for bar in history:
    rsi.Update(bar.EndTime, bar.Close)</pre>
 </div>
 <li class="csharp">
  Display the data.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">Console.WriteLine($"time,{string.Join(',', window.Select(kvp =&gt; kvp.Key))}");
foreach (var i in Enumerable.Range(0, 5).Reverse())
{
    var data = string.Join(", ", window.Select(kvp =&gt; Math.Round(kvp.Value[i],6)));
    Console.WriteLine($"{time[i]:yyyyMMdd}, {data}");
}</pre>
 </div>
 <img alt="Historical data of 10-day SMA of 10-day RSI" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-composite-cs-classic-smaofrsi.png"/>
 <li class="python">
  Populate a
  <code>
   DataFrame
  </code>
  with the data in the
  <code>
   RollingWindow
  </code>
  objects.
 </li>
 <div class="python section-example-container">
  <pre class="python">sma_of_rsi_dataframe = pd.DataFrame(window).set_index('time')</pre>
 </div>
 <img alt="Historical data of 10-day SMA of 10-day RSI" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-composite-py-classic-smaofrsi.png"/>
</ol>

<h3>Plot Indicators</h3>
<p class="csharp">
 Jupyter Notebooks don't currently support libraries to plot historical data, but we are working on adding the functionality. Until the functionality is added, use Python to plot composite indicators.
</p>
<p class="python">
 Follow these steps to plot the indicator values:
</p>
<ol class="python">
 <li>
  Select the columns/features to plot.
 </li>
 <div class="python section-example-container">
  <pre class="python">sma_of_rsi_plot = sma_of_rsi_dataframe[["SMA Of RSI"]]</pre>
 </div>
 <li>
  Call the
  <code>
   plot
  </code>
  method.
 </li>
 <div class="python section-example-container">
  <pre class="python">sma_of_rsi_plot.plot(title="SPY SMA(10) of RSI(10)", figsize=(15, 10))</pre>
 </div>
 <li>
  Show the plots.
 </li>
 <div class="python section-example-container">
  <pre class="python">plt.show()</pre>
 </div>
 <img alt="Line plot of 10-day SMA of 10-day RSI" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-composite-py-plot.png"/>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="5.5"><h3>5.5 Custom Indicators</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to create and update custom indicators.
</p>

<h3>Create Subscriptions</h3>
<p>
 You need to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#03-Create-Subscriptions">
  subscribe to some market data
 </a>
 in order to calculate indicator values.
</p>
<div class="section-example-container">
 <pre class="csharp">var qb = new QuantBook();
var symbol = qb.AddEquity("SPY").Symbol;</pre>
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY").Symbol</pre>
</div>

<h3>Create Indicator Timeseries</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/indicators/custom-indicators#03-Create-Subscriptions">
  subscribe to some market data
 </a>
 in order to calculate a timeseries of indicator values.
</p>
<p>
 Follow these steps to create an indicator timeseries:
</p>
<ol>
 <li>
  Get some
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/key-concepts">
   historical data
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var history = qb.History(symbol, 70, Resolution.Daily);</pre>
  <pre class="python">history = qb.History[TradeBar](symbol, 70, Resolution.Daily)</pre>
 </div>
 <li class="csharp">
  Define a custom indicator class that inherits from the
  <code>
   Indicator
  </code>
  superclass.
 </li>
 <li class="python">
  Define a custom indicator class. Note the
  <code>
   PythonIndicator
  </code>
  superclass inheritance,
  <code>
   Value
  </code>
  attribute, and
  <code>
   Update
  </code>
  method are mandatory.
 </li>
 <p class="csharp">
  In this tutorial, create an
  <code>
   ExpectedShortfallPercent
  </code>
  indicator that uses Monte Carlo to calculate the expected shortfall of returns. Use the
  <code>
   WindowIndicator
  </code>
  superclass instead of
  <code>
   Indicator
  </code>
  for using a period of historical data stored in a
  <code>
   RollingWindow
  </code>
  .
 </p>
 <p class="python">
  In this tutorial, create an
  <code>
   ExpectedShortfallPercent
  </code>
  indicator that uses Monte Carlo to calculate the expected shortfall of returns.
 </p>
 <div class="section-example-container">
  <pre class="csharp">public class ExpectedShortfallPercent : WindowIndicator&lt;IndicatorDataPoint&gt;, IIndicatorWarmUpPeriodProvider
{
    private decimal _alpha;
    
    // Set up IndicatorDataPoint attributes for the indicator.
    public IndicatorBase&lt;IndicatorDataPoint&gt; ValueAtRisk { get; }

    // Set up the WarmUpPeriod attribute to provide implementation of the IIndicatorWarmUpPeriodProvider interface.
    public override int WarmUpPeriod =&gt; Period;

    // Set up the constructor.
    // period: The lookback period for return distribution.
    // alpha: Alpha level of VaR cutoff.
    public ExpectedShortfallPercent(int period, decimal alpha)
        : base("ES", period)
    {
        _alpha = alpha;
        ValueAtRisk = new Identity("ES_VaR");
    }

    // Override the IsReady method to set up the flag of the Indicator and its IndicatorDataPoint attributes are ready.
    public override bool IsReady =&gt; ValueAtRisk.IsReady;

    // Mandatory: Override the ComputeNextValue method to calculate the indictor value.
    protected override decimal ComputeNextValue(IReadOnlyWindow&lt;IndicatorDataPoint&gt; window, IndicatorDataPoint input)
    {
        if (Samples &lt; 2)
            return 0m;
                
        var n = Math.Min(Period, Samples);
        var cutoff = (int) Math.Ceiling(n * _alpha);
        
        var samples = new List&lt;decimal&gt;();
        for (int i = 0; i &lt; window.Count - 1; i++)
        {
            samples.Add( (window[i] - window[i+1]) / window[i+1] );
        }
        var lowest = samples.OrderBy(x =&gt; x).Take(cutoff);
        
        ValueAtRisk.Update(input.Time, lowest.Last());
        return lowest.Average();
    }
}</pre>
  <pre class="python">class ExpectedShortfallPercent(PythonIndicator):
    import math, numpy as np
    
    def __init__(self, period, alpha):
        self.Value = None   # Attribute represents the indicator value
        self.ValueAtRisk = None
        
        self.alpha = alpha
        
        self.window = RollingWindow[float](period)
    
    # Override the IsReady attribute to flag all attributes values are ready.
    @property
    def IsReady(self) -&gt; bool:
        return self.Value and self.ValueAtRisk
    
    # Method to update the indicator values. Note that it only receives 1 IBaseData object (Tick, TradeBar, QuoteBar) argument.
    def Update(self, input: BaseData) -&gt; bool:
        count = self.window.Count
        
        self.window.Add(input.Close)
        
        # Update the Value and other attributes as the indicator current value.
        if count &gt;= 2:
            cutoff = math.ceil(self.alpha * count)
            
            ret = [ (self.window[i] - self.window[i+1]) / self.window[i+1] for i in range(count-1) ]
            lowest = sorted(ret)[:cutoff]
            
            self.Value = np.mean(lowest)
            self.ValueAtRisk = lowest[-1]
            
        # return a boolean to indicate IsReady.
        return count &gt;= 2</pre>
 </div>
 <li>
  Initialize a new instance of the custom indicator.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var es = new ExpectedShortfallPercent(50, 0.05m);</pre>
  <pre class="python">custom = ExpectedShortfallPercent(50, 0.05)</pre>
 </div>
 <li>
  Create a
  <code>
   RollingWindow
  </code>
  for each attribute of the indicator to hold their values.
 </li>
 <p>
  In this example, save 20 data points.
 </p>
 <div class="section-example-container">
  <pre class="csharp">var time = new RollingWindow&lt;DateTime&gt;(20);
var window = new Dictionary&lt;string, RollingWindow&lt;decimal&gt;&gt;();
window["expectedshortfall"] = new RollingWindow&lt;decimal&gt;(20);
window["valueatrisk"] = new RollingWindow&lt;decimal&gt;(20);
</pre>
  <pre class="python">window = {}
window['time'] = RollingWindow[DateTime](20)
window['expectedshortfall'] = RollingWindow[float](20)
window['valueatrisk'] = RollingWindow[float](20)
</pre>
 </div>
 <li>
  Attach a handler method to the indicator that updates the
  <code>
   RollingWindow
  </code>
  objects.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">es.Updated += (sender, updated) =&gt;
{
    var indicator = (ExpectedShortfallPercent) sender;
    time.Add(updated.EndTime);
    window["expectedshortfall"].Add(updated);
    window["valueatrisk"].Add(indicator.ValueAtRisk.Current);
};</pre>
 </div>
 <p>
  When the indicator receives new data, the preceding handler method adds the new
  <code>
   IndicatorDataPoint
  </code>
  values into the respective
  <code>
   RollingWindow
  </code>
  .
 </p>
 <li>
  Iterate through the historical market data and update the indicator.
 </li>
 <div class="section-example-container">
  <pre class="csharp">foreach(var bar in history){
    es.Update(bar.EndTime, bar.Close);
}</pre>
  <pre class="python">for bar in history:
    custom.Update(bar)
    
    # The Updated event handler is not available for custom indicator in Python, RollingWindows are needed to be updated in here.
    if custom.IsReady:
        window['time'].Add(bar.EndTime)
        window['expectedshortfall'].Add(custom.Value)
        window['valueatrisk'].Add(custom.ValueAtRisk)</pre>
 </div>
 <li class="csharp">
  Display the data.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">Console.WriteLine($"time,{string.Join(',', window.Select(kvp =&gt; kvp.Key))}");
foreach (var i in Enumerable.Range(0, 5).Reverse())
{
    var data = string.Join(", ", window.Select(kvp =&gt; Math.Round(kvp.Value[i],6)));
    Console.WriteLine($"{time[i]:yyyyMMdd}, {data}");
}</pre>
 </div>
 <img alt="Historical expected shortfall and value at risk" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-custom-indicator-cs-classic.png"/>
 <li class="python">
  Populate a
  <code>
   DataFrame
  </code>
  with the data in the
  <code>
   RollingWindow
  </code>
  objects.
 </li>
 <div class="python section-example-container">
  <pre class="python">custom_dataframe = pd.DataFrame(window).set_index('time'))</pre>
 </div>
 <img alt="Historical expected shortfall and value at risk" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-custom-indicator-py-classic.png"/>
</ol>

<h3>Plot Indicators</h3>
<p class="csharp">
 Jupyter Notebooks don't currently support libraries to plot historical data, but we are working on adding the functionality. Until the functionality is added, use Python to plot custom indicators.
</p>
<p class="python">
 Follow these steps to plot the indicator values:
</p>
<ol class="python">
 <li>
  Call the
  <code>
   plot
  </code>
  method.
 </li>
 <div class="python section-example-container">
  <pre class="python">custom_dataframe.plot()</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="python section-example-container">
  <pre class="python">plt.show()</pre>
 </div>
 <img alt="Line plot of expected shortfall and value at risk" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/custom-indicators-plot.jpg"/>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="5.6"><h3>5.6 Custom Resolutions</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to create and update indicators with data of a custom resolution.
</p>

<h3>Create Subscriptions</h3>
<p>
 You need to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#03-Create-Subscriptions">
  subscribe to some market data
 </a>
 in order to calculate indicator values.
</p>
<div class="section-example-container">
 <pre class="csharp">var qb = new QuantBook();
var symbol = qb.AddEquity("SPY").Symbol;</pre>
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY").Symbol</pre>
</div>

<h3>Create Indicator Timeseries</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/indicators/custom-resolutions#03-Create-Subscriptions">
  subscribe to some market data
 </a>
 and create an indicator in order to calculate a timeseries of indicator values.
</p>
<p>
 Follow these steps to create an indicator timeseries:
</p>
<ol>
 <li>
  Get some
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/key-concepts">
   historical data
  </a>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var history = qb.History(symbol, 70, Resolution.Daily);</pre>
  <pre class="python">history = qb.History[TradeBar](symbol, 70, Resolution.Daily)</pre>
 </div>
 <li>
  Create a data-point indicator.
 </li>
 <p>
  In this example, use a 20-period 2-standard-deviation
  <code>
   BollingerBands
  </code>
  indicator.
 </p>
 <div class="section-example-container">
  <pre class="csharp">var bb = new BollingerBands(20, 2);</pre>
  <pre class="python">bb = BollingerBands(20, 2)</pre>
 </div>
 <li>
  Create a
  <code>
   RollingWindow
  </code>
  for each attribute of the indicator to hold their values.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var time = new RollingWindow&lt;DateTime&gt;(50);
var window = new Dictionary&lt;string, RollingWindow&lt;decimal&gt;&gt;();
window["bollingerbands"] = new RollingWindow&lt;decimal&gt;(50);
window["lowerband"] = new RollingWindow&lt;decimal&gt;(50);
window["middleband"] = new RollingWindow&lt;decimal&gt;(50);
window["upperband"] = new RollingWindow&lt;decimal&gt;(50);
window["bandwidth"] = new RollingWindow&lt;decimal&gt;(50);
window["percentb"] = new RollingWindow&lt;decimal&gt;(50);
window["standarddeviation"] = new RollingWindow&lt;decimal&gt;(50);
window["price"] = new RollingWindow&lt;decimal&gt;(50);
</pre>
  <pre class="python">window = {}
window['time'] = RollingWindow[DateTime](50)
window["bollingerbands"] = RollingWindow[float](50)
window["lowerband"] = RollingWindow[float](50)
window["middleband"] = RollingWindow[float](50)
window["upperband"] = RollingWindow[float](50)
window["bandwidth"] = RollingWindow[float](50)
window["percentb"] = RollingWindow[float](50)
window["standarddeviation"] = RollingWindow[float](50)
window["price"] = RollingWindow[float](50)
</pre>
 </div>
 <li>
  Attach a handler method to the indicator that updates the
  <code>
   RollingWindow
  </code>
  objects.
 </li>
 <div class="section-example-container">
  <pre class="csharp">bb.Updated += (sender, updated) =&gt; 
{
    var indicator = (BollingerBands)sender;
    time.Add(updated.EndTime);
    window["bollingerbands"].Add(updated);
    window["lowerband"].Add(indicator.LowerBand);
    window["middleband"].Add(indicator.MiddleBand);
    window["upperband"].Add(indicator.UpperBand);
    window["bandwidth"].Add(indicator.BandWidth);
    window["percentb"].Add(indicator.PercentB);
    window["standarddeviation"].Add(indicator.StandardDeviation);
    window["price"].Add(indicator.Price);
};</pre>
  <pre class="python">def UpdateBollingerBandWindow(sender: object, updated: IndicatorDataPoint) -&gt; None:
    indicator = sender
    window['time'].Add(updated.EndTime)
    window["bollingerbands"].Add(updated.Value)
    window["lowerband"].Add(indicator.LowerBand.Current.Value)
    window["middleband"].Add(indicator.MiddleBand.Current.Value)
    window["upperband"].Add(indicator.UpperBand.Current.Value)
    window["bandwidth"].Add(indicator.BandWidth.Current.Value)
    window["percentb"].Add(indicator.PercentB.Current.Value)
    window["standarddeviation"].Add(indicator.StandardDeviation.Current.Value)
    window["price"].Add(indicator.Price.Current.Value)

bb.Updated += UpdateBollingerBandWindow</pre>
 </div>
 <p>
  When the indicator receives new data, the preceding handler method adds the new
  <code>
   IndicatorDataPoint
  </code>
  values into the respective
  <code>
   RollingWindow
  </code>
  .
 </p>
 <li>
  Create a
  <code>
   TradeBarConsolidator
  </code>
  to
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/consolidating-data/getting-started">
   consolidate data
  </a>
  into the custom resolution.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var consolidator = new TradeBarConsolidator(TimeSpan.FromDays(7));</pre>
  <pre class="python">consolidator = TradeBarConsolidator(timedelta(days=7))</pre>
 </div>
 <li>
  Attach a handler method to feed data into the consolidator and updates the indicator with the consolidated bars.
 </li>
 <div class="section-example-container">
  <pre class="csharp">consolidator.DataConsolidated += (sender, consolidated) =&gt;
{
    bb.Update(consolidated.EndTime, consolidated.Close);
};</pre>
  <pre class="python">consolidator.DataConsolidated += lambda sender, consolidated: bb.Update(consolidated.EndTime, consolidated.Close)</pre>
 </div>
 <p>
  When the consolidator receives 7 days of data, the handler generates a 7-day
  <code>
   TradeBar
  </code>
  and update the indicator.
 </p>
 <li>
  Iterate through the historical market data and update the indicator.
 </li>
 <div class="section-example-container">
  <pre class="csharp">foreach(var bar in history)
{
    consolidator.Update(bar);
}</pre>
  <pre class="python">for bar in history:
    consolidator.Update(bar)</pre>
 </div>
 <li class="csharp">
  Display the data.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">Console.WriteLine($"time,{string.Join(',', window.Select(kvp =&gt; kvp.Key))}");
foreach (var i in Enumerable.Range(0, 5).Reverse())
{
    var data = string.Join(", ", window.Select(kvp =&gt; Math.Round(kvp.Value[i],6)));
    Console.WriteLine($"{time[i]:yyyyMMdd}, {data}");
}</pre>
 </div>
 <img alt="Historical custom bollinger band data" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-custom-resolution-cs-classic-bb.png"/>
 <li class="python">
  Populate a
  <code>
   DataFrame
  </code>
  with the data in the
  <code>
   RollingWindow
  </code>
  objects.
 </li>
 <div class="python section-example-container">
  <pre class="python">bb_dataframe = pd.DataFrame(window).set_index('time')</pre>
 </div>
 <img alt="Historical custom bollinger band data" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/indicator-custom-resolution-py-classic-bb.png"/>
</ol>

<h3>Plot Indicators</h3>
<p class="csharp">
 Jupyter Notebooks don't currently support libraries to plot historical data, but we are working on adding the functionality. Until the functionality is added, use Python to plot indicators.
</p>
<p class="python">
 Follow these steps to plot the indicator values:
</p>
<ol class="python">
 <li>
  Select the columsn to plot.
 </li>
 <div class="python section-example-container">
  <pre class="python">df = bb_dataframe[['lowerband', 'middleband', 'upperband', 'price']]</pre>
 </div>
 <li>
  Call the
  <code>
   plot
  </code>
  method.
 </li>
 <div class="python section-example-container">
  <pre class="python">df.plot()</pre>
 </div>
 <li>
  Show the plot.
 </li>
 <div class="python section-example-container">
  <pre class="python">plt.show()</pre>
 </div>
 <img alt="Line plot of custom bollinger band properties" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/custom-resolution-indicator-plot.jpg"/>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="6"><h3>6 Object Store</h3></section>

<h3>Introduction</h3>
<p>
 The Object Store is a file system that you can use in your algorithms to save, read, and delete data. The Object Store is organization-specific, so you can save or read data from the same Object Store in all of your organization's projects. The Object Store works like a key-value storage system where you can store regular strings, JSON encoded strings, XML encoded strings, and bytes. You can access the data you store in the Object Store from backtests, the Research Environment, and live algorithms.
</p>
<p>
 When you deploy live algorithms, the state of the Object Store is copied, but it never refreshes. Therefore, if you save data in the Object Store in a live algorithm, you can access the data from the live algorithm, backtests, and the Research Environment. However, if you save content into the Object Store from the Research Environment or a backtest after you deploy a live algorithm, you can't access the new content from the live algorithm.
</p>

<h3>Get All Stored Data</h3>
<p>
 To get all of the keys and values in the Object Store, iterate through the
 <code>
  ObjectStore
 </code>
 object.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var kvp in qb.ObjectStore)
{
    var key = kvp.Key;
    var value = kvp.Value;
}</pre>
 <pre class="python">for kvp in qb.ObjectStore:
    key = kvp.Key
    value = kvp.Value</pre>
</div>
<p>
 To iterate through just the keys in the Object Store, iterate through the
 <code>
  Keys
 </code>
 property.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var key in qb.ObjectStore.Keys)
{
    continue;
}</pre>
 <pre class="python">for key in qb.ObjectStore.Keys:
    continue</pre>
</div>

<h3>Create Sample Data</h3>
<p>
 You need some data to store data in the Object Store.
</p>
<p>
 Follow these steps to create some sample data:
</p>
<ol>
 <li class="csharp">
  Create a dictionary.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">var dictSample = new Dictionary&lt;string, int&gt; { {"One", 1}, {"Two", 2}, {"Three", 3} };</pre>
 </div>
 <li>
  Create a
  <code>
   string
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var stringSample = "My string";</pre>
  <pre class="python">string_sample = "My string"</pre>
 </div>
 <li>
  Create a
  <code>
   Bytes
  </code>
  object.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var bytesSample = Encoding.UTF8.GetBytes("My String");</pre>
  <pre class="python">bytes_sample = str.encode("My String")</pre>
 </div>
 <li class="csharp">
  Convert the dictionary to an
  <code>
   XML
  </code>
  -formatted object.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">var xmlSample = new XElement("sample",
    dictSample.Select(kvp =&gt; new XElement(kvp.Key, kvp.Value)));
Console.WriteLine(xmlSample.ToString());</pre>
 </div>
 <img alt="Sample XML format data" class="csharp" src="https://cdn.quantconnect.com/i/tu/store-data-xml-cs.png"/>
</ol>

<h3>Save Data</h3>
<p>
 The Object Store saves objects under a key-value system. If you save objects in backtests, you can access them from the Research Environment.
</p>
<p>
 If you run algorithms in QuantConnect Cloud, you need
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/organizations/members#08-Permissions">
  storage create permissions
 </a>
 to save data in the Object Store.
</p>
<p>
 If you don't have data to store,
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/object-store#03-Create-Sample-Data">
  create some sample data
 </a>
 .
</p>
<p class="csharp">
 You can save the following types of objects in the Object Store:
</p>
<ul class="csharp">
 <li>
  <code>
   Bytes
  </code>
  objects
 </li>
 <li>
  <code>
   string
  </code>
  objects
 </li>
 <li>
  JSON objects
 </li>
 <li>
  XML-formatted objects
 </li>
</ul>
<p>
 <span class="python">
  You can save
  <code>
   Bytes
  </code>
  and
  <code>
   string
  </code>
  objects in the Object Store.
 </span>
</p>
<h4>
 Bytes
</h4>
<p>
 To save a
 <code>
  Bytes
 </code>
 object, call the
 <code>
  SaveBytes
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">var saveSuccessful = qb.ObjectStore.SaveBytes($"{qb.ProjectId}/bytesKey", bytesSample)</pre>
 <pre class="python">save_successful = qb.ObjectStore.SaveBytes(f"{qb.ProjectId}/bytes_key", bytes_sample)</pre>
</div>
<h4>
 Strings
</h4>
<p>
 To save a
 <code>
  string
 </code>
 object, call the
 <code>
  Save
 </code>
 or
 <code>
  SaveString
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">var saveSuccessful = qb.ObjectStore.Save($"{qb.ProjectId}/stringKey", stringSample);</pre>
 <pre class="python">save_successful = qb.ObjectStore.Save(f"{qb.ProjectId}/string_key", string_sample)</pre>
</div>
<h4 class="csharp">
 JSON
</h4>
<p class="csharp">
 To save a JSON object, call the
 <code>
  SaveJson&lt;T&gt;
 </code>
 method. This method helps to serialize the data into JSON format.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">var saveSuccessful = qb.ObjectStore.SaveJson&lt;Dictionary&lt;string, int&gt;&gt;($"{qb.ProjectId}/jsonKey", dictSample);</pre>
</div>
<h4 class="csharp">
 XML
</h4>
<p class="csharp">
 To save an XML-formatted object, call the
 <code>
  SaveXml&lt;T&gt;
 </code>
 method.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">var saveSuccessful = qb.ObjectStore.SaveXml&lt;XElement&gt;($"{qb.ProjectId}/xmlKey", xmlSample);</pre>
</div>

<h3>Read Data</h3>
<p>
 To read data from the Object Store, you need to provide the key you used to store the object.
</p>
<p class="csharp">
 You can load the following types of objects from the Object Store:
</p>
<ul class="csharp">
 <li>
  <code>
   Bytes
  </code>
  objects
 </li>
 <li>
  <code>
   string
  </code>
  objects
 </li>
 <li>
  JSON objects
 </li>
 <li>
  XML-formatted objects
 </li>
</ul>
<p class="python">
 You can load
 <code>
  Bytes
 </code>
 and
 <code>
  string
 </code>
 objects from the Object Store.
</p>
<p>
 Before you read data from the Object Store, check if the key exists.
</p>
<div class="section-example-container">
 <pre class="csharp">if (qb.ObjectStore.ContainsKey(key))
{
    // Read data
}</pre>
 <pre class="python">if qb.ObjectStore.ContainsKey(key):
    # Read data</pre>
</div>
<h4>
 Bytes
</h4>
<p>
 To read a
 <code>
  Bytes
 </code>
 object, call the
 <code>
  ReadBytes
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">var bytesData = qb.ObjectStore.ReadBytes($"{qb.ProjectId}/bytesKey");</pre>
 <pre class="python">byte_data = qb.ObjectStore.ReadBytes(f"{qb.ProjectId}/bytes_key")</pre>
</div>
<h4>
 Strings
</h4>
<p>
 To read a
 <code>
  string
 </code>
 object, call the
 <code>
  Read
 </code>
 or
 <code>
  ReadString
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">var stringData = qb.ObjectStore.Read($"{qb.ProjectId}/stringKey");</pre>
 <pre class="python">string_data = qb.ObjectStore.Read(f"{qb.ProjectId}/string_key")</pre>
</div>
<h4 class="csharp">
 JSON
</h4>
<p class="csharp">
 To read a JSON object, call the
 <code>
  ReadJson&lt;T&gt;
 </code>
 method.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">var jsonData = qb.ObjectStore.ReadJson&lt;Dictionary&lt;string, int&gt;&gt;($"{qb.ProjectId}/jsonKey");</pre>
</div>
<h4 class="csharp">
 XML
</h4>
<p class="csharp">
 To read an XML-formatted object, call the
 <code>
  ReadXml&lt;T&gt;
 </code>
 method.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">var xmlData = qb.ObjectStore.ReadXml&lt;XElement&gt;($"{qb.ProjectId}/xmlKey");</pre>
</div>
<p class="csharp">
 If you created the XML object from a dictionary, reconstruct the dictionary.
</p>
<div class="csharp section-example-container">
 <pre class="csharp">var dict = xmlData.Elements().ToDictionary(x =&gt; x.Name.LocalName, x =&gt; int.Parse(x.Value));</pre>
</div>

<h3>Delete Data</h3>
<p>
 Delete objects in the Object Store to remove objects that you no longer need. If you use the Research Environment in QuantConnect Cloud, you need
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/organizations/members#08-Permissions">
  storage delete permissions
 </a>
 to delete data from the Object Store.
</p>
<p>
 To delete objects from the Object Store, call the
 <code>
  Delete
 </code>
 method. Before you delete data, check if the key exists. If you try to delete an object with a key that doesn't exist in the Object Store, the method raises an exception.
</p>
<div class="section-example-container">
 <pre class="csharp">if (qb.ObjectStore.ContainsKey(key))
{
    qb.ObjectStore.Delete(key);
}</pre>
 <pre class="python">if qb.ObjectStore.ContainsKey(key):
    qb.ObjectStore.Delete(key)</pre>
</div>
<p>
 To delete all of the content in the Object Store, iterate through all the stored data.
</p>
<div class="section-example-container">
 <pre class="csharp">foreach (var kvp in qb.ObjectStore)
{
    qb.ObjectStore.Delete(kvp.Key);
}</pre>
 <pre class="python">for kvp in qb.ObjectStore:
    qb.ObjectStore.Delete(kvp.Key)</pre>
</div>

<h3>Cache Data</h3>
<p>
 When you write to or read from the Object Store, the notebook caches the data. The cache speeds up the notebook execution because if you try to read the Object Store data again with the same key, it returns the cached data instead of downloading the data again. The cache speeds up execution, but it can cause problems if you are trying to share data between two nodes under the same Object Store key. For example, consider the following scenario:
</p>
<ol>
 <li>
  You open project A and save data under the key
  <code>
   123
  </code>
  .
 </li>
 <li>
  You open project B and save new data under the same key
  <code>
   123
  </code>
  .
 </li>
 <li>
  In project A, you read the Object Store data under the key
  <code>
   123
  </code>
  , expecting the data from project B, but you get the original data you saved in step #1 instead.
 </li>
 <p>
  You get the data from step 1 instead of step 2 because the cache contains the data from step 1.
 </p>
</ol>
<p>
 To clear the cache, call the
 <code>
  Clear
 </code>
 method.
</p>
<div class="section-example-container">
 <pre class="csharp">qb.ObjectStore.Clear();</pre>
 <pre class="python">qb.ObjectStore.Clear()</pre>
</div>

<h3>Get File Path</h3>
<p>
 To get the file path for a specific key in the Object Store, call the
 <code>
  GetFilePath
 </code>
 method. If the key you pass to the method doesn't already exist in the Object Store, it's added to the Object Store.
</p>
<div class="section-example-container">
 <pre class="csharp">var filePath = qb.ObjectStore.GetFilePath(key);</pre>
 <pre class="python">file_path = qb.ObjectStore.GetFilePath(key)</pre>
</div>

<h3>Storage Quotas</h3>
<p>
 If you use the Research Environment locally, you can store as much data as your hardware will allow. If you use the Research Environment in QuantConnect Cloud, you must stay within your
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/data-storage#03-Storage-Sizes">
  storage quota
 </a>
 . If you need more storage space,
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/data-storage#07-Edit-Storage-Plan">
  edit your storage plan
 </a>
 .
</p>

<h3>Example</h3>
<p>
 You can use the
 <code>
  ObjectStore
 </code>
 to plot data from your backtests and live algorithm in the Research Environment. In the following example, you will learn how to plot the
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/indicators/supported-indicators/simple-moving-average">
  Simple Moving Average
 </a>
 indicator generated in a backtest.
</p>
<ol>
 <li>
  Create a algorithm, add a data subscription and a
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/indicators/supported-indicators/simple-moving-average">
   Simple Moving Average
  </a>
  indicator.
 </li>
 <div class="section-example-container">
  <pre class="csharp">public class ObjectStoreChartingAlgorithm : QCAlgorithm
{
    private SimpleMovingAverage _sma;
    private string _content;

    public override void Initialize()
    {
        AddEquity("SPY", Resolution.Minute);
        _sma = SMA("SPY", 22);
    }
}</pre>
  <pre class="python">class ObjectStoreChartingAlgorithm(QCAlgorithm):
    def Initialize(self):
        self.AddEquity("SPY")
    
        self.content = ''
        self.sma = self.SMA("SPY", 22)</pre>
 </div>
 <p>
  The algorithm will save
  <code class="csharp">
   _content
  </code>
  <code class="python">
   self.content
  </code>
  to the
  <code>
   ObjectStore
  </code>
  .
 </p>
 <li>
  Save indicator data as
  <code>
   string
  </code>
  in
  <code class="csharp">
   _content
  </code>
  <code class="python">
   self.content
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">public override void OnData(Slice data)
{
    _content += $"{_sma.Current.EndTime},{_sma}\n";
}</pre>
  <pre class="python">def OnData(self, data: Slice):
    self.Plot('SMA', 'Value', self.sma.Current.Value)
    self.content += f'{self.sma.Current.EndTime},{self.sma.Current.Value}\n'</pre>
 </div>
 <li>
  To store the collected data, call the
  <code>
   Save
  </code>
  method with a key.
 </li>
 <div class="section-example-container">
  <pre class="csharp">public override void OnEndOfAlgorithm()
{
    ObjectStore.Save("sma_values_csharp", _content);
}</pre>
  <pre class="python">def OnEndOfAlgorithm(self):
    self.ObjectStore.Save('sma_values_python', self.content)</pre>
 </div>
 <li>
  Open the Research Environment, and create a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">// Execute the following command in first
#load "../Initialize.csx"

// Create a QuantBook object
#load "../QuantConnect.csx"
using QuantConnect;
using QuantConnect.Research;

var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  To read data from the Object Store, call the
  <code>
   Read
  </code>
  method. You need to provide the key you used to store the object.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var content = qb.ObjectStore.Read("sma_values_csharp");</pre>
  <pre class="python">content = qb.ObjectStore.Read("sma_values_python")</pre>
 </div>
 <li class="python">
  Convert the data to a pandas object, and create a chart.
 </li>
 <div class="python section-example-container">
  <pre class="python">data = {}
for line in content.split('\n'):
    csv = line.split(',')
    if len(csv) &gt; 1:
        data[csv[0]] = float(csv[1])

series = pd.Series(data, index=data.keys())
series.plot()</pre>
 </div>
 <li class="csharp">
  Import the
  <code>
   Plotly.NET
  </code>
  and
  <code>
   Plotly.NET.LayoutObjects
  </code>
  packages.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">#r "../Plotly.NET.dll"
using Plotly.NET;
using Plotly.NET.LayoutObjects;</pre>
 </div>
 <li class="csharp">
  Create the
  <code>
   Layout
  </code>
  object, and set the
  <code>
   title
  </code>
  ,
  <code>
   xaxis
  </code>
  , and
  <code>
   yaxis
  </code>
  properties.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">var layout = new Layout();
layout.SetValue("title", Title.init("SMA"));

var xAxis = new LinearAxis();
xAxis.SetValue("title", "Time");
layout.SetValue("xaxis", xAxis);

var yAxis = new LinearAxis();
yAxis.SetValue("title", "SMA");
layout.SetValue("yaxis", yAxis);</pre>
 </div>
 <li class="csharp">
  Convert the data to a list of
  <code>
   DateTime
  </code>
  objects for the chart x-axis and a list of
  <code>
   decimal
  </code>
  objects for the chart y-axis. Create a
  <code>
   Chart2D.Chart.Line
  </code>
  object with the data.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">var index = new List&lt;DateTimee&gt;();
var values = new List&lt;decimal&gt;();

foreach (var line in content.Split('\n'))
{
    var csv = line.Split(',');
    if (csv.Length &gt; 1)
    {
        index.Add(Parse.DateTime(csv[0]));
        values.Add(decimal.Parse(csv[1]));
    }
}

var chart = Chart2D.Chart.Linee&lt;DateTime, decimal, stringe&gt;(index, values);</pre>
 </div>
 <li class="csharp">
  Apply the layout to the
  <code>
   Line
  </code>
  object, and create the
  <code>
   HTML
  </code>
  object.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">chart.WithLayout(layout);
var result = HTML(GenericChart.toChartHTML(chart));</pre>
 </div>
</ol>
<div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
 <div class="qc-embed-dummy" style="padding-top: 56.25%;">
 </div>
 <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
  <iframe class="csharp qc-embed-backtest" height="100%" src="https://www.quantconnect.com/terminal/processCache/?request=embedded_backtest_5fb5f5b1bb065a42ef70d4736b10c806.html" style="border: 1px solid #ccc; padding: 0; margin: 0;" width="100%">
  </iframe>
  <iframe class="python qc-embed-backtest" height="100%" src="https://www.quantconnect.com/terminal/processCache/?request=embedded_backtest_bd7112ea146fa3f367c46ce21c489fce.html" style="border: 1px solid #ccc; padding: 0; margin: 0;" width="100%">
  </iframe>
 </div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="7"><h3>7 Machine Learning</h3></section>

<section id="7.1"><h3>7.1 Key Concepts</h3></section>

<h3>Introduction</h3>
<p>
 Machine learning is a field of study that combines statistics and computer science to build intelligent systems that predict outcomes. Quant researchers commonly use machine learning models to optimize portfolios, make trading signals, and manage risk. These models can find relationships in datasets that humans struggle to find, are subtle, or are too complex. You can use machine learning techniques in your research notebooks.
</p>

<h3>Supported Libraries</h3>
<p>
 The following table shows the supported machine learning libraries:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Library
   </th>
   <th>
    Research Tutorial
   </th>
   <th>
    Documentation
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    Keras
   </td>
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/keras">
     Tutorial
    </a>
   </td>
   <td>
    <a href="https://keras.io/" rel="nofollow" target="_blank">
     Documentation
    </a>
   </td>
  </tr>
  <tr>
   <td>
    TensorFlow
   </td>
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/tensorflow">
     Tutorial
    </a>
   </td>
   <td>
    <a href="https://www.tensorflow.org/" rel="nofollow" target="_blank">
     Documentation
    </a>
   </td>
  </tr>
  <tr>
   <td>
    Scikit-Learn
   </td>
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/scikit-learn">
     Tutorial
    </a>
   </td>
   <td>
    <a href="https://scikit-learn.org/stable/index.html" rel="nofollow" target="_blank">
     Documentation
    </a>
   </td>
  </tr>
  <tr>
   <td>
    hmmlearn
   </td>
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/hmmlearn">
     Tutorial
    </a>
   </td>
   <td>
    <a href="https://hmmlearn.readthedocs.io/en/latest/" rel="nofollow" target="_blank">
     Documentation
    </a>
   </td>
  </tr>
  <tr>
   <td>
    gplearn
   </td>
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/gplearn">
     Tutorial
    </a>
   </td>
   <td>
    <a href="https://gplearn.readthedocs.io/en/stable/intro.html" rel="nofollow" target="_blank">
     Documentation
    </a>
   </td>
  </tr>
  <tr>
   <td>
    PyTorch
   </td>
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/pytorch">
     Tutorial
    </a>
   </td>
   <td>
    <a href="https://pytorch.org/" rel="nofollow" target="_blank">
     Documentation
    </a>
   </td>
  </tr>
  <tr>
   <td>
    Stable Baselines
   </td>
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/stable-baselines">
     Tutorial
    </a>
   </td>
   <td>
    <a href="https://stable-baselines.readthedocs.io/en/master/" rel="nofollow" target="_blank">
     Documentation
    </a>
   </td>
  </tr>
  <tr>
   <td>
    tslearn
   </td>
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/tslearn">
     Tutorial
    </a>
   </td>
   <td>
    <a href="https://tslearn.readthedocs.io/en/stable/" rel="nofollow" target="_blank">
     Documentation
    </a>
   </td>
  </tr>
  <tr>
   <td>
    XGBoost
   </td>
   <td>
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/xgboost">
     Tutorial
    </a>
   </td>
   <td>
    <a href="https://xgboost.readthedocs.io/en/latest/" rel="nofollow" target="_blank">
     Documentation
    </a>
   </td>
  </tr>
 </tbody>
</table>

<h3>Add New Libraries</h3>
<p>
 To request a new library,
 <a href="https://www.quantconnect.com/contact">
  contact us
 </a>
 . We will add the library to the queue for review and deployment. Since the libraries run on our servers, we need to ensure they are secure and won't cause harm. The process of adding new libraries takes 2-4 weeks to complete. View the list of libraries currently under review on the
 <a href="https://github.com/QuantConnect/Lean/issues?q=is%3Aissue+is%3Aopen+label%3Alibrary-request" rel="nofollow" target="_blank">
  Issues list of the Lean GitHub repository
 </a>
 .
</p>

<h3>Transfer Models</h3>
<p>
 You can load machine learning models from the Object Store or a custom data file like pickle. If you train a model in the Research Environment, you can also
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/object-store#04-Save-Data">
  save it into the Object Store
 </a>
 to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/machine-learning/key-concepts#09-Load-Models">
  transfer it
 </a>
 to the backtesting and live trading environment.
</p>

<p style="page-break-after: always;">&nbsp;</p>
<section id="7.2"><h3>7.2 Keras</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to build, train, test, and store
 <code>
  keras
 </code>
 models.
</p>

<h3>Import Libraries</h3>
<p>
 Import the
 <code>
  keras
 </code>
 libraries.
</p>
<div class="section-example-container">
 <pre class="python">from tensorflow.keras import utils, models
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten
from tensorflow.keras.optimizers import RMSprop</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to train and test the model. For example, to get data for the SPY ETF during 2020 and 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY", Resolution.Daily).Symbol
history = qb.History(symbol, datetime(2020, 1, 1), datetime(2022, 1, 1)).loc[symbol]</pre>
</div>

<h3>Prepare Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/keras#03-Get-Historical-Data">
  historical data
 </a>
 to prepare the data for the model. If you have historical data, manipulate it to train and test the model. In this example, use the following features and labels:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Data Category
   </th>
   <th>
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    Features
   </td>
   <td>
    Daily percent change of the open, high, low, close, and volume of the SPY over the last 5 days
   </td>
  </tr>
  <tr>
   <td>
    Labels
   </td>
   <td>
    Daily percent return of the SPY over the next day
   </td>
  </tr>
 </tbody>
</table>
<p>
 The following image shows the time difference between the features and labels:
</p>
<img alt="Features and labels for training" class="docs-image" src="https://cdn.quantconnect.com/i/tu/ml-keras-function.png"/>
<p>
 Follow these steps to prepare the data:
</p>
<ol>
 <li>
  Call the
  <code>
   pct_change
  </code>
  and
  <code>
   dropna
  </code>
  methods.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_pct_change = history.pct_change().dropna()</pre>
 </div>
 <li>
  Loop through the
  <code>
   daily_pct_change
  </code>
  DataFrame and collect the features and labels.
 </li>
 <div class="section-example-container">
  <pre class="python">n_steps = 5<br/>features = []
labels = []
for i in range(len(daily_pct_change)-n_steps):
    features.append(daily_pct_change.iloc[i:i+n_steps].values)
    labels.append(daily_pct_change['close'].iloc[i+n_steps])</pre>
 </div>
 <li>
  Convert the lists of features and labels into
  <code>
   numpy
  </code>
  arrays.
 </li>
 <div class="section-example-container">
  <pre class="python">features = np.array(features)
labels = np.array(labels)</pre>
 </div>
 <li>
  Split the data into training and testing periods.
 </li>
 <div class="section-example-container">
  <pre class="python">train_length = int(len(features) * 0.7)
X_train = features[:train_length]
X_test = features[train_length:]
y_train = labels[:train_length]
y_test = labels[train_length:]</pre>
 </div>
</ol>

<h3>Train Models</h3>
<p>
 You need to
 <a href="#04-Prepare-Data">
  prepare the historical data
 </a>
 for training before you train the model. If you have prepared the data, build and train the model. In this example, build a neural network model that predicts the future return of the SPY. Follow these steps to create the model:
 <br/>
</p>
<ol>
 <li>
  Call the
  <code>
   Sequential
  </code>
  constructor with a list of layers.
 </li>
 <div class="section-example-container">
  <pre class="python">model = Sequential([Dense(10, input_shape=(5,5), activation='relu'),
                    Dense(10, activation='relu'),
                    Flatten(),
                    Dense(1)])</pre>
 </div>
 <p>
  Set the
  <code>
   input_shape
  </code>
  of the first layer to
  <code>
   (5, 5)
  </code>
  because each sample contains the percent change of 5 factors (percent change of the open, high, low, close, and volume) over the previous 5 days. Call the
  <code>
   Flatten
  </code>
  constructor because the input is 2-dimensional but the output is just a single value.
 </p>
 <li>
  Call the
  <code>
   compile
  </code>
  method with a loss function, an optimizer, and a list of metrics to monitor.
 </li>
 <div class="section-example-container">
  <pre class="python">model.compile(loss='mse',
              optimizer=RMSprop(0.001),
              metrics=['mae', 'mse'])</pre>
 </div>
 <li>
  Call the
  <code>
   fit
  </code>
  method with the features and labels of the training dataset and a number of epochs.
 </li>
 <div class="section-example-container">
  <pre class="python">model.fit(X_train, y_train, epochs=5)</pre>
 </div>
</ol>

<h3>Test Models</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/keras#05-Train-Models">
  build and train the model
 </a>
 before you test its performance. If you have trained the model, test it on the out-of-sample data. Follow these steps to test the model:
</p>
<ol>
 <li>
  Call the
  <code>
   predict
  </code>
  method with the features of the testing period.
 </li>
 <div class="section-example-container">
  <pre class="python">y_hat = model.predict(X_test)</pre>
 </div>
 <li>
  Plot the actual and predicted labels of the testing period.
 </li>
 <div class="section-example-container">
  <pre class="python">results = pd.DataFrame({'y': y_test.flatten(), 'y_hat': y_hat.flatten()})
df.plot(title='Model Performance: predicted vs actual %change in closing price')</pre>
 </div>
</ol>
<img alt="Keras model performance" class="docs-image" src="https://cdn.quantconnect.com/i/tu/keras-plot.png"/>

<h3>Store Models</h3>
<p>
 You can save and load
 <code>
  keras
 </code>
 models using the ObjectStore.
</p>
<h4>
 Save Models
</h4>
<p>
 Follow these steps to save models in the ObjectStore:
</p>
<ol>
 <li>
  Set the key name of the model to be stored in the ObjectStore.
 </li>
 <div class="section-example-container">
  <pre class="python">model_key = "model"</pre>
 </div>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the file path where the model will be stored.
 </p>
 <li>
  Call the
  <code>
   save
  </code>
  method the file path.
 </li>
 <div class="section-example-container">
  <pre class="python">model.save(file_name)</pre>
 </div>
</ol>
<h4>
 Load Models
</h4>
<p>
 You must save a model into the ObjectStore before you can load it from the ObjectStore. If you saved a model, follow these steps to load it:
</p>
<ol>
 <li>
  Call the
  <code>
   ContainsKey
  </code>
  method with the model key.
 </li>
 <div class="section-example-container">
  <pre class="python">qb.ObjectStore.ContainsKey(model_key)</pre>
 </div>
 <p>
  This method returns a boolean that represents if the
  <code>
   model_key
  </code>
  is in the ObjectStore. If the ObjectStore does not contain the
  <code>
   model_key
  </code>
  , save the model using the
  <code>
   model_key
  </code>
  before you proceed.
 </p>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key name.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the path where the model is stored.
 </p>
 <li>
  Call the
  <code>
   load_model
  </code>
  method with the file path.
 </li>
 <div class="section-example-container">
  <pre class="python">loaded_model = load_model(file_name)</pre>
 </div>
 <p>
  This method returns the saved model.
 </p>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="7.3"><h3>7.3 TensorFlow</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to build, train, test, and store
 <code>
  Tensorflow
 </code>
 models.
</p>

<h3>Import Libraries</h3>
<p>
 Import the
 <code>
  tensorflow
 </code>
 ,
 <code>
  sklearn
 </code>
 ,
 <code>
  json5
 </code>
 and
 <code>
  google.protobuf
 </code>
 libraries.
</p>
<div class="section-example-container">
 <pre class="python">import tensorflow as tf
from sklearn.model_selection import train_test_split
import json5
from google.protobuf import json_format</pre>
</div>
<p>
 You need the
 <code>
  sklearn
 </code>
 library to prepare the data and the
 <code>
  json5
 </code>
 and
 <code>
  google.protobuf
 </code>
 libraries to save models.
</p>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to train and test the model. For example, to get data for the SPY ETF during 2020 and 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY", Resolution.Daily).Symbol
history = qb.History(symbol, datetime(2020, 1, 1), datetime(2022, 1, 1)).loc[symbol]</pre>
</div>

<h3>Prepare Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/tensorflow#03-Get-Historical-Data">
  historical data
 </a>
 to prepare the data for the model. If you have historical data, manipulate it to train and test the model. In this example, use the following features and labels:
</p>
<table class="qc-table table" id="live-trading-custer-sizes-table">
 <thead>
  <tr>
   <th style="width: 50%">
    Data Category
   </th>
   <th>
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    Features
   </td>
   <td>
    The last 5 closing prices
   </td>
  </tr>
  <tr>
   <td>
    Labels
   </td>
   <td>
    The following day's closing price
   </td>
  </tr>
 </tbody>
</table>
<p>
 Follow these steps to prepare the data:
</p>
<ol>
 <li>
  Loop through the DataFrame of historical prices and collect the features.
 </li>
 <div class="section-example-container">
  <pre class="python">lookback = 5
lookback_series = []
for i in range(1, lookback + 1):
    df = history['close'].shift(i)[lookback:-1]
    df.name = f"close_-{i}"
    lookback_series.append(df)
X = pd.concat(lookback_series, axis=1).reset_index(drop=True)</pre>
 </div>
 <p>
  The following image shows the format of the features DataFrame:
 </p>
 <img alt="Features and labels for training" class="docs-image" src="https://cdn.quantconnect.com/i/tu/tf-x.png"/>
 <li>
  Select the close column and then call the
  <code>
   shift
  </code>
  method to collect the labels.
 </li>
 <div class="section-example-container">
  <pre class="python">Y = history['close'].shift(-1)</pre>
 </div>
 <li>
  Drop the first 5 features and then call the
  <code>
   reset_index
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">Y = Y[lookback:-1].reset_index(drop=True)</pre>
 </div>
 <p>
  This method aligns the history of the features and labels.
 </p>
 <li>
  Call the
  <code>
   train_text_split
  </code>
  method with the datasets and a split size.
 </li>
 <p>
  For example, to use the last third of data to test the model, run:
 </p>
 <div class="section-example-container">
  <pre class="python">X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.33, shuffle=False)</pre>
 </div>
</ol>

<h3>Train Models</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/tensorflow#04-Prepare-Data">
  prepare the historical data
 </a>
 for training before you train the model. If you have prepared the data, build and train the model. In this example, build a neural network model that predicts the future price of the SPY.
</p>
<h4>
 Build the Model
</h4>
<p>
 Follow these steps to build the model:
</p>
<ol>
 <li>
  Call the
  <code>
   reset_default_graph
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">tf.reset_default_graph()</pre>
 </div>
 <p>
  This method clears the default graph stack and resets the global default graph.
 </p>
 <li>
  Call the
  <code>
   Session
  </code>
  constructor.
 </li>
 <div class="section-example-container">
  <pre class="python">sess = tf.Session()</pre>
 </div>
 <li>
  Declare the number of factors and then create placeholders for the input and output layers.
 </li>
 <div class="section-example-container">
  <pre class="python">num_factors = X_test.shape[1]
X = tf.placeholder(dtype=tf.float32, shape=[None, num_factors], name='X')
Y = tf.placeholder(dtype=tf.float32, shape=[None])</pre>
 </div>
 <li>
  Set up the weights and bias initializers for each layer.
 </li>
 <div class="section-example-container">
  <pre class="python">weight_initializer = tf.variance_scaling_initializer(mode="fan_avg", distribution="uniform", scale=1)
bias_initializer = tf.zeros_initializer()</pre>
 </div>
 <li>
  Create hidden layers that use the Relu activator.
 </li>
 <div class="section-example-container">
  <pre class="python">num_neurons_1 = 32
num_neurons_2 = 16
num_neurons_3 = 8

W_hidden_1 = tf.Variable(weight_initializer([num_factors, num_neurons_1]))
bias_hidden_1 = tf.Variable(bias_initializer([num_neurons_1]))
hidden_1 = tf.nn.relu(tf.add(tf.matmul(X, W_hidden_1), bias_hidden_1))

W_hidden_2 = tf.Variable(weight_initializer([num_neurons_1, num_neurons_2]))
bias_hidden_2 = tf.Variable(bias_initializer([num_neurons_2]))
hidden_2 = tf.nn.relu(tf.add(tf.matmul(hidden_1, W_hidden_2), bias_hidden_2))

W_hidden_3 = tf.Variable(weight_initializer([num_neurons_2, num_neurons_3]))
bias_hidden_3 = tf.Variable(bias_initializer([num_neurons_3]))
hidden_3 = tf.nn.relu(tf.add(tf.matmul(hidden_2, W_hidden_3), bias_hidden_3))</pre>
 </div>
 <li>
  Create the output layer and give it a name.
 </li>
 <div class="section-example-container">
  <pre class="python">W_out = tf.Variable(weight_initializer([num_neurons_3, 1]))
bias_out = tf.Variable(bias_initializer([1]))
output = tf.transpose(tf.add(tf.matmul(hidden_3, W_out), bias_out), name='outer')</pre>
 </div>
 <p>
  This snippet creates a 1-node output for both weight and bias. You must name the output layer so you can access it after you load and save the model.
 </p>
 <li>
  Set up the loss function and optimizers for gradient descent optimization and backpropagation.
 </li>
 <div class="section-example-container">
  <pre class="python">loss = tf.reduce_mean(tf.squared_difference(output, Y))
optimizer = tf.train.AdamOptimizer().minimize(loss)</pre>
 </div>
 <p>
  Use mean-square error as the loss function because the close price is a continuous data and use Adam as the optimizer because of its adaptive step size.
 </p>
 <li>
  Set the batch size and number of epochs to bootstrap the training process.
 </li>
 <div class="section-example-container">
  <pre class="python">batch_size = len(y_train) // 10
epochs = 20</pre>
 </div>
</ol>
<h4>
 Train the Model
</h4>
<p>
 Follow these steps to train the model:
</p>
<ol>
 <li>
  Call the
  <code>
   run
  </code>
  method with the result from the
  <code>
   global_variables_initializer
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">sess.run(tf.global_variables_initializer())</pre>
 </div>
 <li>
  Loop through the number of epochs, select a subset of the training data, and then call the
  <code>
   run
  </code>
  method with the subset of data.
 </li>
 <div class="section-example-container">
  <pre class="python">for _ in range(epochs):
    for i in range(0, len(y_train) // batch_size):
        start = i * batch_size
        batch_x = X_train[start:start + batch_size]
        batch_y = y_train[start:start + batch_size]
        sess.run(optimizer, feed_dict={X: batch_x, Y: batch_y})</pre>
 </div>
</ol>

<h3>Test Models</h3>
<p>
 To test the model, we'll setup a method to plot test set predictions ontop of the SPY price.
</p>
<div class="section-example-container">
 <pre class="python">def test_model(sess, output, title, X):
    prediction = sess.run(output, feed_dict={X: X_test})
    prediction = prediction.reshape(prediction.shape[1], 1)

    y_test.reset_index(drop=True).plot(figsize=(16, 6), label="Actual")
    plt.plot(prediction, label="Prediction")
    plt.title(title)
    plt.xlabel("Time step")
    plt.ylabel("SPY Price")
    plt.legend()
    plt.show()

test_model(sess, output, "Test Set Results from Original Model", X)</pre>
</div>
<img alt="Tensorflow model performance" class="docs-image" src="https://cdn.quantconnect.com/i/tu/tf-test.png"/>

<h3>Store Models</h3>
<p>
 You can save and load
 <code>
  TensorFlow
 </code>
 models using the ObjectStore.
</p>
<h4>
 Save Models
</h4>
<p>
 Follow these steps to save models in the ObjectStore:
</p>
<ol>
 <li>
  Export the
  <code>
   TensorFlow
  </code>
  graph as a JSON object.
 </li>
 <div class="section-example-container">
  <pre class="python">graph_definition = tf.compat.v1.train.export_meta_graph()
json_graph = json_format.MessageToJson(graph_definition)</pre>
 </div>
 <li>
  Export the
  <code>
   TensorFlow
  </code>
  weights as a JSON object.
 </li>
 <div class="section-example-container">
  <pre class="python"># Define a function to get the weights from the tensorflow session
def get_json_weights(sess):
    weights = sess.run(tf.compat.v1.trainable_variables())
    weights = [w.tolist() for w in weights]
    weights_list = json5.dumps(weights)
    return weights_list
    
json_weights = get_json_weights(sess)
sess.close()    # Close the session opened by the `get_json_weights` function</pre>
 </div>
 <li>
  Save the graph and weights to the
  <code>
   ObjectStore
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">qb.ObjectStore.Save('graph', json_graph)
qb.ObjectStore.Save('weights', json_weights)</pre>
 </div>
</ol>
<h4>
 Load Models
</h4>
<p>
 You must save a model into the ObjectStore before you can load it from the ObjectStore. If you saved a model, follow these steps to load it:
</p>
<ol>
 <li>
  Read the model graph and weights from the
  <code>
   ObjectStore
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">json_graph = qb.ObjectStore.Read('graph')
json_weights = qb.ObjectStore.Read('weights')</pre>
 </div>
 <li>
  Restore the
  <code>
   TensorFlow
  </code>
  graph from the JSON object.
 </li>
 <div class="section-example-container">
  <pre class="python">tf.reset_default_graph()
graph_definition = json_format.Parse(json_graph, tf.compat.v1.MetaGraphDef())
sess = tf.Session()
tf.compat.v1.train.import_meta_graph(graph_definition)</pre>
 </div>
 <li>
  Select the input and output tensors.
  <br/>
 </li>
 <div class="section-example-container">
  <pre class="python">X = tf.compat.v1.get_default_graph().get_tensor_by_name('X:0')
output = tf.compat.v1.get_default_graph().get_tensor_by_name('outer:0')</pre>
 </div>
 <li>
  Restore the model weights from the JSON object.
 </li>
 <div class="section-example-container">
  <pre class="python">weights = [np.asarray(x) for x in json5.loads(json_weights)]
assign_ops = []
feed_dict = {}
vs = tf.compat.v1.trainable_variables()
zipped_values = zip(vs, weights)
for var, value in zipped_values:
    value = np.asarray(value)
    assign_placeholder = tf.placeholder(var.dtype, shape=value.shape)
    assign_op = var.assign(assign_placeholder)
    assign_ops.append(assign_op)
    feed_dict[assign_placeholder] = value
sess.run(assign_ops, feed_dict=feed_dict)</pre>
 </div>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="7.4"><h3>7.4 Scikit-Learn</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to build, train, test, and store
 <code>
  Scikit-Learn
 </code>
 /
 <code>
  sklearn
 </code>
 models.
</p>

<h3>Import Libraries</h3>
<p>
 Import the
 <code>
  sklearn
 </code>
 libraries.
</p>
<div class="section-example-container">
 <pre class="python">from sklearn.svm import SVR
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import train_test_split
import joblib</pre>
</div>
<p>
 You need the
 <code>
  joblib
 </code>
 library to store models.
</p>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to train and test the model. For example, to get data for the SPY ETF during 2020 and 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY", Resolution.Daily).Symbol
history = qb.History(symbol, datetime(2020, 1, 1), datetime(2022, 1, 1)).loc[symbol]</pre>
</div>

<h3>Prepare Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/scikit-learn#03-Get-Historical-Data">
  historical data
 </a>
 to prepare the data for the model. If you have historical data, manipulate it to train and test the model. In this example, use the following features and labels:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Data Category
   </th>
   <th>
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    Features
   </td>
   <td>
    Daily percent change of the open, high, low, close, and volume of the SPY over the last 5 days
   </td>
  </tr>
  <tr>
   <td>
    Labels
   </td>
   <td>
    Daily percent return of the SPY over the next day
   </td>
  </tr>
 </tbody>
</table>
<p>
 The following image shows the time difference between the features and labels:
</p>
<img alt="Features and labels for training" class="docs-image" src="https://cdn.quantconnect.com/i/tu/ml-keras-function.png"/>
<p>
 Follow these steps to prepare the data:
</p>
<ol>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method and then drop the first row.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = history['close'].pct_change()[1:]</pre>
 </div>
 <li>
  Loop through the
  <code>
   daily_returns
  </code>
  DataFrame and collect the features and labels.
 </li>
 <div class="section-example-container">
  <pre class="python">n_steps = 5
features = []
labels = []
for i in range(len(daily_returns)-n_steps):
    features.append(daily_returns.iloc[i:i+n_steps].values)
    labels.append(daily_returns.iloc[i+n_steps])</pre>
 </div>
 <li>
  Convert the lists of features and labels into
  <code>
   numpy
  </code>
  arrays.
 </li>
 <div class="section-example-container">
  <pre class="python">X = np.array(features)
y = np.array(labels)</pre>
 </div>
 <li>
  Split the data into training and testing periods.
 </li>
 <div class="section-example-container">
  <pre class="python">X_train, X_test, y_train, y_test = train_test_split(X, y)</pre>
 </div>
</ol>

<h3>Train Models</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/scikit-learn#04-Prepare-Data">
  prepare the historical data
 </a>
 for training before you train the model. If you have prepared the data, build and train the model. In this example, build a Support Vector Regressor model and optimize its hyperparameters with grid search cross-validation. Follow these steps to create the model:
</p>
<ol>
 <li>
  Set the choices of hyperparameters used for grid search testing.
 </li>
 <div class="section-example-container">
  <pre class="python">param_grid = {'C': [.05, .1, .5, 1, 5, 10], 
              'epsilon': [0.001, 0.005, 0.01, 0.05, 0.1], 
              'gamma': ['auto', 'scale']}</pre>
 </div>
 <li>
  Call the
  <code>
   GridSearchCV
  </code>
  constructor with the SVR model, the parameter grid, a scoring method, the number of cross-validation folds.
 </li>
 <div class="section-example-container">
  <pre class="python">gsc = GridSearchCV(SVR(), param_grid, scoring='neg_mean_squared_error', cv=5)</pre>
 </div>
 <li>
  Call the
  <code>
   fit
  </code>
  method and then select the best estimator.
 </li>
 <div class="section-example-container">
  <pre class="python">model = gsc.fit(X_train, y_train).best_estimator_</pre>
 </div>
</ol>

<h3>Test Models</h3>
<p>
 You need to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/scikit-learn#05-Train-Models">
  build and train the model
 </a>
 before you test its performance. If you have trained the model, test it on the out-of-sample data. Follow these steps to test the model:
</p>
<ol>
 <li>
  Call the
  <code>
   predict
  </code>
  method with the features of the testing period.
 </li>
 <div class="section-example-container">
  <pre class="python">y_hat = model.predict(X_test)</pre>
 </div>
 <li>
  Plot the actual and predicted labels of the testing period.
 </li>
 <div class="section-example-container">
  <pre class="python">df = pd.DataFrame({'y': y_test.flatten(), 'y_hat': y_hat.flatten()})
df.plot(title='Model Performance: predicted vs actual %change in closing price', figsize=(15, 10))</pre>
 </div>
</ol>
<img alt="Sklearn model performance" class="docs-image" src="https://cdn.quantconnect.com/i/tu/sklearn-plot-2.png"/>

<h3>Store Models</h3>
<p>
 You can save and load
 <code>
  sklearn
 </code>
 models using the ObjectStore.
</p>
<h4>
 Save Models
</h4>
<p>
 Follow these steps to save models in the ObjectStore:
</p>
<ol>
 <li>
  Set the key name of the model to be stored in the ObjectStore.
 </li>
 <div class="section-example-container">
  <pre class="python">model_key = "model"</pre>
 </div>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the file path where the model will be stored.
 </p>
 <li>
  Call the
  <code>
   dump
  </code>
  method with the model and file path.
 </li>
 <div class="section-example-container">
  <pre class="python">joblib.dump(model, file_name)</pre>
 </div>
 <p>
  If you dump the model using the
  <code>
   joblib
  </code>
  module before you save the model, you don't need to retrain the model.
 </p>
</ol>
<h4>
 Load Models
</h4>
<p>
 You must save a model into the ObjectStore before you can load it from the ObjectStore. If you saved a model, follow these steps to load it:
</p>
<ol>
 <li>
  Call the
  <code>
   ContainsKey
  </code>
  method with the model key.
 </li>
 <div class="section-example-container">
  <pre class="python">qb.ObjectStore.ContainsKey(model_key)</pre>
 </div>
 <p>
  This method returns a boolean that represents if the
  <code>
   model_key
  </code>
  is in the ObjectStore. If the ObjectStore does not contain the
  <code>
   model_key
  </code>
  , save the model using the
  <code>
   model_key
  </code>
  before you proceed.
 </p>
 <li>
  Call
  <code>
   GetFilePath
  </code>
  with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the path where the model is stored.
 </p>
 <li>
  Call
  <code>
   load
  </code>
  with the file path.
 </li>
 <div class="section-example-container">
  <pre class="python">loaded_model = joblib.load(file_name)</pre>
 </div>
 <p>
  This method returns the saved model.
 </p>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="7.5"><h3>7.5 Hmmlearn</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to build, train, test, and store
 <code>
  Hmmlearn
 </code>
 models.
</p>

<h3>Import Libraries</h3>
<p>
 Import the
 <code>
  Hmmlearn
 </code>
 library.
</p>
<div class="section-example-container">
 <pre class="python">from hmmlearn import hmm
import joblib</pre>
</div>
<p>
 You need the
 <code>
  joblib
 </code>
 library to store models.
</p>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to train and test the model. For example, to get data for the SPY ETF during 2020 and 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY", Resolution.Daily).Symbol
history = qb.History(symbol, datetime(2020, 1, 1), datetime(2022, 1, 1)).loc[symbol]</pre>
</div>

<h3>Prepare Data</h3>
<p>
 You need some
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/hmmlearn#03-Get-Historical-Data">
  historical data
 </a>
 to prepare the data for the model. If you have historical data, manipulate it to train and test the model. Follow these steps to prepare the data:
</p>
<ol>
 <li>
  Select the close column of the historical data DataFrame.
 </li>
 <div class="section-example-container">
  <pre class="python">closes = history['close']</pre>
 </div>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method and then drop the first row.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = closes.pct_change().iloc[1:]</pre>
 </div>
 <li>
  Call the
  <code>
   reshape
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">X = daily_returns.values.reshape(-1, 1)</pre>
 </div>
</ol>

<h3>Train Models</h3>
<p>
 You need to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/hmmlearn#04-Prepare-Data">
  prepare the historical data
 </a>
 for training before you train the model. If you have prepared the data, build and train the model. In this example, assume the market has only 2 regimes and the market returns follow a Gaussian distribution. Therefore, create a 2-component Hidden Markov Model with Gaussian emissions, which is equivalent to a Gaussian mixture model with 2 means. Follow these steps to create the model:
</p>
<ol>
 <li>
  Call the
  <code>
   GaussianHMM
  </code>
  constructor with the number of components, a covariance type, and the number of iterations.
 </li>
 <div class="section-example-container">
  <pre class="python">model = hmm.GaussianHMM(n_components=2, covariance_type="full", n_iter=100)</pre>
 </div>
 <li>
  Call the
  <code>
   fit
  </code>
  method with the training data.
 </li>
 <div class="section-example-container">
  <pre class="python">model.fit(X)</pre>
 </div>
</ol>

<h3>Test Models</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/hmmlearn#05-Train-Models">
  build and train the model
 </a>
 before you test its performance. If you have trained the model, test it on the out-of-sample data. Follow these steps to test the model:
</p>
<ol>
 <li>
  Call the predict method with the testing dataset.
 </li>
 <div class="section-example-container">
  <pre class="python">y = model.predict(X)</pre>
 </div>
 <li>
  Plot the regimes in a scatter plot.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.figure(figsize=(15, 10))
plt.scatter(ret.index, [f'Regime {n+1}' for n in y])
plt.title(f'{symbol} market regime')
plt.xlabel("time")
plt.show()</pre>
 </div>
</ol>
<img alt="Hmmlearn model performance" class="docs-image" src="https://cdn.quantconnect.com/i/tu/hmmmodel-test.png"/>

<h3>Store Models</h3>
<p>
 You can save and load
 <code>
  Hmmlearn
 </code>
 models using the ObjectStore.
</p>
<h4>
 Save Models
</h4>
<p>
 Follow these steps to save models in the ObjectStore:
</p>
<ol>
 <li>
  Set the key name of the model to be stored in the ObjectStore.
 </li>
 <div class="section-example-container">
  <pre class="python">model_key = "model"</pre>
 </div>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the file path where the model will be stored.
 </p>
 <li>
  Call the
  <code>
   dump
  </code>
  method with the model and file path.
 </li>
 <div class="section-example-container">
  <pre class="python">joblib.dump(model, file_name)</pre>
 </div>
 <p>
  If you dump the model using the
  <code>
   joblib
  </code>
  module before you save the model, you don't need to retrain the model.
 </p>
</ol>
<h4>
 Load Models
</h4>
<p>
 You must save a model into the ObjectStore before you can load it from the ObjectStore. If you saved a model, follow these steps to load it:
</p>
<ol>
 <li>
  Call the
  <code>
   ContainsKey
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">qb.ObjectStore.ContainsKey(model_key)</pre>
 </div>
 <p>
  This method returns a boolean that represents if the
  <code>
   model_key
  </code>
  is in the ObjectStore. If the ObjectStore does not contain the
  <code>
   model_key
  </code>
  , save the model using the
  <code>
   model_key
  </code>
  before you proceed.
 </p>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the path where the model is stored.
 </p>
 <li>
  Call the
  <code>
   load
  </code>
  method with the file path.
 </li>
 <div class="section-example-container">
  <pre class="python">loaded_model = joblib.load(file_name)</pre>
 </div>
 <p>
  This method returns the saved model.
 </p>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="7.6"><h3>7.6 Gplearn</h3></section>

<h3>Introduction</h3>
<p>
 This page introduces how to build, train, test, and store
 <code>
  GPlearn
 </code>
 models.
</p>

<h3>Import Libraries</h3>
<p>
 Import the
 <code>
  GPlearn
 </code>
 library.
</p>
<div class="section-example-container">
 <pre class="python">from gplearn.genetic import SymbolicRegressor, SymbolicTransformer
from sklearn.model_selection import train_test_split
import joblib</pre>
</div>
<p>
 You need the
 <code>
  sklearn
 </code>
 library to prepare the data and the
 <code>
  joblib
 </code>
 library to store models.
</p>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to train and test the model. For example, to get data for the SPY ETF during 2020 and 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY", Resolution.Daily).Symbol
history = qb.History(symbol, datetime(2020, 1, 1), datetime(2022, 1, 1)).loc[symbol]</pre>
</div>

<h3>Prepare Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/gplearn#03-Get-Historical-Data">
  historical data
 </a>
 to prepare the data for the model. If you have historical data, manipulate it to train and test the model. In this example, use the following features and labels:
</p>
<table class="qc-table table" id="live-trading-custer-sizes-table">
 <thead>
  <tr>
   <th>
    Data Category
   </th>
   <th>
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    Features
   </td>
   <td>
    Daily percent change of the open, high, low, close, and volume of the SPY over the last 5 days
   </td>
  </tr>
  <tr>
   <td>
    Labels
   </td>
   <td>
    Daily percent return of the SPY over the next day
   </td>
  </tr>
 </tbody>
</table>
<p>
 The following image shows the time difference between the features and labels:
</p>
<img alt="Features and labels for training" class="docs-image" src="https://cdn.quantconnect.com/i/tu/ml-keras-function.png"/>
<p>
 Follow these steps to prepare the data:
</p>
<ol>
 <li>
  Call the
  <code>
   pct_change
  </code>
  method and then drop the first row.
 </li>
 <div class="section-example-container">
  <pre class="python">daily_returns = history['close'].pct_change()[1:]</pre>
 </div>
 <li>
  Loop through the
  <code>
   daily_returns
  </code>
  DataFrame and collect the features and labels.
 </li>
 <div class="section-example-container">
  <pre class="python">n_steps = 5
features = []
labels = []
for i in range(len(daily_returns)-n_steps):
    features.append(daily_returns.iloc[i:i+n_steps].values)
    labels.append(daily_returns.iloc[i+n_steps])</pre>
 </div>
 <li>
  Convert the lists of features and labels into
  <code>
   numpy
  </code>
  arrays.
 </li>
 <div class="section-example-container">
  <pre class="python">X = np.array(features)
y = np.array(labels)</pre>
 </div>
 <li>
  Split the data into training and testing periods.
 </li>
 <div class="section-example-container">
  <pre class="python">X_train, X_test, y_train, y_test = train_test_split(X, y)</pre>
 </div>
</ol>

<h3>Train Models</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/gplearn#04-Prepare-Data">
  prepare the historical data
 </a>
 for training before you train the model. If you have prepared the data, build and train the model. In this example, create a Symbolic Transformer to generate new non-linear features and then build a Symbolic Regressor model. Follow these steps to create the model:
</p>
<ol>
 <li>
  Declare a set of functions to use for feature engineering.
 </li>
 <div class="section-example-container">
  <pre class="python">function_set = ['add', 'sub', 'mul', 'div',
                'sqrt', 'log', 'abs', 'neg', 'inv',
                'max', 'min']</pre>
 </div>
 <li>
  Call the
  <code>
   SymbolicTransformer
  </code>
  constructor with the preceding set of functions.
 </li>
 <div class="section-example-container">
  <pre class="python">gp_transformer = SymbolicTransformer(function_set=function_set,
                                     random_state=0, 
                                     verbose=1)</pre>
 </div>
 <li>
  Call the
  <code>
   fit
  </code>
  method with the training features and labels.
 </li>
 <div class="section-example-container">
  <pre class="python">gp_transformer.fit(X_train, y_train)</pre>
 </div>
 <p>
  This method displays the following output:
 </p>
 <img alt="Gplearn transformer output" class="docs-image" src="https://cdn.quantconnect.com/i/tu/gplearn-transform-2.png"/>
 <li>
  Call the
  <code>
   transform
  </code>
  method with the original features.
 </li>
 <div class="section-example-container">
  <pre class="python">gp_features_train = gp_transformer.transform(X_train)</pre>
 </div>
 <li>
  Call the
  <code>
   hstack
  </code>
  method with the original features and the transformed features.
 </li>
 <div class="section-example-container">
  <pre class="python">new_X_train = np.hstack((X_train, gp_features_train))</pre>
 </div>
 <li>
  Call the
  <code>
   SymbolicRegressor
  </code>
  constructor.
 </li>
 <div class="section-example-container">
  <pre class="python">gp_regressor = SymbolicRegressor(random_state=0, verbose=1)</pre>
 </div>
 <li>
  Call the
  <code>
   fit
  </code>
  method with the engineered features and the original labels.
 </li>
 <div class="section-example-container">
  <pre class="python">gp_regressor.fit(new_X_train, y_train)</pre>
 </div>
 <img alt="Gplearn regressor output" class="docs-image" src="https://cdn.quantconnect.com/i/tu/gplearn-regress-2.png"/>
</ol>

<h3>Test Models</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/gplearn#05-Train-Models">
  build and train the model
 </a>
 before you test its performance. If you have trained the model, test it on the out-of-sample data. Follow these steps to test the model:
</p>
<ol>
 <li>
  Feature engineer the testing set data.
 </li>
 <div class="section-example-container">
  <pre class="python">gp_features_test = gp_transformer.transform(X_test)
new_X_test = np.hstack((X_test, gp_features_test))</pre>
 </div>
 <li>
  Call the
  <code>
   predict
  </code>
  method with the engineered testing set data.
 </li>
 <div class="section-example-container">
  <pre class="python">y_predict = gp_regressor.predict(new_X_test)</pre>
 </div>
 <li>
  Plot the actual and predicted labels of the testing period.
 </li>
 <div class="section-example-container">
  <pre class="python">df = pd.DataFrame({'Real': y_test.flatten(), 'Predicted': y_predict.flatten()})
df.plot(title='Model Performance: predicted vs actual closing price', figsize=(15, 10))
plt.show()</pre>
 </div>
 <img alt="Gplearn model performance" class="docs-image" src="https://cdn.quantconnect.com/i/tu/gplearn-plot-2.png"/>
 <li>
  Calculate the R-square value.
 </li>
 <div class="section-example-container">
  <pre class="python">r2 = gp_regressor.score(new_X_test, y_test)
print(f"The explained variance of the GP model: {r2*100:.2f}%")</pre>
 </div>
 <img alt="Gplearn model r-square" class="docs-image" src="https://cdn.quantconnect.com/i/tu/gplearn-rsquare-2.png"/>
</ol>

<h3>Store Models</h3>
<p>
 You can save and load
 <code>
  GPlearn
 </code>
 models using the ObjectStore.
</p>
<h4>
 Save Models
</h4>
<p>
 Follow these steps to save models in the ObjectStore:
</p>
<ol>
 <li>
  Set the key names of the models to be stored in the ObjectStore.
 </li>
 <div class="section-example-container">
  <pre class="python">transformer_key = "transformer"
regressor_key = "regressor"</pre>
 </div>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key names.
 </li>
 <div class="section-example-container">
  <pre class="python">transformer_file = qb.ObjectStore.GetFilePath(transformer_key)
regressor_file = qb.ObjectStore.GetFilePath(regressor_key)</pre>
 </div>
 <p>
  This method returns the file paths where the models will be stored.
 </p>
 <li>
  Call the
  <code>
   dump
  </code>
  method with the models and file paths.
 </li>
 <div class="section-example-container">
  <pre class="python">joblib.dump(gp_transformer, transformer_file)
joblib.dump(gp_regressor, regressor_file)</pre>
 </div>
 <p>
  If you dump the model using the
  <code>
   joblib
  </code>
  module before you save the model, you don't need to retrain the model.
 </p>
</ol>
<h4>
 Load Models
</h4>
<p>
 You must save a model into the ObjectStore before you can load it from the ObjectStore. If you saved a model, follow these steps to load it:
</p>
<ol>
 <li>
  Call the
  <code>
   ContainsKey
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">qb.ObjectStore.ContainsKey(transformer_key)
qb.ObjectStore.ContainsKey(regressor_key)</pre>
 </div>
 <p>
  This method returns a boolean that represents if the
  <code>
   model_key
  </code>
  is in the ObjectStore. If the ObjectStore does not contain the
  <code>
   model_key
  </code>
  , save the model using the
  <code>
   model_key
  </code>
  before you proceed.
 </p>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the keys.
 </li>
 <div class="section-example-container">
  <pre class="python">transformer_file = qb.ObjectStore.GetFilePath(transformer_key)
regressor_file = qb.ObjectStore.GetFilePath(regressor_key)</pre>
 </div>
 <p>
  This method returns the path where the model is stored.
 </p>
 <li>
  Call the
  <code>
   load
  </code>
  method with the file paths.
 </li>
 <div class="section-example-container">
  <pre class="python">loaded_transformer = joblib.load(transformer_file)
loaded_regressor = joblib.load(regressor_file)</pre>
 </div>
 <p>
  This method returns the saved models.
 </p>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="7.7"><h3>7.7 PyTorch</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how how to build, train, test, and store
 <code>
  PyTorch
 </code>
 models.
</p>

<h3>Import Libraries</h3>
<p>
 Import the
 <code>
  torch
 </code>
 ,
 <code>
  sklearn
 </code>
 , and
 <code>
  joblib
 </code>
 libraries by the following:
</p>
<div class="section-example-container">
 <pre class="python">import torch
from torch import nn
from sklearn.model_selection import train_test_split
import joblib</pre>
</div>
<p>
 You need the
 <code>
  sklearn
 </code>
 library to prepare the data and the
 <code>
  joblib
 </code>
 library to store models.
</p>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to train and test the model. For example, to get data for the SPY ETF during 2020 and 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY", Resolution.Daily).Symbol
history = qb.History(symbol, datetime(2020, 1, 1), datetime(2022, 1, 1)).loc[symbol]</pre>
</div>

<h3>Prepare Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/pytorch#03-Get-Historical-Data">
  historical data
 </a>
 to prepare the data for the model. If you have historical data, manipulate it to train and test the model. In this example, use the following features and labels:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Data Category
   </th>
   <th>
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    Features
   </td>
   <td>
    The last 5 closing prices
   </td>
  </tr>
  <tr>
   <td>
    Labels
   </td>
   <td>
    The following day's closing price
   </td>
  </tr>
 </tbody>
</table>
<p>
 The following image shows the time difference between the features and labels:
</p>
<img alt="Features and labels for training" class="docs-image" src="https://cdn.quantconnect.com/i/tu/ml-keras-function.png"/>
<p>
 Follow these steps to prepare the data:
</p>
<ol>
 <li>
  Perform fractional differencing on the historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">df = (history['close'] * 0.5 + history['close'].diff() * 0.5)[1:]</pre>
 </div>
 <p>
  Fractional differencing helps make the data stationary yet retains the variance information.
 </p>
 <li>
  Loop through the
  <code>
   df
  </code>
  DataFrame and collect the features and labels.
 </li>
 <div class="section-example-container">
  <pre class="python">n_steps = 5
features = []
labels = []
for i in range(len(df)-n_steps):
    features.append(df.iloc[i:i+n_steps].values)
    labels.append(df.iloc[i+n_steps])</pre>
 </div>
 <li>
  Convert the lists of features and labels into
  <code>
   numpy
  </code>
  arrays.
 </li>
 <div class="section-example-container">
  <pre class="python">features = np.array(features)
labels = np.array(labels)</pre>
 </div>
 <li>
  Standardize the features and labels
 </li>
 <div class="section-example-container">
  <pre class="python">X = (features - features.mean()) / features.std()
y = (labels - labels.mean()) / labels.std()</pre>
 </div>
 <li>
  Split the data into training and testing periods.
 </li>
 <div class="section-example-container">
  <pre class="python">X_train, X_test, y_train, y_test = train_test_split(X, y)</pre>
 </div>
</ol>

<h3>Train Models</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/pytorch#04-Prepare-Data">
  prepare the historical data
 </a>
 for training before you train the model. If you have prepared the data, build and train the model. In this example, create a deep neural network with 2 hidden layers. Follow these steps to create the model:
</p>
<ol>
 <li>
  Define a subclass of
  <code>
   nn.Module
  </code>
  to be the model.
  <br/>
 </li>
 <p>
  In this example, use the ReLU activation function for each layer.
 </p>
 <div class="section-example-container">
  <pre class="python">class NeuralNetwork(nn.Module):
    # Model Structure
    def __init__(self):
        super(NeuralNetwork, self).__init__()
        self.flatten = nn.Flatten()
        self.linear_relu_stack = nn.Sequential(
            nn.Linear(5, 5),   # input size, output size of the layer
            nn.ReLU(),         # Relu non-linear transformation
            nn.Linear(5, 5),
            nn.ReLU(),  
            nn.Linear(5, 1),   # Output size = 1 for regression
        )
    
    # Feed-forward training/prediction
    def forward(self, x):
        x = torch.from_numpy(x).float()   # Convert to tensor in type float
        result = self.linear_relu_stack(x)
        return result</pre>
 </div>
 <li>
  Create an instance of the model and set its configuration to train on the GPU if it's available.
 </li>
 <div class="section-example-container">
  <pre class="python">device = 'cuda' if torch.cuda.is_available() else 'cpu'
model = NeuralNetwork().to(device)</pre>
 </div>
 <li>
  Set the loss and optimization functions.
 </li>
 <p>
  In this example, use the mean squared error as the loss function and stochastic gradient descent as the optimizer.
 </p>
 <div class="section-example-container">
  <pre class="python">loss_fn = nn.MSELoss()
learning_rate = 0.001
optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</pre>
 </div>
 <li>
  Train the model.
 </li>
 <p>
  In this example, train the model through 5 epochs.
 </p>
 <div class="section-example-container">
  <pre class="python">epochs = 5
for t in range(epochs):
    print(f"Epoch {t+1}\n-------------------------------")
    
    # Since we're using SGD, we'll be using the size of data as batch number.
    for batch, (X, y) in enumerate(zip(X_train, y_train)):
        # Compute prediction and loss
        pred = model(X)
        real = torch.from_numpy(np.array(y).flatten()).float()
        loss = loss_fn(pred, real)

        # Backpropagation
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        if batch % 100 == 0:
            loss, current = loss.item(), batch
            print(f"loss: {loss:.5f}  [{current:5d}/{len(X_train):5d}]")</pre>
 </div>
 <img alt="Pytorch model training summary" class="docs-image" src="https://cdn.quantconnect.com/i/tu/pytorch-train.png"/>
</ol>

<h3>Test Models</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/pytorch#05-Train-Models">
  build and train the model
 </a>
 before you test its performance. If you have trained the model, test it on the out-of-sample data. Follow these steps to test the model:
</p>
<ol>
 <li>
  Predict with the testing data.
 </li>
 <div class="section-example-container">
  <pre class="python">predict = model(X_test)
y_predict = predict.detach().numpy()   # Convert tensor to numpy ndarray</pre>
 </div>
 <li>
  Plot the actual and predicted values of the testing period.
 </li>
 <div class="section-example-container">
  <pre class="python">df = pd.DataFrame({'Real': y_test.flatten(), 'Predicted': y_predict.flatten()})
df.plot(title='Model Performance: predicted vs actual standardized fractional return', figsize=(15, 10))
plt.show()</pre>
 </div>
 <img alt="Pytorch model performance" class="docs-image" src="https://cdn.quantconnect.com/i/tu/pytorch-plot.png"/>
 <li>
  Calculate the R-square value.
 </li>
 <div class="section-example-container">
  <pre class="python">r2 = 1 - np.sum(np.square(y_test.flatten() - y_predict.flatten())) / np.sum(np.square(y_test.flatten() - y_test.mean()))
print(f"The explained variance by the model (r-square): {r2*100:.2f}%")</pre>
 </div>
 <img alt="Pytorch model r-square" class="docs-image" src="https://cdn.quantconnect.com/i/tu/pytorch-rsquare-2.png"/>
</ol>

<h3>Store Models</h3>
<p>
 You can save and load
 <code>
  PyTorch
 </code>
 models using the ObjectStore.
</p>
<h4>
 Save Models
</h4>
<p>
 Don't use the
 <code>
  torch.save
 </code>
 method to save models because the tensor data will be lost and corrupt the save. Follow these steps to save models in the ObjectStore:
</p>
<ol>
 <li>
  Set the key name of the model to be stored in the ObjectStore.
 </li>
 <div class="section-example-container">
  <pre class="python">model_key = "model"</pre>
 </div>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the file path where the model will be stored.
 </p>
 <li>
  Call the
  <code>
   dump
  </code>
  method with the model and file path.
 </li>
 <div class="section-example-container">
  <pre class="python">joblib.dump(model, file_name)</pre>
 </div>
 <p>
  If you dump the model using the
  <code>
   joblib
  </code>
  module before you save the model, you don't need to retrain the model.
 </p>
</ol>
<h4>
 Load Models
</h4>
<p>
 You must save a model into the ObjectStore before you can load it from the ObjectStore. If you saved a model, follow these steps to load it:
</p>
<ol>
 <li>
  Call the
  <code>
   ContainsKey
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">qb.ObjectStore.ContainsKey(model_key)</pre>
 </div>
 <p>
  This method returns a boolean that represents if the
  <code>
   model_key
  </code>
  is in the ObjectStore. If the ObjectStore does not contain the
  <code>
   model_key
  </code>
  , save the model using the
  <code>
   model_key
  </code>
  before you proceed.
 </p>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the path where the model is stored.
 </p>
 <li>
  Call the
  <code>
   load
  </code>
  method with the file path.
 </li>
 <div class="section-example-container">
  <pre class="python">loaded_model = joblib.load(file_name)</pre>
 </div>
 <p>
  This method returns the saved model.
 </p>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="7.8"><h3>7.8 Stable Baselines</h3></section>

<h3>Introduction</h3>
<p>
 This page introduces how to use
 <code>
  stable baselines
 </code>
 library in Python for reinforcement machine learning (RL) model building, training, saving in the ObjectStore, and loading, through an example of a single-asset deep Q-network learning (DQN) trading bot.
</p>

<h3>Import Libraries</h3>
<p>
 Import the
 <code>
  stable_baselines
 </code>
 , and
 <code>
  gym
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">import gym
from stable_baselines import DQN
from stable_baselines.deepq.policies import MlpPolicy</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to train and test the model. For example, to get data for the SPY ETF during 2020 and 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY", Resolution.Daily).Symbol
history = qb.History(symbol, datetime(2020, 1, 1), datetime(2022, 1, 1)).loc[symbol]</pre>
</div>

<h3>Prepare Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/stable-baselines#03-Get-Historical-Data">
  historical data
 </a>
 to prepare the data for the model. If you have historical data, manipulate it to train and test the model. In this example, calculate the log return time-series of the securities:
</p>
<div class="section-example-container">
 <pre class="python">ret = np.log(history/history.shift(1)).iloc[1:].close</pre>
</div>

<h3>Train Models</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/stable-baselines#04-Prepare-Data">
  prepare the historical data
 </a>
 for training before you train the model. If you have prepared the data, build and train the environment and the model. In this example, create a
 <code>
  gym
 </code>
 environment to initialize the training environment, agent and reward. Then, create a RL model by DQN algorithm. Follow these steps to create the environment and the model:
</p>
<ol>
 <li>
  Split the data for training and testing to evaluate our model.
 </li>
 <div class="section-example-container">
  <pre class="python">X_train = history.iloc[:-50].values
X_test = history.iloc[-50:].values
y_train = ret.iloc[:-50].values
y_test = ret.iloc[-50:].values</pre>
 </div>
 <li>
  Create a custom
  <code>
   gym
  </code>
  environment class.
 </li>
 <p>
  In this example, create a custom environment with previous 5 OHLCV log-return data as observation and the highest portfolio value as reward.
 </p>
 <div class="section-example-container">
  <pre class="python">class TradingEnv(gym.Env):
    metadata = {'render.modes': ['console']}
    
    FLAT = 0
    LONG = 1
    SHORT = 2

    def __init__(self, ohlcv, ret):
        super(TradingEnv, self).__init__()
        
        self.ohlcv = ohlcv
        self.ret = ret
        self.trading_cost = 0.01
        self.reward = 1
        
        # The number of step the training has taken, starts at 5 since we're using the previous 5 data for observation.
        self.current_step = 5
        # The last action
        self.last_action = 0

        # Define action and observation space
        # Example when using discrete actions, we have 3: LONG, SHORT and FLAT.
        n_actions = 3
        self.action_space = gym.spaces.Discrete(n_actions)
        # The observation will be the coordinate of the agent, shape for (5 previous data poionts, OHLCV)
        self.observation_space = gym.spaces.Box(low=-np.inf, high=np.inf, shape=(5, 5), dtype=np.float64)

    def reset(self):
        # Reset the number of step the training has taken
        self.current_step = 5
        # Reset the last action
        self.last_action = 0
        # must return np.array type
        return self.ohlcv[self.current_step-5:self.current_step].astype(np.float32)

    def step(self, action):
        if action == self.LONG:
            self.reward *= 1 + self.ret[self.current_step] - (self.trading_cost if self.last_action != action else 0)
        elif action == self.SHORT:
            self.reward *= 1 + -1 * self.ret[self.current_step] - (self.trading_cost if self.last_action != action else 0)
        elif action == self.FLAT:
             self.reward *= 1 - (self.trading_cost if self.last_action != action else 0)
        else:
            raise ValueError("Received invalid action={} which is not part of the action space".format(action))
            
        self.last_action = action
        self.current_step += 1

        # Have we iterate all data points?
        done = (self.current_step == self.ret.shape[0]-1)

        # Reward as return
        return self.ohlcv[self.current_step-5:self.current_step].astype(np.float32), self.reward, done, {}

    def render(self, mode='console'):
        if mode != 'console':
            raise NotImplementedError()
        print(f'Equity Value: {self.reward}')</pre>
 </div>
 <li>
  Initialize the environment.
 </li>
 <div class="section-example-container">
  <pre class="python">env = TradingEnv(X_train, y_train)</pre>
 </div>
 <li>
  Train the model.
 </li>
 <p>
  In this example, create a RL model and train with MLP-policy DQN algorithm.
 </p>
 <div class="section-example-container">
  <pre class="python">model = DQN(MlpPolicy, env, verbose=1)
model.learn(total_timesteps=1000)</pre>
 </div>
</ol>

<h3>Test Models</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/stable-baselines#05-Train-Models">
  build and train the model
 </a>
 before you test its performance. If you have trained the model, test it on the out-of-sample data. Follow these steps to test the model:
</p>
<ol>
 <li>
  Initialize a list to store the equity value with initial capital in each timestep, and variables to store last action and trading cost.
 </li>
 <div class="section-example-container">
  <pre class="python">equity = [1]
last_action = 0
trading_cost = 0.01</pre>
 </div>
 <li>
  Iterate each testing data point for prediction and trading.
 </li>
 <div class="section-example-container">
  <pre class="python">for i in range(5, X_test.shape[0]):
    action, _ = model.predict(X_test[i-5:i], deterministic=True)
    
    if action == 0:
        new = equity[-1] * (1 - (trading_cost if last_action != action else 0))
    elif action == 1:
        new = equity[-1] * (1 + y_test[i] - (trading_cost if last_action != action else 0))
    elif action == 2:
        new = equity[-1] * (1 + -1 * y_test[i] - (trading_cost if last_action != action else 0))
    
    equity.append(new)
    last_action = action</pre>
 </div>
 <li>
  Plot the result.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.figure(figsize=(15, 10))
plt.title("Equity Curve")
plt.xlabel("timestep")
plt.ylabel("equity")
plt.plot(equity)
plt.show()</pre>
 </div>
 <img alt="Stable baselines model training summary" class="docs-image" src="https://cdn.quantconnect.com/i/tu/rl-plot.png"/>
</ol>

<h3>Store Models</h3>
<p>
 You can save and load
 <code>
  stable baselines
 </code>
 models using the ObjectStore.
</p>
<h4>
 Save Models
</h4>
<ol>
 <li>
  Set the key name of the model to be stored in the ObjectStore.
 </li>
 <div class="section-example-container">
  <pre class="python">model_key = "model"</pre>
 </div>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the file path where the model will be stored.
 </p>
 <li>
  Call the
  <code>
   save
  </code>
  method with the file path.
 </li>
 <div class="section-example-container">
  <pre class="python">model.save(file_name)</pre>
 </div>
</ol>
<h4>
 Load Models
</h4>
<p>
 You must save a model into the ObjectStore before you can load it from the ObjectStore. If you saved a model, follow these steps to load it:
</p>
<ol>
 <li>
  Call the
  <code>
   ContainsKey
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">qb.ObjectStore.ContainsKey(model_key)</pre>
 </div>
 <p>
  This method returns a boolean that represents if the
  <code>
   model_key
  </code>
  is in the ObjectStore. If the ObjectStore does not contain the
  <code>
   model_key
  </code>
  , save the model using the
  <code>
   model_key
  </code>
  before you proceed.
 </p>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the path where the model is stored.
 </p>
 <li>
  Call the
  <code>
   load
  </code>
  method with the file path, environment and policy.
 </li>
 <div class="section-example-container">
  <pre class="python">loaded_model = DQN.load(file_name, env=env, policy=MlpPolicy)</pre>
 </div>
 <p>
  This method returns the saved model.
 </p>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="7.9"><h3>7.9 Tslearn</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to build, train, test, and store
 <code>
  tslearn
 </code>
 models.
</p>

<h3>Import Libraries</h3>
<p>
 Import the
 <code>
  tslearn
 </code>
 libraries.
</p>
<div class="section-example-container">
 <pre class="python">from tslearn.barycenters import softdtw_barycenter
from tslearn.clustering import TimeSeriesKMeans</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to train and test the model. For example, get data for the securities shown in the following table:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th style="width:50%">
    Group Name
   </th>
   <th>
    Tickers
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    Overall US market
   </td>
   <td>
    SPY, QQQ, DIA
   </td>
  </tr>
  <tr>
   <td>
    Tech companies
   </td>
   <td>
    AAPL, MSFT, TSLA
   </td>
  </tr>
  <tr>
   <td>
    Long-term US Treasury ETFs
   </td>
   <td>
    IEF, TLT
   </td>
  </tr>
  <tr>
   <td>
    Short-term US Treasury ETFs
   </td>
   <td>
    SHV, SHY
   </td>
  </tr>
  <tr>
   <td>
    Heavy metal ETFs
   </td>
   <td>
    GLD, IAU, SLV
   </td>
  </tr>
  <tr>
   <td>
    Energy sector
   </td>
   <td>
    USO, XLE, XOM
   </td>
  </tr>
 </tbody>
</table>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
tickers = ["SPY", "QQQ", "DIA", 
           "AAPL", "MSFT", "TSLA", 
           "IEF", "TLT", "SHV", "SHY", 
           "GLD", "IAU", "SLV", 
           "USO", "XLE", "XOM"]
symbols = [qb.AddEquity(ticker, Resolution.Daily).Symbol for ticker in tickers]
history = qb.History(symbols, datetime(2020, 1, 1), datetime(2022, 2, 20))</pre>
</div>

<h3>Prepare Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/tslearn#03-Get-Historical-Data">
  historical data
 </a>
 to prepare the data for the model. If you have historical data, manipulate it to train and test the model. In this example, standardize the log close price time-series of the securities. Follow these steps to prepare the data:
</p>
<ol>
 <li>
  Unstack the historical DataFrame and select the close column.
 </li>
 <div class="section-example-container">
  <pre class="python">close = history.unstack(0).close</pre>
 </div>
 <li>
  Take the logarithm of the historical time series.
 </li>
 <div class="section-example-container">
  <pre class="python">log_close = np.log(close)</pre>
 </div>
 <p>
  Taking the logarithm eases the compounding effect.
 </p>
 <li>
  Standardize the data.
 </li>
 <div class="section-example-container">
  <pre class="python">standard_close = (log_close - log_close.mean()) / log_close.std()</pre>
 </div>
</ol>

<h3>Train Models</h3>
<p>
 Instead of using real-time comparison, we could apply a technique call Dynamic Time Wrapping (DTW) with Barycenter Averaging (DBA). Intuitively, it is a technique of averaging a few time-series into a single one without losing much of their information. Since not all time-series would move efficiently like in ideal EMH assumption, this would allow similarity analysis of different time-series with sticky lags. Check the technical details from
 <a href="https://tslearn.readthedocs.io/en/stable/user_guide/dtw.html">
  tslearn documentation page
 </a>
 .
</p>
<img alt="Dynamic time wraping barycenter averaging visualization" class="docs-image" src="https://cdn.quantconnect.com/i/tu/dba.png"/>
<p>
 We then can separate different clusters by KMean after DBA.
</p>
<div class="section-example-container">
 <pre class="python"># Set up the Time Series KMean model with soft DBA.
km = TimeSeriesKMeans(n_clusters=6,   # We have 6 main groups
                      metric="softdtw",  # soft for differentiable
                      random_state=0)

# Fit the model.
km.fit(standard_close.T)</pre>
</div>

<h3>Test Models</h3>
<p>
 We visualize the clusters and their corresponding underlying series.
</p>
<ol>
 <li>
  Predict with the label of the data.
 </li>
 <div class="section-example-container">
  <pre class="python">labels = km.predict(standard_close.T)</pre>
 </div>
 <li>
  Create a class to aid plotting.
 </li>
 <div class="section-example-container">
  <pre class="python">def plot_helper(ts):
    # plot all points of the data set
    for i in range(ts.shape[0]):
        plt.plot(ts[i, :], "k-", alpha=.2)
        
    # plot the given barycenter of them
    barycenter = softdtw_barycenter(ts, gamma=1.)
    plt.plot(barycenter, "r-", linewidth=2)</pre>
 </div>
 <li>
  Plot the results.
 </li>
 <div class="section-example-container">
  <pre class="python">j = 1
plt.figure(figsize=(15, 10))
for i in set(labels):
    # Select the series in the i-th cluster.
    X = standard_close.iloc[:, [n for n, k in enumerate(labels) if k == i]].values
    
    # Plot the series and barycenter-averaged series.
    plt.subplot(len(set(labels)) // 3 + (1 if len(set(labels))%3 != 0 else 0), 3, j)
    plt.title(f"Cluster {i+1}")
    plot_helper(X.T)
    
    j += 1

plt.show()</pre>
 </div>
 <img alt="Tslearn model equity curves of each cluster" class="docs-image" src="https://cdn.quantconnect.com/i/tu/tslearn-plot.png"/>
 <li>
  Display the groupings.
 </li>
 <div class="section-example-container">
  <pre class="python">for i in set(labels):
    print(f"Cluster {i+1}: {standard_close.columns[[n for n, k in enumerate(labels) if k == i]]}")</pre>
 </div>
 <img alt="Tslearn model clustering result" class="docs-image" src="https://cdn.quantconnect.com/i/tu/tslearn-clustering.png"/>
</ol>

<h3>Store Models</h3>
<p>
 You can save and load
 <code>
  tslearn
 </code>
 models using the ObjectStore.
</p>
<h4>
 Save Models
</h4>
<p>
 Follow these steps to save models in the ObjectStore:
</p>
<ol>
 <li>
  Set the key name of the model to be stored in the ObjectStore.
 </li>
 <div class="section-example-container">
  <pre class="python">model_key = "model"</pre>
 </div>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the file path where the model will be stored.
 </p>
 <li>
  Call the
  <code>
   to_hdf5
  </code>
  method with the file path.
 </li>
 <div class="section-example-container">
  <pre class="python">km.to_hdf5(file_name + ".hdf5")</pre>
 </div>
</ol>
<h4>
 Load Models
</h4>
<p>
 You must save a model into the ObjectStore before you can load it from the ObjectStore. If you saved a model, follow these steps to load it:
</p>
<ol>
 <li>
  Call the
  <code>
   ContainsKey
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">qb.ObjectStore.ContainsKey(model_key)</pre>
 </div>
 <p>
  This method returns a boolean that represents if the
  <code>
   model_key
  </code>
  is in the ObjectStore. If the ObjectStore does not contain the
  <code>
   model_key
  </code>
  , save the model using the
  <code>
   model_key
  </code>
  before you proceed.
 </p>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the path where the model is stored.
 </p>
 <li>
  Call the
  <code>
   from_hdf5
  </code>
  method with the file path.
 </li>
 <div class="section-example-container">
  <pre class="python">loaded_model = TimeSeriesKMeans.from_hdf5(file_name + ".hdf5")</pre>
 </div>
 <p>
  This method returns the saved model.
 </p>
</ol>

<h3>Reference</h3>
<li>
 F. Petitjean, A. Ketterlin, P. Gancarski. (2010). A global averaging method for dynamic time warping, with applications to clustering.
 <i>
  Pattern Recognition. 44(2011). 678-693. Retreived from https://lig-membres.imag.fr/bisson/cours/M2INFO-AIW-ML/papers/PetitJean11.pdf
 </i>
</li>

<p style="page-break-after: always;">&nbsp;</p>
<section id="7.10"><h3>7.10 XGBoost</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to build, train, test, and store
 <code>
  XGBoost
 </code>
 models.
</p>

<h3>Import Libraries</h3>
<p>
 Import the
 <code>
  xgboost
 </code>
 ,
 <code>
  sklearn
 </code>
 , and
 <code>
  joblib
 </code>
 libraries.
</p>
<div class="section-example-container">
 <pre class="python">import xgboost as xgb
from sklearn.model_selection import train_test_split
import joblib</pre>
</div>
<p>
 You need the
 <code>
  sklearn
 </code>
 library to prepare the data and the
 <code>
  joblib
 </code>
 library to save models.
</p>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to train and test the model. For example, to get data for the SPY ETF during 2020 and 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY", Resolution.Daily).Symbol
history = qb.History(symbol, datetime(2020, 1, 1), datetime(2022, 1, 1)).loc[symbol]</pre>
</div>

<h3>Prepare Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/pytorch#03-Get-Historical-Data">
  historical data
 </a>
 to prepare the data for the model. If you have historical data, manipulate it to train and test the model. In this example, use the following features and labels:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Data Category
   </th>
   <th>
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    Features
   </td>
   <td>
    The last 5 closing prices
   </td>
  </tr>
  <tr>
   <td>
    Labels
   </td>
   <td>
    The following day's closing price
   </td>
  </tr>
 </tbody>
</table>
<p>
 The following image shows the time difference between the features and labels:
</p>
<img alt="Features and labels for training" class="docs-image" src="https://cdn.quantconnect.com/i/tu/ml-keras-function.png"/>
<p>
 Follow these steps to prepare the data:
</p>
<ol>
 <li>
  Perform fractional differencing on the historical data.
 </li>
 <div class="section-example-container">
  <pre class="python">df = (history['close'] * 0.5 + history['close'].diff() * 0.5)[1:]</pre>
 </div>
 <p>
  Fractional differencing helps make the data stationary yet retains the variance information.
 </p>
 <li>
  Loop through the
  <code>
   df
  </code>
  DataFrame and collect the features and labels.
 </li>
 <div class="section-example-container">
  <pre class="python">n_steps = 5
features = []
labels = []
for i in range(len(df)-n_steps):
    features.append(df.iloc[i:i+n_steps].values)
    labels.append(df.iloc[i+n_steps])</pre>
 </div>
 <li>
  Convert the lists of features and labels into
  <code>
   numpy
  </code>
  arrays.
 </li>
 <div class="section-example-container">
  <pre class="python">features = np.array(features)
labels = np.array(labels)</pre>
 </div>
 <li>
  Standardize the features and labels
 </li>
 <div class="section-example-container">
  <pre class="python">X = (features - features.mean()) / features.std()
y = (labels - labels.mean()) / labels.std()</pre>
 </div>
 <li>
  Split the data into training and testing periods.
 </li>
 <div class="section-example-container">
  <pre class="python">X_train, X_test, y_train, y_test = train_test_split(X, y)</pre>
 </div>
</ol>

<h3>Train Models</h3>
<p>
 We're about to train a gradient-boosted random forest for future price prediction.
</p>
<ol>
 <li>
  Split the data for training and testing to evaluate our model.
 </li>
 <div class="section-example-container">
  <pre class="python">X_train, X_test, y_train, y_test = train_test_split(X, y)</pre>
 </div>
 <li>
  Format training set into XGBoost matrix.
 </li>
 <div class="section-example-container">
  <pre class="python">dtrain = xgb.DMatrix(X_train, label=y_train)</pre>
 </div>
 <li>
  Train the model with parameters.
 </li>
 <div class="section-example-container">
  <pre class="python">params = {
  'booster': 'gbtree',
  'colsample_bynode': 0.8,
  'learning_rate': 0.1,
  'lambda': 0.1,
  'max_depth': 5,
  'num_parallel_tree': 100,
  'objective': 'reg:squarederror',
  'subsample': 0.8,
}
model = xgb.train(params, dtrain, num_boost_round=10)</pre>
 </div>
</ol>

<h3>Test Models</h3>
<p>
 We then make predictions on the testing data set. We compare our Predicted Values with the Expected Values by plotting both to see if our Model has predictive power.
</p>
<ol>
 <li>
  Format testing set into XGBoost matrix.
 </li>
 <div class="section-example-container">
  <pre class="python">dtest = xgb.DMatrix(X_test, label=y_test)</pre>
 </div>
 <li>
  Predict with the testing set data.
 </li>
 <div class="section-example-container">
  <pre class="python">y_predict = model.predict(dtest)</pre>
 </div>
 <li>
  Plot the result.
 </li>
 <div class="section-example-container">
  <pre class="python">df = pd.DataFrame({'Real': y_test.flatten(), 'Predicted': y_predict.flatten()})
df.plot(title='Model Performance: predicted vs actual closing price', figsize=(15, 10))
plt.show()</pre>
 </div>
 <img alt="Xgboost model performance" class="docs-image" src="https://cdn.quantconnect.com/i/tu/xgboost-plot-2.png"/>
</ol>

<h3>Store Models</h3>
<h4>
 Saving the Model
</h4>
<p>
 We dump the model using the
 <code>
  joblib
 </code>
 module and save it to
 <code>
  ObjectStore
 </code>
 file path. This way, the model doesn't need to be retrained, saving time and computational resources.
</p>
<ol>
 <li>
  Set the key name of the model to be stored in the ObjectStore.
 </li>
 <div class="section-example-container">
  <pre class="python">model_key = "model"</pre>
 </div>
 <li>
  Call
  <code>
   GetFilePath
  </code>
  with the key's name to get the file path.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <li>
  Call dump with the model and file path to save the model to the file path.
 </li>
 <div class="section-example-container">
  <pre class="python">joblib.dump(model, file_name)</pre>
 </div>
</ol>
<h4>
 Loading the Model
</h4>
<p>
 Let's retrieve the model from
 <code>
  ObjectStore
 </code>
 file path and load by
 <code>
  joblib
 </code>
 .
</p>
<ol>
 <li>
  Call the
  <code>
   ContainsKey
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">qb.ObjectStore.ContainsKey(model_key)</pre>
 </div>
 <p>
  This method returns a boolean that represents if the
  <code>
   model_key
  </code>
  is in the ObjectStore. If the ObjectStore does not contain the
  <code>
   model_key
  </code>
  , save the model using the
  <code>
   model_key
  </code>
  before you proceed.
 </p>
 <li>
  Call
  <code>
   GetFilePath
  </code>
  with the key's name to get the file path.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <li>
  Call
  <code>
   load
  </code>
  with the file path to fetch the saved model.
 </li>
 <div class="section-example-container">
  <pre class="python">loaded_model = joblib.load(file_name)</pre>
 </div>
</ol>
<p>
 To ensure loading the model was successfuly, let's test the model.
</p>
<div class="section-example-container">
 <pre class="python">y_pred = loaded_model.predict(dtest)
df = pd.DataFrame({'Real': y_test.flatten(), 'Predicted': y_pred.flatten()})
df.plot(title='Model Performance: predicted vs actual closing price', figsize=(15, 10))</pre>
</div>
<img alt="Restored xgboost model performance" class="docs-image" src="https://cdn.quantconnect.com/i/tu/xgboost-plot-2.png"/>

<p style="page-break-after: always;">&nbsp;</p>
<section id="7.11"><h3>7.11 Aesera</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to build, train, test, and store
 <code>
  Aesera
 </code>
 models.
</p>

<h3>Import Libraries</h3>
<p>
 Import the
 <code>
  aesera
 </code>
 , and
 <code>
  sklearn
 </code>
 libraries.
</p>
<div class="section-example-container">
 <pre class="python">import aesara
import aesara.tensor as at
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
import joblib</pre>
</div>
<p>
 You need the
 <code>
  joblib
 </code>
 library to store models.
</p>

<h3>Get Historical Data</h3>
<p>
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/datasets/us-equity#04-Get-Historical-Data">
  Get some historical market data
 </a>
 to train and test the model. For example, to get data for the SPY ETF during 2020 and 2021, run:
</p>
<div class="section-example-container">
 <pre class="python">qb = QuantBook()
symbol = qb.AddEquity("SPY", Resolution.Daily).Symbol
history = qb.History(symbol, datetime(2020, 1, 1), datetime(2022, 1, 1)).loc[symbol]</pre>
</div>

<h3>Prepare Data</h3>
<p>
 You need some
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/aesera#03-Get-Historical-Data">
  historical data
 </a>
 to prepare the data for the model. If you have historical data, manipulate it to train and test the model. In this example, use the following features and labels:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Data Category
   </th>
   <th>
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    Features
   </td>
   <td>
    Normalized close price of the SPY over the last 5 days
   </td>
  </tr>
  <tr>
   <td>
    Labels
   </td>
   <td>
    Return direction of the SPY over the next day
   </td>
  </tr>
 </tbody>
</table>
<p>
 The following image shows the time difference between the features and labels:
</p>
<img alt="Features and labels for training" class="docs-image" src="https://cdn.quantconnect.com/i/tu/ml-keras-function.png"/>
<p>
 Follow these steps to prepare the data:
</p>
<ol>
 <li>
  Obtain the close price and return direction series.
 </li>
 <div class="section-example-container">
  <pre class="python">close = history['close']
returns = data['close'].pct_change().shift(-1)[lookback*2-1:-1].reset_index(drop=True)
labels = pd.Series([1 if y &gt; 0 else 0 for y in returns])   # binary class</pre>
 </div>
 <li>
  Loop through the
  <code>
   close
  </code>
  Series and collect the features.
 </li>
 <div class="section-example-container">
  <pre class="python">lookback = 5
lookback_series = []
for i in range(1, lookback + 1):
    df = data['close'].shift(i)[lookback:-1]
    df.name = f"close-{i}"
    lookback_series.append(df)
X = pd.concat(lookback_series, axis=1)
# Normalize using the 5 day interval
X = MinMaxScaler().fit_transform(X.T).T[4:]</pre>
 </div>
 <li>
  Convert the lists of features and labels into
  <code>
   numpy
  </code>
  arrays.
 </li>
 <div class="section-example-container">
  <pre class="python">X = np.array(features)
y = np.array(labels)</pre>
 </div>
 <li>
  Split the data into training and testing periods.
 </li>
 <div class="section-example-container">
  <pre class="python">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)</pre>
 </div>
</ol>

<h3>Train Models</h3>
<p>
 You need to
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/aesera#04-Prepare-Data">
  prepare the historical data
 </a>
 for training before you train the model. If you have prepared the data, build and train the model. In this example, build a Logistic Regression model with log loss cross entropy and square error as cost function. Follow these steps to create the model:
</p>
<ol>
 <li>
  Generate a dataset.
 </li>
 <div class="section-example-container">
  <pre class="python"># D = (input_values, target_class)
D = (np.array(X_train), np.array(y_train))</pre>
 </div>
 <li>
  Initialize variables.
 </li>
 <div class="section-example-container">
  <pre class="python"># Declare Aesara symbolic variables
x = at.dmatrix("x")
y = at.dvector("y")

# initialize the weight vector w randomly using share so model coefficients keep their values
# between training iterations (updates)
rng = np.random.default_rng(100)
w = aesara.shared(rng.standard_normal(X.shape[1]), name="w")

# initialize the bias term
b = aesara.shared(0., name="b")</pre>
 </div>
 <li>
  Construct the model graph.
 </li>
 <div class="section-example-container">
  <pre class="python"># Construct Aesara expression graph
p_1 = 1 / (1 + at.exp(-at.dot(x, w) - b))       # Logistic transformation
prediction = p_1 &gt; 0.5                          # The prediction thresholded
xent = y * at.log(p_1) - (1 - y) * at.log(1 - p_1)  # Cross-entropy log-loss function
cost = xent.mean() + 0.01 * (w ** 2).sum()      # The cost to minimize (MSE)
gw, gb = at.grad(cost, [w, b])                  # Compute the gradient of the cost</pre>
 </div>
 <li>
  Compile the model.
 </li>
 <div class="section-example-container">
  <pre class="python">train = aesara.function(
          inputs=[x, y],
          outputs=[prediction, xent],
          updates=((w, w - 0.1 * gw), (b, b - 0.1 * gb)))
predict = aesara.function(inputs=[x], outputs=prediction)</pre>
 </div>
 <li>
  Train the model with training dataset.
 </li>
 <div class="section-example-container">
  <pre class="python">pred, err = train(D[0], D[1])

# We can also inspect the final outcome
print("Final model:")
print(w.get_value())
print(b.get_value())
print("target values for D:")
print(D[1])
print("prediction on D:")
print(predict(D[0]))    # whether &gt; 0.5 or not</pre>
 </div>
 <img alt="Aesera model's training summary" class="docs-image" src="https://cdn.quantconnect.com/i/tu/aesera-model.png"/>
</ol>

<h3>Test Models</h3>
<p>
 You need to
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/machine-learning/aesera#05-Train-Models">
  build and train the model
 </a>
 before you test its performance. If you have trained the model, test it on the out-of-sample data. Follow these steps to test the model:
</p>
<ol>
 <li>
  Call the
  <code>
   predict
  </code>
  method with the features of the testing period.
 </li>
 <div class="section-example-container">
  <pre class="python">y_hat = predict(np.array(X_test))</pre>
 </div>
 <li>
  Plot the actual and predicted labels of the testing period.
 </li>
 <div class="section-example-container">
  <pre class="python">df = pd.DataFrame({'y': y_test, 'y_hat': y_hat}).astype(int)
df.plot(title='Model Performance: predicted vs actual return direction in closing price', figsize=(12, 5))</pre>
 </div>
 <li>
  Calculate the prediction accuracy.
 </li>
 <div class="section-example-container">
  <pre class="python">correct = sum([1 if x==y else 0 for x, y in zip(y_test, y_hat)])
print(f"Accuracy: {correct}/{y_test.shape[0]} ({correct/y_test.shape[0]}%)")</pre>
 </div>
</ol>
<img alt="Aesera model's performance" class="docs-image" src="https://cdn.quantconnect.com/i/tu/aesera-model-performance-2.png"/>

<h3>Store Models</h3>
<p>
 You can save and load
 <code>
  aesera
 </code>
 models using the ObjectStore.
</p>
<h4>
 Save Models
</h4>
<p>
 Follow these steps to save models in the ObjectStore:
</p>
<ol>
 <li>
  Set the key name of the model to be stored in the ObjectStore.
 </li>
 <div class="section-example-container">
  <pre class="python">model_key = "model"</pre>
 </div>
 <li>
  Call the
  <code>
   GetFilePath
  </code>
  method with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the file path where the model will be stored.
 </p>
 <li>
  Call the
  <code>
   dump
  </code>
  method with the model and file path.
 </li>
 <div class="section-example-container">
  <pre class="python">joblib.dump(predict, file_name)</pre>
 </div>
 <p>
  If you dump the model using the
  <code>
   joblib
  </code>
  module before you save the model, you don't need to retrain the model.
 </p>
</ol>
<h4>
 Load Models
</h4>
<p>
 You must save a model into the ObjectStore before you can load it from the ObjectStore. If you saved a model, follow these steps to load it:
</p>
<ol>
 <li>
  Call the
  <code>
   ContainsKey
  </code>
  method with the model key.
 </li>
 <div class="section-example-container">
  <pre class="python">qb.ObjectStore.ContainsKey(model_key)</pre>
 </div>
 <p>
  This method returns a boolean that represents if the
  <code>
   model_key
  </code>
  is in the ObjectStore. If the ObjectStore does not contain the
  <code>
   model_key
  </code>
  , save the model using the
  <code>
   model_key
  </code>
  before you proceed.
 </p>
 <li>
  Call
  <code>
   GetFilePath
  </code>
  with the key.
 </li>
 <div class="section-example-container">
  <pre class="python">file_name = qb.ObjectStore.GetFilePath(model_key)</pre>
 </div>
 <p>
  This method returns the path where the model is stored.
 </p>
 <li>
  Call
  <code>
   load
  </code>
  with the file path.
 </li>
 <div class="section-example-container">
  <pre class="python">loaded_model = joblib.load(file_name)</pre>
 </div>
 <p>
  This method returns the saved model.
 </p>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="8"><h3>8 Debugging</h3></section>

<h3>Introduction</h3>
<p>
 The debugger is a built-in tool to help you debug coding errors while in the Research Environment. The debugger enables you to slow down the code execution, step through the program line-by-line, and inspect the variables to understand the internal state of the notebook.
</p>
<div class="highlight">
 The Research Environment debugger isn't currently available for C#.
</div>

<h3>Breakpoints</h3>
<p>
 Breakpoints are lines in your notebook where execution pauses. You need at least one breakpoint in your notebook to start the debugger.
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
  Open a project
 </a>
 to start adjusting its breakpoints.
</p>
<h4>
 Add Breakpoints
</h4>
<p>
 Click to the left of a line to add a breakpoint on that line.
</p>
<img alt="Add breakpoint" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-environment-breakpoint.gif"/>
<img alt="Add breakpoint" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/research-environment-breakpoint-c.gif"/>
<h4>
 Edit Breakpoint Conditions
</h4>
<p>
 Follow these steps to customize what happens when a breakpoint is hit:
</p>
<ol>
 <li>
  Right-click the breakpoint and then click
  <span class="menu-name">
   Edit Breakpoint...
  </span>
  .
 </li>
 <li>
  Click one of the options in the following table:
 </li>
</ol>
<table class="qc-table table">
 <thead>
  <tr>
   <th>
    Option
   </th>
   <th>
    Additional Steps
   </th>
   <th>
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <span class="menu-name">
     Expression
    </span>
   </td>
   <td>
    Enter an expression and then press
    <span class="key-combinations">
     Enter
    </span>
    .
   </td>
   <td>
    The breakpoint only pauses the notebook when the expression is true.
   </td>
  </tr>
  <tr>
   <td>
    <span class="menu-name">
     Hit Count
    </span>
   </td>
   <td>
    Enter an integer and then press
    <span class="key-combinations">
     Enter
    </span>
    .
   </td>
   <td>
    The breakpoint doesn't pause the notebook until its hit the number of times you specify.
   </td>
  </tr>
 </tbody>
</table>
<h4>
 Enable and Disable Breakpoints
</h4>
<p>
 To enable a breakpoint, right-click it and then click
 <span class="menu-name">
  Enable Breakpoint
 </span>
 .
</p>
<p>
 To disable a breakpoint, right-click it and then click
 <span class="menu-name">
  Disable Breakpoint
 </span>
 .
</p>
<p>
 Follow these steps to enable and disable all breakpoints:
</p>
<ol>
 <li>
  In the right navigation menu, click the
  <img alt="Run &amp; debug icon" class="inline-icon" src="https://cdn.quantconnect.com/i/tu/run-and-debug-icon.png"/>
  <span class="icon-name">
   Run and Debug
  </span>
  icon.
 </li>
 <li>
  In the Run and Debug panel, hover over the
  <span class="page-section-name">
   Breakpoints
  </span>
  section and then click the
  <img class="inline-icon" src="https://cdn.quantconnect.com/i/tu/disable-all-breakpoints-icon.png"/>
  <span class="icon-name">
   Toggle Active Breakpoints
  </span>
  icon.
 </li>
</ol>
<h4>
 Remove Breakpoints
</h4>
<p>
 To remove a breakpoint, right-click it and then click
 <span class="menu-name">
  Remove Breakpoint
 </span>
 .
</p>
<p>
 Follow these steps to remove all breakpoints:
</p>
<ol>
 <li>
  In the right navigation menu, click the
  <img alt="Run &amp; debug icon" class="inline-icon" src="https://cdn.quantconnect.com/i/tu/run-and-debug-icon.png"/>
  <span class="icon-name">
   Run and Debug
  </span>
  icon.
 </li>
 <li>
  In the Run and Debug panel, hover over the
  <span class="page-section-name">
   Breakpoints
  </span>
  section and then click the
  <img class="inline-icon" src="https://cdn.quantconnect.com/i/tu/remove-all-breakpoints-icon.png"/>
  <span class="icon-name">
   Remove All Breakpoints
  </span>
  icon.
 </li>
</ol>

<h3>Launch Debugger</h3>
<p>
 Follow these steps to launch the debugger:
</p>
<ol>
 <li>
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
   Open the project
  </a>
  you want to debug.
 </li>
 <li>
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/files#05-Open-Files">
   Open the notebook file
  </a>
  in your project.
 </li>
 <li>
  In a notebook cell, add at least one breakpoint.
 </li>
 <li>
  In the top-left corner of the cell, click the drop-down arrow and then click
  <span class="menu-name">
   Debug Cell
  </span>
  .
 </li>
</ol>
<p>
 If the Run and Debug panel is not open, it opens when the first breakpoint is hit.
</p>

<h3>Control Debugger</h3>
<p>
 After you launch the debugger, you can use the following buttons to control it:
</p>
<table class="qc-table table" id="debugger-button-table">
 <thead>
  <tr>
   <th>
    Button
   </th>
   <th>
    Name
   </th>
   <th>
    Default Keyboard Shortcut
   </th>
   <th>
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <img alt="Debugger continue icon" src="https://cdn.quantconnect.com/i/tu/debugger-continue-button.png"/>
   </td>
   <td>
    Continue
   </td>
   <td>
   </td>
   <td>
    Continue execution until the next breakpoint
   </td>
  </tr>
  <tr>
   <td>
    <img alt="Debugger step over icon" src="https://cdn.quantconnect.com/i/tu/debugger-stop-over-button.png"/>
   </td>
   <td>
    Step Over
   </td>
   <td>
    <span class="key-combinations">
     Alt+F10
    </span>
   </td>
   <td>
    Step to the next line of code in the current or parent scope
   </td>
  </tr>
  <tr>
   <td>
    <img alt="Debugger step into icon" src="https://cdn.quantconnect.com/i/tu/debugger-step-into-button.png"/>
   </td>
   <td>
    Step Into
   </td>
   <td>
    <span class="key-combinations">
     Alt+F11
    </span>
   </td>
   <td>
    Step into the definition of the function call on the current line
   </td>
  </tr>
  <tr>
   <td>
    <img alt="Debugger restart icon" src="https://cdn.quantconnect.com/i/tu/debugger-restart-button.png"/>
   </td>
   <td>
    Restart
   </td>
   <td>
    <span class="key-combinations">
     Shift+F11
    </span>
   </td>
   <td>
    Restart the debugger
   </td>
  </tr>
  <tr>
   <td>
    <img alt="Debugger disconnect icon" src="https://cdn.quantconnect.com/i/tu/debugger-disconnect-button.png"/>
   </td>
   <td>
    Disconnect
   </td>
   <td>
    <span class="key-combinations">
     Shift+F5
    </span>
   </td>
   <td>
    Exit the debugger
   </td>
  </tr>
 </tbody>
</table>
<style>
 #debugger-button-table td:first-child,
#debugger-button-table th:first-child {
    text-align: center;
}
#debugger-button-table img {
    height: 40px;
}
</style>

<h3>Inspect Variables</h3>
<p>
 After you launch the debugger, you can inspect the state of your notebook as it executes each line of code. You can inspect local variables or custom expressions.
 <span class="python">
  The values of variables in your notebook are formatted in the IDE to improve readability. For example, if you inspect a variable that references a DataFrame, the debugger represents the variable value as the following:
 </span>
</p>
<img alt="Dataframe in a debugger variable view" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/debugger-dataframe.png"/>
<h4>
 Local Variables
</h4>
<p>
 The
 <span class="page-section-name">
  Variables
 </span>
 section of the Run and Debug panel shows the local variables at the current breakpoint. If a variable in the panel is an object, click it to see its members. The panel updates as the notebook runs.
</p>
<img alt="Local variables in debugger view" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/research-environment-local-variables-py.gif"/>
<p>
 Follow these steps to update the value of a variable:
</p>
<ol>
 <li>
  In the Run and Debug panel, right-click a variable and then click
  <span class="menu-name">
   Set Value
  </span>
  .
 </li>
 <li>
  Enter the new value and then press
  <span class="key-combinations">
   Enter
  </span>
  .
 </li>
</ol>
<h4>
 Custom Expressions
</h4>
<p>
 The
 <span class="page-section-name">
  Watch
 </span>
 section of the Run and Debug panel shows any custom expressions you add. For example, you can add an expression to show a
 <code>
  datetime
 </code>
 object.
</p>
<img alt="Inspect custom variables in debugger view" class="docs-image" src="https://cdn.quantconnect.com/i/tu/research-env-custom-expressions-debug.jpg"/>
<p>
 Follow these steps to add a custom expression:
</p>
<ol>
 <li>
  Hover over the
  <span class="page-section-name">
   Watch
  </span>
  section and then click the
  <span class="icon-name">
   plus
  </span>
  icon that appears.
 </li>
 <li>
  Enter an expression and then press
  <span class="key-combinations">
   Enter
  </span>
  .
 </li>
</ol>

<p style="page-break-after: always;">&nbsp;</p>
<section id="9"><h3>9 Meta Analysis</h3></section>

<section id="9.1"><h3>9.1 Key Concepts</h3></section>

<h3>Introduction</h3>
<p>
 Understanding your strategy trades in detail is key to attributing performance, and determining areas to focus for improvement. This analysis can be done with the QuantConnect API. We enable you to load backtest, optimization, and live trading results into the Research Environment.
</p>

<h3>Backtest Analysis</h3>
<p>
 Load your backtest results into the Research Environment to analyze trades and easily compare them against the raw backtesting data. For more information on loading and manipulating backtest results, see
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/meta-analysis/backtest-analysis">
  Backtest Analysis
 </a>
 .
</p>

<h3>Optimization Analysis</h3>
<p>
 Load your optimization results into the Research Environment to analyze how different combinations of parameters affect the algorithm's performance. For more information on loading and manipulating optimizations results, see
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/meta-analysis/optimization-analysis">
  Optimization Analysis
 </a>
 .
</p>

<h3>Live Analysis</h3>
<p>
 Load your live trading results into the Research Environment to compare live trading performance against simulated backtest results, or analyze your trades to improve your slippage and fee models. For more information on loading and manipulating live trading results, see
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/research-environment/meta-analysis/live-analysis">
  Live Analysis
 </a>
 .
</p>

<p style="page-break-after: always;">&nbsp;</p>
<section id="9.2"><h3>9.2 Backtest Analysis</h3></section>

<h3>Introduction</h3>
<p>
 Load your backtest results into the Research Environment to analyze trades and easily compare them against the raw backtesting data. Compare backtests from different projects to find uncorrelated strategies to combine for better performance.
</p>
<p>
 Loading your backtest trades allows you to plot fills against detailed data, or locate the source of profits. Similarly you can search for periods of high churn to reduce turnover and trading fees.
</p>

<h3>Read Backtest Results</h3>
<p>
 To get the results of a backtest, call the
 <code>
  ReadBacktest
 </code>
 method with the project Id and backtest ID.
</p>
<div class="section-example-container">
 <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"

using QuantConnect;
using QuantConnect.Api;

var backtest = api.ReadBacktest(projectId, backtestId);</pre>
 <pre class="python">backtest = api.ReadBacktest(project_id, backtest_id)</pre>
</div>
<p>
 To get the project Id,
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
  open the project in the Algorithm Lab
 </a>
 and check the URL. For example, the project Id of https://www.quantconnect.com/project/13946911 is 13946911.
</p>
<p>
 To get the backtest Id,
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/backtesting/results#16-View-All-Backtests">
  open a backtest result in the Algorithm Lab
 </a>
 and check the last line of its
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/backtesting/results#12-Logs">
  log file
 </a>
 . An example backtest Id is 97e7717f387cadd070e4b77015aacece.
</p>
<p>
 Note that this method returns a snapshot of the backtest at the current moment. If the backtest is still executing, the result won't include all of the backtest data.
</p>
<p>
 The
 <code>
  ReadBacktest
 </code>
 method returns a
 <code>
  Backtest
 </code>
 object, which have the following attributes:
</p>
<div data-tree="QuantConnect.Api.Backtest">
</div>

<h3>Plot Order Fills</h3>
<p>
 Follow these steps to plot the daily order fills of a backtest:
</p>
<ol>
 <li>
  Get the backtest orders.
 </li>
 <div class="section-example-container">
  <pre class="python">orders = api.ReadBacktestOrders(project_id, backtest_id)</pre>
 </div>
 <p>
  To get the project Id,
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
   open the project in the Algorithm Lab
  </a>
  and check the URL. For example, the project Id of https://www.quantconnect.com/project/13946911 is 13946911.
 </p>
 <p>
  To get the backtest Id,
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/backtesting/results#16-View-All-Backtests">
   open a backtest result in the Algorithm Lab
  </a>
  and check the last line of its
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/backtesting/results#12-Logs">
   log file
  </a>
  . An example backtest Id is 97e7717f387cadd070e4b77015aacece.
 </p>
 <p>
  The
  <code>
   ReadBacktestOrders
  </code>
  method returns a list of
  <code>
   Order
  </code>
  objects, which have the following properties:
 </p>
 <div data-tree="QuantConnect.Orders.Order">
 </div>
 <li>
  Organize the trade times and prices for each security into a dictionary.
  <div class="section-example-container">
   <pre class="python">class OrderData:
    def __init__(self):
        self.buy_fill_times = []
        self.buy_fill_prices = []
        self.sell_fill_times = []
        self.sell_fill_prices = []

order_data_by_symbol = {}
for order in orders:
    if order.Symbol not in order_data_by_symbol:
        order_data_by_symbol[order.Symbol] = OrderData()
    order_data = order_data_by_symbol[order.Symbol]
    is_buy = order.Quantity &gt; 0
    (order_data.buy_fill_times if is_buy else order_data.sell_fill_times).append(order.LastFillTime.date())
    (order_data.buy_fill_prices if is_buy else order_data.sell_fill_prices).append(order.Price)</pre>
  </div>
 </li>
 <li>
  Get the price history of each security you traded.
  <div class="section-example-container">
   <pre class="python">qb = QuantBook()
start_date = datetime.max.date()
end_date = datetime.min.date()
for symbol, order_data in order_data_by_symbol.items():
    start_date = min(start_date, min(order_data.buy_fill_times), min(order_data.sell_fill_times))
    end_date = max(end_date, max(order_data.buy_fill_times), max(order_data.sell_fill_times))
start_date -= timedelta(days=1)
all_history = qb.History(list(order_data_by_symbol.keys()), start_date, end_date, Resolution.Daily)</pre>
  </div>
 </li>
 <li>
  Create a candlestick plot for each security and annotate each plot with buy and sell markers.
  <div class="section-example-container">
   <pre class="python">import plotly.express as px
import plotly.graph_objects as go

for symbol, order_data in order_data_by_symbol.items():
    history = all_history.loc[symbol]

    # Plot security price candlesticks
    candlestick = go.Candlestick(x=history.index,
                                open=history['open'],
                                high=history['high'],
                                low=history['low'],
                                close=history['close'],
                                name='Price')
    layout = go.Layout(title=go.layout.Title(text=f'{symbol.Value} Trades'),
                    xaxis_title='Date',
                    yaxis_title='Price',
                    xaxis_rangeslider_visible=False,
                    height=600)
    fig = go.Figure(data=[candlestick], layout=layout)

    # Plot buys
    fig.add_trace(go.Scatter(
        x=order_data.buy_fill_times,
        y=order_data.buy_fill_prices,
        marker=go.scatter.Marker(color='aqua', symbol='triangle-up', size=10),
        mode='markers',
        name='Buys',
    ))

    # Plot sells
    fig.add_trace(go.Scatter(
        x=order_data.sell_fill_times,
        y=order_data.sell_fill_prices,
        marker=go.scatter.Marker(color='indigo', symbol='triangle-down', size=10),
        mode='markers',
        name='Sells',
    ))

fig.show()</pre>
  </div>
 </li>
 <img alt="Plot of AAPL price with buy/sell markers" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plot-backtest-trades-in-research-env-aapl.png"/>
 <img alt="Plot of SPY price with buy/sell markers" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plot-backtest-trades-in-research-env-spy.png"/>
 <p>
  Note: The preceding plots only show the last fill of each trade. If your trade has partial fills, the plots only display the last fill.
 </p>
</ol>

<h3>Plot Metadata</h3>
<p>
 Follow these steps to plot the equity curve, benchmark, and drawdown of a backtest:
</p>
<ol>
 <li>
  Get the backtest instance.
 </li>
 <div class="section-example-container">
  <pre class="python">backtest = api.ReadBacktest(project_id, backtest_id)</pre>
 </div>
 <p>
  To get the project Id,
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
   open the project in the Algorithm Lab
  </a>
  and check the URL. For example, the project Id of https://www.quantconnect.com/project/13946911 is 13946911.
 </p>
 <p>
  To get the backtest Id,
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/backtesting/results#16-View-All-Backtests">
   open a backtest result in the Algorithm Lab
  </a>
  and check the last line of its
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/backtesting/results#12-Logs">
   log file
  </a>
  . An example backtest Id is 97e7717f387cadd070e4b77015aacece.
 </p>
 <li>
  Get the "Strategy Equity", "Drawdown", and "Benchmark"
  <code>
   Chart
  </code>
  objects.
 </li>
 <div class="section-example-container">
  <pre class="python">equity_chart = backtest.Charts["Strategy Equity"]
drawdown_chart = backtest.Charts["Drawdown"]
benchmark_chart = backtest.Charts["Benchmark"]</pre>
 </div>
 <li>
  Get the "Equity", "Equity Drawdown", and "Benchmark"
  <code>
   Series
  </code>
  from the preceding charts.
 </li>
 <div class="section-example-container">
  <pre class="python">equity = equity_chart.Series["Equity"].Values
drawdown = drawdown_chart.Series["Equity Drawdown"].Values
benchmark = benchmark_chart.Series["Benchmark"].Values</pre>
 </div>
 <li>
  Create a
  <code>
   pandas.DataFrame
  </code>
  from the series values.
 </li>
 <div class="section-example-container">
  <pre class="python">df = pd.DataFrame({
    "Equity": pd.Series({datetime.fromtimestamp(value.x): value.y for value in equity}),
    "Drawdown": pd.Series({datetime.fromtimestamp(value.x): value.y for value in drawdown}),
    "Benchmark": pd.Series({datetime.fromtimestamp(value.x): value.y for value in benchmark})
}).ffill()</pre>
 </div>
 <li>
  Plot the performance chart.
 </li>
 <div class="section-example-container">
  <pre class="python"># Create subplots to plot series on same/different plots
fig, ax = plt.subplots(2, 1, figsize=(12, 12), sharex=True, gridspec_kw={'height_ratios': [2, 1]})

# Plot the equity curve
ax[0].plot(df.index, df["Equity"])
ax[0].set_title("Strategy Equity Curve")
ax[0].set_ylabel("Portfolio Value ($)")

# Plot the benchmark on the same plot, scale by using another y-axis
ax2 = ax[0].twinx()
ax2.plot(df.index, df["Benchmark"], color="grey")
ax2.set_ylabel("Benchmark Price ($)", color="grey")

# Plot the drawdown on another plot
ax[1].plot(df.index, df["Drawdown"], color="red")
ax[1].set_title("Drawdown")
ax[1].set_xlabel("Time")
ax[1].set_ylabel("%")</pre>
 </div>
 <img alt="api-equity-curve" class="docs-image" src="https://cdn.quantconnect.com/i/tu/api-result-plot.png"/>
</ol>
<p>
 The following table shows all the chart series you can plot:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th style="width: 20%">
    Chart
   </th>
   <th style="width: 20%">
    Series
   </th>
   <th style="width: 60%">
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td rowspan="2">
    Strategy Equity
   </td>
   <td>
    Equity
   </td>
   <td>
    Time series of the equity curve
   </td>
  </tr>
  <tr>
   <td>
    Daily Performance
   </td>
   <td>
    Time series of daily percentage change
   </td>
  </tr>
  <tr>
   <td>
    Capacity
   </td>
   <td>
    Strategy Capacity
   </td>
   <td>
    Time series of
    <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/glossary#08-capacity">
     strategy capacity
    </a>
    snapshots
   </td>
  </tr>
  <tr>
   <td>
    Drawdown
   </td>
   <td>
    Equity Drawdown
   </td>
   <td>
    Time series of equity peak-to-trough value
   </td>
  </tr>
  <tr>
   <td>
    Benchmark
   </td>
   <td>
    Benchmark
   </td>
   <td>
    Time series of the
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/initialization#11-Set-Benchmark">
     benchmark
    </a>
    closing price (SPY, by default)
   </td>
  </tr>
  <tr>
   <td rowspan="2">
    Exposure
   </td>
   <td>
    <span class="placeholder-text">
     SecurityType
    </span>
    - Long Ratio
   </td>
   <td>
    Time series of the overall ratio of
    <span class="placeholder-text">
     SecurityType
    </span>
    long positions of the whole portfolio if any
    <span class="placeholder-text">
     SecurityType
    </span>
    is ever in the universe
   </td>
  </tr>
  <tr>
   <td>
    <span class="placeholder-text">
     SecurityType
    </span>
    - Short Ratio
   </td>
   <td>
    Time series of the overall ratio of
    <span class="placeholder-text">
     SecurityType
    </span>
    short position of the whole portfolio if any
    <span class="placeholder-text">
     SecurityType
    </span>
    is ever in the universe
   </td>
  </tr>
  <tr>
   <td>
    Custom Chart
   </td>
   <td>
    Custom Series
   </td>
   <td>
    Time series of a
    <code>
     Series
    </code>
    in a
    <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/charting">
     custom chart
    </a>
   </td>
  </tr>
 </tbody>
</table>

<p style="page-break-after: always;">&nbsp;</p>
<section id="9.3"><h3>9.3 Optimization Analysis</h3></section>

<h3>Introduction</h3>
<p>
 Load your optimization results into the Research Environment to analyze how different combinations of parameters affect the algorithm's performance.
</p>

<h3>Read Optimization Results</h3>
<p>
 To get the results of an optimization, call the
 <code>
  ReadOptimization
 </code>
 method with the optimization Id.
</p>
<div class="section-example-container">
 <pre class="csharp">var optimization = api.ReadOptimization(optimizationId);</pre>
 <pre class="python">optimization = api.ReadOptimization(optimization_id)</pre>
</div>
<p>
 To get the optimization Id, check the
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/ide#06-Cloud-Terminal">
  Cloud Terminal
 </a>
 when you
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/optimization/getting-started#04-View-All-Optimizations">
  run an optimization in the Algorithm Lab
 </a>
 . An example optimization Id is O-696d861d6dbbed45a8442659bd24e59f.
</p>
<p>
 The
 <code>
  ReadOptimization
 </code>
 method returns an
 <code>
  Optimization
 </code>
 object, which have the following attributes:
</p>
<div data-tree="QuantConnect.Api.Optimization">
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="9.4"><h3>9.4 Live Analysis</h3></section>

<h3>Introduction</h3>
<p>
 Load your live trading results into the Research Environment to compare live trading performance against simulated backtest results.
</p>

<h3>Read Live Results</h3>
<p>
 To get the results of a live algorithm, call the
 <code>
  ReadLiveAlgorithm
 </code>
 method with the project Id and deployment ID.
</p>
<div class="section-example-container">
 <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"

using QuantConnect;
using QuantConnect.Api;

var liveAlgorithm = api.ReadLiveAlgorithm(projectId, deployId);</pre>
 <pre class="python">live_algorithm = api.ReadLiveAlgorithm(project_id, deploy_id)</pre>
</div>
<p>
 To get the project Id,
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
  open the project in the Algorithm Lab
 </a>
 and check the URL. For example, the project Id of https://www.quantconnect.com/project/13946911 is 13946911.
</p>
<p>
 To get the deployment Id,
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/live-trading/results#12-View-All-Live-Projects">
  open a live result in the Algorithm Lab
 </a>
 and check its
 <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/backtesting/results#12-Logs">
  log file
 </a>
 . An example deployment Id is L-ac54ffadf4ca52efabcd1ac29e4735cf. If you have deployed the project multiple times, the log file has multiple deployment Ids. In this case, use the most recent Id.
</p>
<p>
 The
 <code>
  ReadLiveAlgorithm
 </code>
 method returns a
 <code>
  LiveAlgorithmResults
 </code>
 object, which have the following attributes:
</p>
<div data-tree="QuantConnect.Api.LiveAlgorithmResults">
</div>

<h3>Reconciliation</h3>
<p>
 Reconciliation is a way to
 <a href="https://www.quantconnect.com/forum/discussion/7606/a-new-reconciliation-metric/p1">
  quantify
 </a>
 the difference between an algorithm's live performance and its out-of-sample (OOS) performance (a backtest run over the live deployment period).
</p>
<p>
 Seeing the difference between live performance and OOS performance gives you a way to determine if the algorithm is making unrealistic assumptions, exploiting data differences, or merely exhibiting behavior that is impractical or impossible in live trading.
</p>
<p>
 A perfectly reconciled algorithm has an exact overlap between its live equity and OOS backtest curves. Any deviation means that the performance of the algorithm has differed for some reason. Several factors can contribute to this, often stemming from the algorithm design.
</p>
<p>
 <img alt="Live Deployment Reconciliation" class="docs-image" src="https://cdn.quantconnect.com/i/tu/reconciliation-4.png" width="100%"/>
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
 </script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
 </script>
 <p>
  Reconciliation is scored using two metrics: returns correlation and dynamic time warping (DTW) distance.
 </p>
 <h4>
  What is DTW Distance?
 </h4>
 <p>
  Dynamic Time Warp (DTW) Distance quantifies the difference between two time-series. It is an algorithm that measures the shortest path between the points of two time-series. It uses Euclidean distance as a measurement of
  <b>
   point-to-point distance
  </b>
  and returns an overall measurement of the distance on the scale of the initial time-series values. We apply DTW to the returns curve of the live and OOS performance, so the DTW distance measurement is on the scale of percent returns.
 </p>
 $$\begin{equation}
DTW(X,Y) = min\bigg\{\sum_{l=1}^{L}\left(x_{m_l} - y_{n_l}\right)^{2}\in P^{N\times M}\bigg\}
\end{equation}$$
 <p>
  For the reasons outlined in our research notebook on the topic (linked below), QuantConnect annualizes the daily DTW. An annualized distance provides a user with a measurement of the annual difference in the magnitude of returns between the two curves. A perfect score is 0, meaning the returns for each day were precisely the same. A DTW score of 0 is nearly impossible to achieve, and we consider anything below 0.2 to be a decent score. A distance of 0.2 means the returns between an algorithm's live and OOS performance deviated by 20% over a year.
 </p>
 <h4>
  What is Returns Correlation?
 </h4>
 <p>
  Returns correlation is the simple Pearson correlation between the live and OOS returns. Correlation gives us a rudimentary understanding of how the returns move together. Do they trend up and down at the same time? Do they deviate in direction or timing?
 </p>
 $$\begin{equation}
\rho_{XY} = \frac{cov(X, Y)}{\sigma_X\sigma_Y}
\end{equation}$$
 <p>
  An algorithm's returns correlation should be as close to 1 as possible. We consider a good score to be 0.8 or above, meaning that there is a strong positive correlation. This indicates that the returns move together most of the time and that for any given return you see from one of the curves, the other curve usually has a similar direction return (positive or negative).
 </p>
 <h4>
  Why Do We Need Both DTW and Returns Correlation?
 </h4>
 <p>
  Each measurement provides insight into distinct elements of time-series similarity, but neither measurement alone gives us the whole picture. Returns correlation tells us whether or not the live and OOS returns move together, but it doesn't account for the possible differences in the magnitude of the returns. DTW distance measures the difference in magnitude of returns but provides no insight into whether or not the returns move in the same direction. It is possible for there to be two cases of equity curve similarity where both pairs have the same DTW distance, but one has perfectly negatively correlated returns, and the other has a perfectly positive correlation. Similarly, it is possible for two pairs of equity curves to each have perfect correlation but substantially different DTW distance. Having both measurements provides us with a more comprehensive understanding of the actual similarity between live and OOS performance. We outline several interesting cases and go into more depth on the topic of reconciliation in
  <a href="https://www.quantconnect.com/forum/discussion/7606/a-new-reconciliation-metric/p1">
   research
  </a>
  we have published.
 </p>
</p>

<h3>Plot Order Fills</h3>
<p>
 Follow these steps to plot the daily order fills of a live algorithm:
</p>
<ol>
 <li>
  Get the live trading orders.
 </li>
 <div class="section-example-container">
  <pre class="python">orders = api.ReadLiveOrders(project_id)</pre>
 </div>
 <p>
  To get the project Id,
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
   open the project in the Algorithm Lab
  </a>
  and check the URL. For example, the project Id of https://www.quantconnect.com/project/13946911 is 13946911.
 </p>
 <p>
  By default, the orders with an ID between 0 and 100. To get orders with an ID greater than 100, pass
  <code>
   start
  </code>
  and
  <code>
   end
  </code>
  arguments to the
  <code>
   ReadLiveOrders
  </code>
  method. Note that
  <code>
   end
  </code>
  -
  <code>
   start
  </code>
  must be less than 100.
 </p>
 <div class="section-example-container">
  <pre class="python">orders = api.ReadLiveOrders(project_id, 100, 150)</pre>
 </div>
 <p>
  The
  <code>
   ReadLiveOrders
  </code>
  method returns a list of
  <code>
   Order
  </code>
  objects, which have the following properties:
 </p>
 <div data-tree="QuantConnect.Orders.Order">
 </div>
 <li>
  Organize the trade times and prices for each security into a dictionary.
  <div class="section-example-container">
   <pre class="python">class OrderData:
    def __init__(self):
        self.buy_fill_times = []
        self.buy_fill_prices = []
        self.sell_fill_times = []
        self.sell_fill_prices = []

order_data_by_symbol = {}
for order in orders:
    if order.Symbol not in order_data_by_symbol:
        order_data_by_symbol[order.Symbol] = OrderData()
    order_data = order_data_by_symbol[order.Symbol]
    is_buy = order.Quantity &gt; 0
    (order_data.buy_fill_times if is_buy else order_data.sell_fill_times).append(order.LastFillTime.date())
    (order_data.buy_fill_prices if is_buy else order_data.sell_fill_prices).append(order.Price)</pre>
  </div>
 </li>
 <li>
  Get the price history of each security you traded.
  <div class="section-example-container">
   <pre class="python">qb = QuantBook()
start_date = datetime.max.date()
end_date = datetime.min.date()
for symbol, order_data in order_data_by_symbol.items():
    start_date = min(start_date, min(order_data.buy_fill_times), min(order_data.sell_fill_times))
    end_date = max(end_date, max(order_data.buy_fill_times), max(order_data.sell_fill_times))
start_date -= timedelta(days=1)
all_history = qb.History(list(order_data_by_symbol.keys()), start_date, end_date, Resolution.Daily)</pre>
  </div>
 </li>
 <li>
  Create a candlestick plot for each security and annotate each plot with buy and sell markers.
  <div class="section-example-container">
   <pre class="python">import plotly.express as px
import plotly.graph_objects as go

for symbol, order_data in order_data_by_symbol.items():
    history = all_history.loc[symbol]

    # Plot security price candlesticks
    candlestick = go.Candlestick(x=history.index,
                                open=history['open'],
                                high=history['high'],
                                low=history['low'],
                                close=history['close'],
                                name='Price')
    layout = go.Layout(title=go.layout.Title(text=f'{symbol.Value} Trades'),
                    xaxis_title='Date',
                    yaxis_title='Price',
                    xaxis_rangeslider_visible=False,
                    height=600)
    fig = go.Figure(data=[candlestick], layout=layout)

    # Plot buys
    fig.add_trace(go.Scatter(
        x=order_data.buy_fill_times,
        y=order_data.buy_fill_prices,
        marker=go.scatter.Marker(color='aqua', symbol='triangle-up', size=10),
        mode='markers',
        name='Buys',
    ))

    # Plot sells
    fig.add_trace(go.Scatter(
        x=order_data.sell_fill_times,
        y=order_data.sell_fill_prices,
        marker=go.scatter.Marker(color='indigo', symbol='triangle-down', size=10),
        mode='markers',
        name='Sells',
    ))

fig.show()</pre>
  </div>
 </li>
 <img alt="Plot of AAPL price with buy/sell markers" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plot-backtest-trades-in-research-env-aapl.png"/>
 <img alt="Plot of SPY price with buy/sell markers" class="docs-image" src="https://cdn.quantconnect.com/i/tu/plot-backtest-trades-in-research-env-spy.png"/>
 <p>
  Note: The preceding plots only show the last fill of each trade. If your trade has partial fills, the plots only display the last fill.
 </p>
</ol>

<h3>Plot Metadata</h3>
<p>
 Follow these steps to plot the equity curve, benchmark, and drawdown of a live algorithm:
</p>
<ol>
 <li>
  Get the live algorithm instance.
 </li>
 <div class="section-example-container">
  <pre class="python">live_algorithm = api.ReadLiveAlgorithm(project_id, deploy_id)</pre>
 </div>
 <p>
  To get the project Id,
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/projects/getting-started#02-View-All-Projects">
   open the project in the Algorithm Lab
  </a>
  and check the URL. For example, the project Id of https://www.quantconnect.com/project/13946911 is 13946911.
 </p>
 <p>
  To get the deployment Id,
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/live-trading/results#12-View-All-Live-Projects">
   open a live result in the Algorithm Lab
  </a>
  and check its
  <a href="https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/backtesting/results#12-Logs">
   log file
  </a>
  . An example deployment Id is L-ac54ffadf4ca52efabcd1ac29e4735cf. If you have deployed the project multiple times, the log file has multiple deployment Ids. In this case, use the most recent Id.
 </p>
 <li>
  Get the results of the live algorithm.
 </li>
 <div class="section-example-container">
  <pre class="python">results = live_algorithm.LiveResults.Results</pre>
 </div>
 <li>
  Get the "Strategy Equity", "Drawdown", and "Benchmark"
  <code>
   Chart
  </code>
  objects.
 </li>
 <div class="section-example-container">
  <pre class="python">equity_chart = results.Charts["Strategy Equity"]
drawdown_chart = results.Charts["Drawdown"]
benchmark_chart = results.Charts["Benchmark"]</pre>
 </div>
 <li>
  Get the "Equity", "Equity Drawdown", and "Benchmark"
  <code>
   Series
  </code>
  from the preceding charts.
 </li>
 <div class="section-example-container">
  <pre class="python">equity = equity_chart.Series["Equity"].Values
drawdown = drawdown_chart.Series["Equity Drawdown"].Values
benchmark = benchmark_chart.Series["Benchmark"].Values</pre>
 </div>
 <li>
  Create a
  <code>
   pandas.DataFrame
  </code>
  from the series values.
 </li>
 <div class="section-example-container">
  <pre class="python">df = pd.DataFrame({
    "Equity": pd.Series({datetime.fromtimestamp(value.x): value.y for value in equity}),
    "Drawdown": pd.Series({datetime.fromtimestamp(value.x): value.y for value in drawdown}),
    "Benchmark": pd.Series({datetime.fromtimestamp(value.x): value.y for value in benchmark})
}).ffill()</pre>
 </div>
 <li>
  Plot the performance chart.
 </li>
 <div class="section-example-container">
  <pre class="python"># Create subplots to plot series on same/different plots
fig, ax = plt.subplots(2, 1, figsize=(12, 12), sharex=True, gridspec_kw={'height_ratios': [2, 1]})

# Plot the equity curve
ax[0].plot(df.index, df["Equity"])
ax[0].set_title("Strategy Equity Curve")
ax[0].set_ylabel("Portfolio Value ($)")

# Plot the benchmark on the same plot, scale by using another y-axis
ax2 = ax[0].twinx()
ax2.plot(df.index, df["Benchmark"], color="grey")
ax2.set_ylabel("Benchmark Price ($)", color="grey")

# Plot the drawdown on another plot
ax[1].plot(df.index, df["Drawdown"], color="red")
ax[1].set_title("Drawdown")
ax[1].set_xlabel("Time")
ax[1].set_ylabel("%")</pre>
 </div>
 <img alt="api-equity-curve" class="docs-image" src="https://cdn.quantconnect.com/i/tu/api-result-plot.png"/>
</ol>
<p>
 The following table shows all the chart series you can plot:
</p>
<table class="qc-table table">
 <thead>
  <tr>
   <th style="width: 20%">
    Chart
   </th>
   <th style="width: 20%">
    Series
   </th>
   <th style="width: 60%">
    Description
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td rowspan="2">
    Strategy Equity
   </td>
   <td>
    Equity
   </td>
   <td>
    Time series of the equity curve
   </td>
  </tr>
  <tr>
   <td>
    Daily Performance
   </td>
   <td>
    Time series of daily percentage change
   </td>
  </tr>
  <tr>
   <td>
    Capacity
   </td>
   <td>
    Strategy Capacity
   </td>
   <td>
    Time series of
    <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/key-concepts/glossary#08-capacity">
     strategy capacity
    </a>
    snapshots
   </td>
  </tr>
  <tr>
   <td>
    Drawdown
   </td>
   <td>
    Equity Drawdown
   </td>
   <td>
    Time series of equity peak-to-trough value
   </td>
  </tr>
  <tr>
   <td>
    Benchmark
   </td>
   <td>
    Benchmark
   </td>
   <td>
    Time series of the
    <a href="https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/initialization#11-Set-Benchmark">
     benchmark
    </a>
    closing price (SPY, by default)
   </td>
  </tr>
  <tr>
   <td rowspan="2">
    Exposure
   </td>
   <td>
    <span class="placeholder-text">
     SecurityType
    </span>
    - Long Ratio
   </td>
   <td>
    Time series of the overall ratio of
    <span class="placeholder-text">
     SecurityType
    </span>
    long positions of the whole portfolio if any
    <span class="placeholder-text">
     SecurityType
    </span>
    is ever in the universe
   </td>
  </tr>
  <tr>
   <td>
    <span class="placeholder-text">
     SecurityType
    </span>
    - Short Ratio
   </td>
   <td>
    Time series of the overall ratio of
    <span class="placeholder-text">
     SecurityType
    </span>
    short position of the whole portfolio if any
    <span class="placeholder-text">
     SecurityType
    </span>
    is ever in the universe
   </td>
  </tr>
  <tr>
   <td>
    Custom Chart
   </td>
   <td>
    Custom Series
   </td>
   <td>
    Time series of a
    <code>
     Series
    </code>
    in a
    <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/charting">
     custom chart
    </a>
   </td>
  </tr>
 </tbody>
</table>

<p style="page-break-after: always;">&nbsp;</p>
<section id="10"><h3>10 Applying Research</h3></section>

<section id="10.1"><h3>10.1 Key Concepts</h3></section>

<h3>Introduction</h3>
<p>
 The ultimate goal of research is to produce a strategy that you can backtest and eventually trade live. Once you've developed a hypothesis that you're confident in, you can start working towards exporting your research into backtesting. To export the code, you need to replace
 <code>
  QuantBook()
 </code>
 with
 <code>
  self
 </code>
 and replace the
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/key-concepts/research-engine#04-Your-Research-and-LEAN">
  QuantBook methods
 </a>
 with their
 <code>
  QCAlgorithm
 </code>
 counterparts.
</p>

<h3>Workflow</h3>
<p>
 Imagine that you've developed the following hypothesis: stocks that are below 1 standard deviation of their 30-day mean are due to revert and increase in value. The following Research Environment code picks out such stocks from a preselected basket of stocks:
</p>
<div class="section-example-container">
 <pre class="python">import numpy as np
qb = QuantBook()

symbols = {}
assets = ["SHY", "TLT", "SHV", "TLH", "EDV", "BIL",
"SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
"VGLT", "SCHO", "SCHR", "SPTS", "GOVT"]

for i in range(len(assets)):
    symbols[assets[i]] = qb.AddEquity(assets[i],Resolution.Minute).Symbol

# Fetch history on our universe
df = qb.History(qb.Securities.Keys, 30, Resolution.Daily)

# Make all of them into a single time index.
df = df.close.unstack(level=0)

# Calculate the truth value of the most recent price being less than 1 std away from the mean
classifier = df.le(df.mean().subtract(df.std())).tail(1)

# Get indexes of the True values
classifier_indexes = np.where(classifier)[1]

# Get the Symbols for the True values
classifier = classifier.transpose().iloc[classifier_indexes].index.values

# Get the std values for the True values (used for magnitude)
magnitude = df.std().transpose()[classifier_indexes].values

# Zip together to iterate over later
selected = zip(classifier, magnitude)
</pre>
</div>
<p>
 Once you are confident in your hypothesis, you can export this code into the backtesting environment. The algorithm will ultimately go long on the stocks that pass the classifier logic. One way to accommodate this model into a backtest is to create a
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/writing-algorithms/scheduled-events">
  Scheduled Event
 </a>
 that uses the model to pick stocks and place orders.
</p>
<div class="section-example-container">
 <pre class="python">def Initialize(self) -&gt; None:
    self.SetStartDate(2014, 1, 1)
    self.SetCash(1000000)
    self.SetBenchmark("SPY")
    
    self.SetPortfolioConstruction(EqualWeightingPortfolioConstructionModel())
    self.SetExecution(ImmediateExecutionModel())
    
    self.assets = ["IEF", "SHY", "TLT", "IEI", "SHV", "TLH", "EDV", "BIL",
                   "SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
                   "VGLT", "SCHO", "SCHR", "SPTS", "GOVT"]
    
    self.symbols = {}
    
    # Add Equity ------------------------------------------------ 
    for i in range(len(self.assets)):
        self.symbols[self.assets[i]] = self.AddEquity(self.assets[i], Resolution.Minute).Symbol 
        
    # Set the Scheduled Event method
    self.Schedule.On(self.DateRules.Every(DayOfWeek.Monday), self.TimeRules.AfterMarketOpen("IEF", 1), self.EveryDayAfterMarketOpen)
</pre>
</div>
<p>
 Now that the
 <code>
  Initialize
 </code>
 method of the algorithm is set, export the model into the Scheduled Event method. You just need to switch
 <code>
  qb
 </code>
 with
 <code>
  self
 </code>
 and replace
 <code>
  QuantBook
 </code>
 methods with their
 <code>
  QCAlgorithm
 </code>
 counterparts. In this example, you don't need to switch any methods because the model only uses methods that exist in
 <code>
  QCAlgorithm
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">def EveryDayAfterMarketOpen(self):
    qb = self
    # Fetch history on our universe
    df = qb.History(qb.Securities.Keys, 5, Resolution.Daily)
    
    # Make all of them into a single time index.
    df = df.close.unstack(level=0)
    
    # Calculate the truth value of the most recent price being less than 1 std away from the mean
    classifier = df.le(df.mean().subtract(df.std())).tail(1)
    
    # Get indexes of the True values
    classifier_indexes = np.where(classifier)[1]
    
    # Get the Symbols for the True values
    classifier = classifier.transpose().iloc[classifier_indexes].index.values
    
    # Get the std values for the True values (used for magnitude)
    magnitude = df.std().transpose()[classifier_indexes].values
    
    # Zip together to iterate over later
    selected = zip(classifier, magnitude)
    
    # ==============================
    
    insights = []
    
    for symbol, magnitude in selected:
        insights.append(Insight.Price(symbol, timedelta(days=5), InsightDirection.Up, magnitude))
    
    self.EmitInsights(insights)
</pre>
</div>
<p>
 With the Research Environment model now in the backtesting environment, you can further analyze its performance with its
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/backtesting/results">
  backtesting metrics
 </a>
 . If you are confident in the backtest, you can eventually live trade this strategy.
</p>
<p>
 To view full examples of this Research to Production workflow, see the examples in the menu.
</p>

<h3>Contribute Tutorials</h3>
<p>
 If you contribute Research to Production tutorials, you'll get the following benefits:
</p>
<ul>
 <li>
  A
  <a href="/https://www.quantconnect.com/docs/v2/docs/v2/cloud-platform/organizations/credit">
   QCC
  </a>
  reward
 </li>
 <li>
  You'll learn the Research to Production methodology to improve your own strategy research and development
 </li>
 <li>
  Your contribution will be featured in the community forum
 </li>
</ul>
<p>
 To view the topics the community wants Research to Production tutorials for, see
 <a href="https://github.com/QuantConnect/Research/labels/WishList">
  the issues with the WishList tag in the Research GitHub repository
 </a>
 . If you find a topic you want to create a tutorial for, make a pull request to the repository with your tutorial and we will review it.
</p>
<p>
 To request new tutorial topics,
 <a href="/https://www.quantconnect.com/docs/v2/contact">
  contact us
 </a>
 .
</p>

<p style="page-break-after: always;">&nbsp;</p>
<section id="10.2"><h3>10.2 Mean Reversion</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to you can use the Research Environment to develop and test a Mean Reversion hypothesis, then put the hypothesis in production.
</p>

<h3>Create Hypothesis</h3>
<p>
 Imagine that we've developed the following hypothesis: stocks that are below 1 standard deviation of their 30-day-mean are due to revert and increase in value, statistically around 85% chance if we assume the return series is stationary and the price series is a Random Process. We've developed the following code in research to pick out such stocks from a preselected basket of stocks.
</p>

<h3>Import Libraries</h3>
<p class="csharp">
 Load the required assembly files and data types.
</p>
<p class="python">
 We'll need to import libraries to help with data processing. Import
 <code>
  numpy
 </code>
 and
 <code>
  scipy
 </code>
 libraries by the following:
</p>
<div class="section-example-container">
 <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Data.Market;
using QuantConnect.Algorithm;
using QuantConnect.Research;
using System;
using MathNet.Numerics.Distributions;</pre>
 <pre class="python">import numpy as np
from scipy.stats import norm, zscore</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 To begin, we retrieve historical data for researching.
</p>
<ol>
 <li>
  Instantiate a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Select the desired tickers for research.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var assets = new List&lt;string&gt;() {"SHY", "TLT", "SHV", "TLH", "EDV", "BIL",
                  "SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
                  "VGLT", "SCHO", "SCHR", "SPTS", "GOVT"};</pre>
  <pre class="python">assets = ["SHY", "TLT", "SHV", "TLH", "EDV", "BIL",
          "SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
          "VGLT", "SCHO", "SCHR", "SPTS", "GOVT"]</pre>
 </div>
 <li>
  Call the
  <code>
   AddEquity
  </code>
  method with the tickers, and their corresponding resolution.
 </li>
 <div class="section-example-container">
  <pre class="csharp">foreach(var ticker in assets){
    qb.AddEquity(ticker, Resolution.Minute);
}</pre>
  <pre class="python">for i in range(len(assets)):
    qb.AddEquity(assets[i],Resolution.Minute)</pre>
 </div>
 <p>
  If you do not pass a resolution argument,
  <code>
   Resolution.Minute
  </code>
  is used by default.
 </p>
 <li>
  Call the
  <code>
   History
  </code>
  method with
  <code>
   qb.Securities.Keys
  </code>
  for all tickers, time argument(s), and resolution to request historical data for the symbol.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var history = qb.History(qb.Securities.Keys, new DateTime(2021, 1, 1), new DateTime(2021, 12, 31), Resolution.Daily);</pre>
  <pre class="python">history = qb.History(qb.Securities.Keys, datetime(2021, 1, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
 </div>
 <img alt="Historical data" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/mean-reversion-2022-data.png"/>
</ol>

<h3>Prepare Data</h3>
<p>
 We'll have to process our data to get an extent of the signal on how much the stock is deviated from its norm for each ticker.
</p>
<ol>
 <li class="csharp">
  Extract close prices for each
  <code>
   Symbol
  </code>
  from
  <code>
   Slice
  </code>
  data.
 </li>
 <li class="python">
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var closes = new Dictionary&lt;Symbol, List&lt;Decimal&gt;&gt;();
foreach(var slice in history){
    foreach(var symbol in slice.Keys){
        if(!closes.ContainsKey(symbol)){
            closes.Add(symbol, new List&lt;Decimal&gt;());
        }
        closes[symbol].Add(slice.Bars[symbol].Close);
    }
}</pre>
  <pre class="python">df = history['close'].unstack(level=0)</pre>
 </div>
 <li class="csharp">
  Get the 30-day rolling mean, standard deviation series, z-score and filtration for each
  <code>
   Symbol
  </code>
  .
 </li>
 <li class="python">
  Calculate the truth value of the most recent price being less than 1 standard deviation away from the mean price.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var rollingMean = new Dictionary&lt;Symbol, List&lt;double&gt;&gt;();
var rollingStd = new Dictionary&lt;Symbol, List&lt;double&gt;&gt;();
var filter = new Dictionary&lt;Symbol, List&lt;bool&gt;&gt;();
var zScore = new Dictionary&lt;Symbol, List&lt;double&gt;&gt;();
foreach(var kvp in closes)
{
    var symbol = kvp.Key;
    if(!rollingMean.ContainsKey(symbol)){
        rollingMean.Add(symbol, new List&lt;double&gt;());
        rollingStd.Add(symbol, new List&lt;double&gt;());
        zScore.Add(symbol, new List&lt;double&gt;());
        filter.Add(symbol, new List&lt;bool&gt;());
    }
    for (int i=30; i &lt; closes.Values.ElementAt(0).Count; i++)
    {
        var slice = kvp.Value.Skip(i).Take(30);
        rollingMean[symbol].Add(decimal.ToDouble(slice.Average()));
        rollingStd[symbol].Add(Math.Sqrt(slice.Average(v =&gt; Math.Pow(decimal.ToDouble(v-slice.Average()), 2))));
        zScore[symbol].Add((decimal.ToDouble(closes[symbol][i]) - rollingMean[symbol].Last()) / rollingStd[symbol].Last());
        filter[symbol].Add(zScore[symbol].Last() &lt; -1);
    }
}</pre>
  <pre class="python">classifier = df.le(df.rolling(30).mean() - df.rolling(30).std())</pre>
 </div>
 <li class="csharp">
  Calculate the expected return and its probability, then calculate the weight.
 </li>
 <li class="python">
  Get the z-score for the True values, then compute the expected return and probability (used for Insight magnitude and confidence).
 </li>
 <div class="section-example-container">
  <pre class="csharp">var magnitude = new Dictionary&lt;Symbol, List&lt;double&gt;&gt;();
var confidence = new Dictionary&lt;Symbol, List&lt;double&gt;&gt;();
var weights = new Dictionary&lt;Symbol, List&lt;double&gt;&gt;();
foreach(var kvp in rollingMean)
{
    var symbol = kvp.Key;
    if(!magnitude.ContainsKey(symbol)){
        magnitude.Add(symbol, new List&lt;double&gt;());
        confidence.Add(symbol, new List&lt;double&gt;());
        weights.Add(symbol, new List&lt;double&gt;());
    }
    for (int i=1; i &lt; rollingMean.Values.ElementAt(0).Count; i++)
    {
        magnitude[symbol].Add(-zScore[symbol][i] * rollingStd[symbol][i] / decimal.ToDouble(closes[symbol][i-1]));
        confidence[symbol].Add(Normal.CDF(0, 1, -zScore[symbol][i]));
        // Filter if trade or not
        var trade = filter[symbol][i] ? 1d : 0d;
        weights[symbol].Add(trade * Math.Max(confidence[symbol].Last() - 1 / (magnitude[symbol].Last() + 1), 0));
    }
}</pre>
  <pre class="python">z_score = df.apply(zscore)[classifier]
magnitude = -z_score * df.rolling(30).std() / df.shift(1)
confidence = (-z_score).apply(norm.cdf)</pre>
 </div>
 <li class="csharp">
  Convert the weights into 2-d array.
 </li>
 <li class="python">
  Call
  <code>
   fillna
  </code>
  to fill NaNs with 0.
 </li>
 <div class="section-example-container">
  <pre class="csharp">double[,] weight = new double[weights.Values.ElementAt(0).Count, weights.Count];
int j = 0;
foreach(var symbol in weights.Keys){
    for(int i=0; i &lt; weights[symbol].Count; i++){
        weight[i, j] = weights[symbol][i];
    }
    j++;
}</pre>
  <pre class="python">magnitude.fillna(0, inplace=True)
confidence.fillna(0, inplace=True)</pre>
 </div>
 <li>
  Get our trading weight, we'd take a long only portfolio and normalized to total weight = 1.
 </li>
 <div class="section-example-container">
  <pre class="csharp">public double[,] Normalize(double[,] array)
{
    for(int i=0; i &lt; array.GetLength(0); i++)
    {
        var sum = 0.0;
        for (int j=0; j &lt; array.GetLength(1); j++)
        {
            sum += array[i, j];
        }
        if (sum == 0.0) continue;
        for (int j=0; j &lt; array.GetLength(1); j++)
        {
            array[i, j] = array[i, j] / sum;
        }
    }
    
    return array;
}
weight = Normalize(weight);</pre>
  <pre class="python">weight = confidence - 1 / (magnitude + 1)
weight = weight[weight &gt; 0].fillna(0)
sum_ = np.sum(weight, axis=1)
for i in range(weight.shape[0]):
    if sum_[i] &gt; 0:
        weight.iloc[i] = weight.iloc[i] / sum_[i]
    else:
        weight.iloc[i] = 0
weight = weight.iloc[:-1]</pre>
 </div>
</ol>

<h3>Test Hypothesis</h3>
<p>
 We would test the performance of this strategy. To do so, we would make use of the calculated weight for portfolio optimization.
</p>
<ol>
 <li class="csharp">
  Convert close price to 2-d array.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">double[,] close = new double[closes.Values.ElementAt(0).Count, closes.Count];
int j = 0;
foreach(var symbol in closes.Keys){
    for(int i=0; i &lt; closes[symbol].Count; i++){
        close[i, j] = decimal.ToDouble(closes[symbol][i]);
    }
    j++;
}</pre>
 </div>
 <li>
  Get the total daily return series.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var totalValue = new List&lt;double&gt;{1.0};
var dailySum = 0.0;
for(int i=0; i &lt; weight.GetLength(0) - 1; i++)
{
    totalValue.Add(totalValue.Last() * (1 + dailySum));
    dailySum = 0.0;
    for (int j=0; j &lt; weight.GetLength(1); j++)
    {
        if (close[i, j] != 0 &amp;&amp; double.IsFinite(close[i+1, j]) &amp;&amp; double.IsFinite(close[i, j]) &amp;&amp; double.IsFinite(weight[i, j]))
        {
            dailySum += weight[i, j] * (close[i+1, j] - close[i, j]) / close[i, j];
        }
    }
}</pre>
  <pre class="python">ret = pd.Series(index=range(df.shape[0] - 1))
for i in range(df.shape[0] - 1):
    ret[i] = weight.iloc[i] @ df.pct_change().iloc[i + 1].T</pre>
 </div>
 <li class="python">
  Call
  <code>
   cumprod
  </code>
  to get the cumulative return.
 </li>
 <div class="python section-example-container">
  <pre class="python">total_ret = (ret + 1).cumprod()</pre>
 </div>
 <li class="python">
  Set index for visualization.
 </li>
 <div class="python section-example-container">
  <pre class="python">total_ret.index = weight.index</pre>
 </div>
 <li>
  Display the result.
 </li>
 <div class="section-example-container">
  <pre class="csharp">for(int i=0; i &lt; totalValue.Count; i=i+5)
{
    Console.WriteLine("Portfolio Value in Day{0}: {1}", i, totalValue[i]);
}</pre>
  <pre class="python">total_ret.plot(title='Strategy Equity Curve', figsize=(15, 10))
plt.show()</pre>
 </div>
 <img alt="Mean reversion results" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/mean-reversion-2022-cs-result.png"/>
 <img alt="Mean reversion equity line plot" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/mean-reversion-2022-plot.png"/>
</ol>

<h3>Set Up Algorithm</h3>
<p>
 Once we are confident in our hypothesis, we can export this code into backtesting. One way to accomodate this model into research is to create a scheduled event which uses our model to pick stocks and goes long.
</p>
<div class="section-example-container">
 <pre class="csharp">private List&lt;string&gt; _asset = new List&lt;string&gt;{"SHY", "TLT", "IEI", "SHV", "TLH", "EDV", "BIL",
        "SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
        "VGLT", "SCHO", "SCHR", "SPTS", "GOVT"};
        
public override void Initialize()
{
    // 1. Required: Five years of backtest history
    SetStartDate(2014, 1, 1);

    // 2. Required: Alpha Streams Models:
    SetBrokerageModel(BrokerageName.AlphaStreams);

    // 3. Required: Significant AUM Capacity
    SetCash(1000000);

    // 4. Required: Benchmark to SPY
    SetBenchmark("SPY");

    SetPortfolioConstruction(new InsightWeightingPortfolioConstructionModel());
    SetExecution(new ImmediateExecutionModel());

    // Add Equity ------------------------------------------------ 
    foreach(var ticker in _asset)
    {
    AddEquity(ticker, Resolution.Minute);
    }

    // Set Scheduled Event Method For Our Model
    Schedule.On(DateRules.EveryDay(), 
        TimeRules.BeforeMarketClose("SHY", 5),
        EveryDayBeforeMarketClose);
}</pre>
 <pre class="python">def Initialize(self) -&gt; None:

    #1. Required: Five years of backtest history
    self.SetStartDate(2014, 1, 1)

    #2. Required: Alpha Streams Models:
    self.SetBrokerageModel(BrokerageName.AlphaStreams)

    #3. Required: Significant AUM Capacity
    self.SetCash(1000000)

    #4. Required: Benchmark to SPY
    self.SetBenchmark("SPY")
    
    self.SetPortfolioConstruction(InsightWeightingPortfolioConstructionModel())
    self.SetExecution(ImmediateExecutionModel())

    self.assets = ["SHY", "TLT", "IEI", "SHV", "TLH", "EDV", "BIL",
                    "SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
                    "VGLT", "SCHO", "SCHR", "SPTS", "GOVT"]
    
    # Add Equity ------------------------------------------------ 
    for i in range(len(self.assets)):
        self.AddEquity(self.assets[i], Resolution.Minute)
    
    # Set Scheduled Event Method For Our Model
    self.Schedule.On(self.DateRules.EveryDay(), self.TimeRules.BeforeMarketClose("SHY", 5), self.EveryDayBeforeMarketClose)</pre>
</div>
<p class="csharp">
 Now we export our model into the scheduled event method. We will remove
 <code>
  qb
 </code>
 and replace methods with their
 <code>
  QCAlgorithm
 </code>
 counterparts as needed. In this example, this is not an issue because all the methods we used in research also exist in
 <code>
  QCAlgorithm
 </code>
 .
</p>
<p class="python">
 Now we export our model into the scheduled event method. We will switch
 <code>
  qb
 </code>
 with
 <code>
  self
 </code>
 and replace methods with their
 <code>
  QCAlgorithm
 </code>
 counterparts as needed. In this example, this is not an issue because all the methods we used in research also exist in
 <code>
  QCAlgorithm
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">private void EveryDayBeforeMarketClose()
{
    // Fetch history on our universe
    var history = History(Securities.Keys, 30, Resolution.Daily);
    if (history.Count() &lt; 0) return;
    
    // Extract close prices for each Symbol from Slice data
    var closes = new Dictionary&lt;Symbol, List&lt;Decimal&gt;&gt;();
    foreach(var slice in history){
        foreach(var symbol in slice.Keys){
            if(!closes.ContainsKey(symbol)){
                closes.Add(symbol, new List&lt;Decimal&gt;());
            }
            closes[symbol].Add(slice.Bars[symbol].Close);
        }
    }
    
    // Get the 30-day rolling mean, standard deviation series, z-score and filtration for each Symbol
    var rollingMean = new Dictionary&lt;string, double&gt;();
    var rollingStd = new Dictionary&lt;string, double&gt;();
    var filter = new Dictionary&lt;string, bool&gt;();
    var zScore = new Dictionary&lt;string, double&gt;();
    foreach(var kvp in closes)
    {
        var symbol = kvp.Key;
        if(!rollingMean.ContainsKey(symbol)){
            rollingMean.Add(symbol, decimal.ToDouble(kvp.Value.Average()));
            rollingStd.Add(symbol, Math.Sqrt(kvp.Value.Average(v =&gt; Math.Pow(decimal.ToDouble(v-kvp.Value.Average()), 2))));
            zScore.Add(symbol, (decimal.ToDouble(kvp.Value.Last()) - rollingMean[symbol]) / rollingStd[symbol]);
            filter.Add(symbol, zScore[symbol] &lt; -1);
        }
    }
    
    // Calculate the expected return and its probability, then calculate the weight
    var magnitude = new Dictionary&lt;Symbol, double&gt;();
    var confidence = new Dictionary&lt;Symbol, double&gt;();
    var weights = new Dictionary&lt;Symbol, double&gt;();
    foreach(var kvp in rollingMean)
    {
        var symbol = kvp.Key;
        if(!magnitude.ContainsKey(symbol)){
            magnitude.Add(symbol, -zScore[symbol] * rollingStd[symbol] / decimal.ToDouble(closes[symbol].Last()));
            confidence.Add(symbol, Normal.CDF(0, 1, -zScore[symbol]));
            // Filter if trade or not
            var trade = filter[symbol] ? 1d : 0d;
            weights.Add(symbol, trade * Math.Max(confidence[symbol] - 1 / (magnitude[symbol] + 1), 0));
        }
    }
    
    // Normalize the weights, then emit insights
    var sum = weights.Sum(x =&gt; x.Value);
    if (sum == 0) return;
    
    foreach(var kvp in weights)
    {
        var symbol = kvp.Key;
        weights[symbol] = kvp.Value / sum;
        
        var insight = new Insight(symbol, TimeSpan.FromDays(1), InsightType.Price, InsightDirection.Up, magnitude[symbol], confidence[symbol], null, weights[symbol]);
        EmitInsights(insight);
    }
}</pre>
 <pre class="python">def EveryDayBeforeMarketClose(self) -&gt; None:
    qb = self
    # Fetch history on our universe
    df = qb.History(qb.Securities.Keys, 30, Resolution.Daily)
    if df.empty: return

    # Make all of them into a single time index.
    df = df.close.unstack(level=0)

    # Calculate the truth value of the most recent price being less than 1 std away from the mean
    classifier = df.le(df.mean().subtract(df.std())).iloc[-1]
    if not classifier.any(): return

    # Get the z-score for the True values, then compute the expected return and probability
    z_score = df.apply(zscore)[[classifier.index[i] for i in range(classifier.size) if classifier.iloc[i]]]

    magnitude = -z_score * df.std() / df
    confidence = (-z_score).apply(norm.cdf)

    # Get the latest values
    magnitude = magnitude.iloc[-1].fillna(0)
    confidence = confidence.iloc[-1].fillna(0)

    # Get the weights, then zip together to iterate over later
    weight = confidence - 1 / (magnitude + 1)
    weight = weight[weight &gt; 0].fillna(0)
    sum_ = np.sum(weight)
    if sum_ &gt; 0:
        weight = (weight) / sum_
        selected = zip(weight.index, magnitude, confidence, weight)
    else:
        return

    # ==============================
    
    insights = []
    
    for symbol, magnitude, confidence, weight in selected:
        insights.append( Insight.Price(symbol, timedelta(days=1), InsightDirection.Up, magnitude, confidence, None, weight) )

    self.EmitInsights(insights)</pre>
</div>

<h3>Clone Example Project</h3>
<div class="python">
 <div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
  <div class="qc-embed-dummy" style="padding-top: 56.25%;">
  </div>
  <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
   <iframe class="qc-embed-backtest" height="100%" src="https://www.quantconnect.com/terminal/processCache/embedded_backtest_2a3ba604f7c87d56319c6cd628a11b59.html" style="border: 1px solid #ccc; padding: 0; margin: 0;" width="100%">
   </iframe>
  </div>
 </div>
</div>
<div class="csharp">
 <div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
  <div class="qc-embed-dummy" style="padding-top: 56.25%;">
  </div>
  <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
   <iframe class="qc-embed-backtest" height="100%" src="https://www.quantconnect.com/terminal/processCache/embedded_backtest_9c741b7682468eecd59c87be466a6507.html" style="border: 1px solid #ccc; padding: 0; margin: 0;" width="100%">
   </iframe>
  </div>
 </div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="10.3"><h3>10.3 Random Forest Regression</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to you can use the Research Environment to develop and test a Random Forest Regression hypothesis, then put the hypothesis in production.
</p>

<h3>Create Hypothesis</h3>
<p>
 We've assumed the price data is a time series with some auto regressive property (i.e. its expectation is related to past price information). Therefore, by using past information, we could predict the next price level. One way to do so is by Random Forest Regression, which is a supervised machine learning algorithm where its weight and bias is decided in non-linear hyperdimension.
</p>

<h3>Import Libraries</h3>
<p>
 We'll need to import libraries to help with data processing and machine learning. Import
 <code>
  sklearn
 </code>
 ,
 <code>
  numpy
 </code>
 and
 <code>
  matplotlib
 </code>
 libraries by the following:
</p>
<div class="section-example-container">
 <pre class="python">from sklearn.ensemble import RandomForestRegressor
import numpy as np
from matplotlib import pyplot as plt</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 To begin, we retrieve historical data for researching.
</p>
<ol>
 <li>
  Instantiate a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Select the desired tickers for research.
 </li>
 <div class="section-example-container">
  <pre class="python">symbols = {}
assets = ["SHY", "TLT", "SHV", "TLH", "EDV", "BIL",
          "SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
          "VGLT", "SCHO", "SCHR", "SPTS", "GOVT"]</pre>
 </div>
 <li>
  Call the
  <code>
   AddEquity
  </code>
  method with the tickers, and their corresponding resolution. Then store their
  <code>
   Symbol
  </code>
  s.
 </li>
 <div class="section-example-container">
  <pre class="python">for i in range(len(assets)):
    symbols[assets[i]] = qb.AddEquity(assets[i],Resolution.Minute).Symbol</pre>
 </div>
 <p>
  If you do not pass a resolution argument,
  <code>
   Resolution.Minute
  </code>
  is used by default.
 </p>
 <li>
  Call the
  <code>
   History
  </code>
  method with
  <code>
   qb.Securities.Keys
  </code>
  for all tickers, time argument(s), and resolution to request historical data for the symbol.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(qb.Securities.Keys, datetime(2019, 1, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
 </div>
 <img alt="Historical data" class="docs-image" src="https://cdn.quantconnect.com/i/tu/rfr-2022-data.png"/>
</ol>

<h3>Prepare Data</h3>
<p>
 We'll have to process our data as well as to build the ML model before testing the hypothesis. Our methodology is to use fractional differencing close price as the input data in order to (1) provide stationarity, and (2) retain sufficient extent of variance of the previous price information. We assume d=0.5 is the right balance to do so.
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">df = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Feature engineer the data as fractional differencing for input.
 </li>
 <div class="section-example-container">
  <pre class="python">input_ = df.diff() * 0.5 + df * 0.5
input_ = input_.iloc[1:]</pre>
 </div>
 <li>
  Shift the data for 1-step backward as training output result.
 </li>
 <div class="section-example-container">
  <pre class="python">output = df.shift(-1).iloc[:-1]</pre>
 </div>
 <li>
  Split the data into training and testing sets.
 </li>
 <div class="section-example-container">
  <pre class="python">splitter = int(input_.shape[0] * 0.8)
X_train = input_.iloc[:splitter]
X_test = input_.iloc[splitter:]
y_train = output.iloc[:splitter]
y_test = output.iloc[splitter:]</pre>
 </div>
 <li>
  Initialize a Random Forest Regressor.
 </li>
 <div class="section-example-container">
  <pre class="python">regressor = RandomForestRegressor(n_estimators=100, min_samples_split=5, random_state = 1990)</pre>
 </div>
 <li>
  Fit the regressor.
 </li>
 <div class="section-example-container">
  <pre class="python">regressor.fit(X_train, y_train)</pre>
 </div>
</ol>

<h3>Test Hypothesis</h3>
<p>
 We would test the performance of this ML model to see if it could predict 1-step forward price precisely. To do so, we would compare the predicted and actual prices.
</p>
<ol>
 <li>
  Predict the testing set.
 </li>
 <div class="section-example-container">
  <pre class="python">predictions = regressor.predict(X_test)</pre>
 </div>
 <li>
  Convert result into
  <code>
   DataFrame
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">predictions = pd.DataFrame(predictions, index=y_test.index, columns=y_test.columns)</pre>
 </div>
 <li>
  Plot the result for comparison.
 </li>
 <div class="section-example-container">
  <pre class="python">for col in y_test.columns:
    plt.figure(figsize=(15, 10))

    y_test[col].plot(label="Actual")
    predictions[col].plot(label="Prediction")

    plt.title(f"{col} Regression Result")
    plt.legend()
    plt.show()
    plt.clf()</pre>
 </div>
 <img alt="Random forest regression EDV result" class="docs-image" src="https://cdn.quantconnect.com/i/tu/rfr-2022-plot-1.png"/>
 <img alt="Random forest regression GOVT result" class="docs-image" src="https://cdn.quantconnect.com/i/tu/rfr-2022-plot-2.png"/>
 <img alt="Random forest regression SCHO result" class="docs-image" src="https://cdn.quantconnect.com/i/tu/rfr-2022-plot-3.png"/>
 <p>
  For more plots, please
  <a href="#10-Clone-Example-Project">
   clone the project
  </a>
  and run the notebook.
 </p>
</ol>

<h3>Set Up Algorithm</h3>
<p>
 Once we are confident in our hypothesis, we can export this code into backtesting. One way to accomodate this model into backtest is to create a scheduled event which uses our model to predict the expected return. Since we could calculate the expected return, we'd use Mean-Variance Optimization for portfolio construction.
</p>
<div class="section-example-container">
 <pre class="python">def Initialize(self) -&gt; None:

    #1. Required: Five years of backtest history
    self.SetStartDate(2014, 1, 1)

    #2. Required: Alpha Streams Models:
    self.SetBrokerageModel(BrokerageName.AlphaStreams)

    #3. Required: Significant AUM Capacity
    self.SetCash(1000000)

    #4. Required: Benchmark to SPY
    self.SetBenchmark("SPY")
    
    self.SetPortfolioConstruction(MeanVarianceOptimizationPortfolioConstructionModel(portfolioBias = PortfolioBias.Long,
                                                                                    period=252))
    self.SetExecution(ImmediateExecutionModel())

    self.assets = ["SHY", "TLT", "IEI", "SHV", "TLH", "EDV", "BIL",
                    "SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
                    "VGLT", "SCHO", "SCHR", "SPTS", "GOVT"]
    
    # Add Equity ------------------------------------------------ 
    for i in range(len(self.assets)):
        self.AddEquity(self.assets[i], Resolution.Minute)
        
    # Initialize the timer to train the Machine Learning model
    self.time = datetime.min
    
    # Set Scheduled Event Method For Our Model
    self.Schedule.On(self.DateRules.EveryDay(), self.TimeRules.BeforeMarketClose("SHY", 5), self.EveryDayBeforeMarketClose)</pre>
</div>
<p>
 We'll also need to create a function to train and update our model from time to time.
</p>
<div class="section-example-container">
 <pre class="python">def BuildModel(self) -&gt; None:
    # Initialize the Random Forest Regressor
    self.regressor = RandomForestRegressor(n_estimators=100, min_samples_split=5, random_state = 1990)
    
    # Get historical data
    history = self.History(self.Securities.Keys, 360, Resolution.Daily)
    
    # Select the close column and then call the unstack method.
    df = history['close'].unstack(level=0)
    
    # Feature engineer the data for input.
    input_ = df.diff() * 0.5 + df * 0.5
    input_ = input_.iloc[1:].ffill().fillna(0)
    
    # Shift the data for 1-step backward as training output result.
    output = df.shift(-1).iloc[:-1].ffill().fillna(0)
    
    # Fit the regressor
    self.regressor.fit(input_, output)</pre>
</div>
<p>
 Now we export our model into the scheduled event method. We will switch
 <code>
  qb
 </code>
 with
 <code>
  self
 </code>
 and replace methods with their
 <code>
  QCAlgorithm
 </code>
 counterparts as needed. In this example, this is not an issue because all the methods we used in research also exist in
 <code>
  QCAlgorithm
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">def EveryDayBeforeMarketClose(self) -&gt; None:
    # Retrain the regressor every month
    if self.time &lt; self.Time:
        self.BuildModel()
        self.time = Expiry.EndOfMonth(self.Time)
    
    qb = self
    # Fetch history on our universe
    df = qb.History(qb.Securities.Keys, 2, Resolution.Daily)
    if df.empty: return

    # Make all of them into a single time index.
    df = df.close.unstack(level=0)

    # Feature engineer the data for input
    input_ = df.diff() * 0.5 + df * 0.5
    input_ = input_.iloc[-1].fillna(0).values.reshape(1, -1)
    
    # Predict the expected price
    predictions = self.regressor.predict(input_)
    
    # Get the expected return
    predictions = (predictions - df.iloc[-1].values) / df.iloc[-1].values
    predictions = predictions.flatten()

    # ==============================
    
    insights = []
    
    for i in range(len(predictions)):
        insights.append( Insight.Price(self.assets[i], timedelta(days=1), InsightDirection.Up, predictions[i]) )

    self.EmitInsights(insights)</pre>
</div>

<h3>Clone Example Project</h3>
<div class="python">
 <div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
  <div class="qc-embed-dummy" style="padding-top: 56.25%;">
  </div>
  <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
   <iframe class="qc-embed-backtest" height="100%" src="https://www.quantconnect.com/terminal/processCache/embedded_backtest_37fbeb5de9c6c4e58e283053fbe29a69.html" style="border: 1px solid #ccc; padding: 0; margin: 0;" width="100%">
   </iframe>
  </div>
 </div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="10.4"><h3>10.4 Uncorrelated Assets</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to you can use the Research Environment to develop and test a Uncorrelated Assets hypothesis, then put the hypothesis in production.
</p>

<h3>Create Hypothesis</h3>
<p>
 According to Modern Portfolio Thoery, asset combinations with negative or very low correlation could have lower total portfolio variance given the same level of return. Thus, uncorrelated assets allows you to find a portfolio that will, theoretically, be more diversified and resilient to extreme market events. We're testing this statement in real life scenario, while hypothesizing a portfolio with uncorrelated assets could be a consistent portfolio. In this example, we'll compare the performance of 5-least-correlated-asset portfolio (proposed) and 5-most-correlated-asset portfolio (benchmark), both equal weighting.
</p>

<h3>Import Libraries</h3>
<p class="csharp">
 Load the required assembly files and data types.
</p>
<p class="python">
 We'll need to import libraries to help with data processing and visualization. Import
 <code>
  numpy
 </code>
 and
 <code>
  matplotlib
 </code>
 libraries by the following:
</p>
<div class="section-example-container">
 <pre class="csharp">#load "../Initialize.csx"
#load "../QuantConnect.csx"

using QuantConnect;
using QuantConnect.Data;
using QuantConnect.Data.Market;
using QuantConnect.Algorithm;
using QuantConnect.Research;
using System;
using System.Linq;
using Accord.Statistics;</pre>
 <pre class="python">import numpy as np
from matplotlib import pyplot as plt</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 To begin, we retrieve historical data for researching.
</p>
<ol>
 <li>
  Instantiate a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="csharp">var qb = new QuantBook();</pre>
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Select the desired tickers for research.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var assets = new List&lt;string&gt;() {"SHY", "TLT", "SHV", "TLH", "EDV", "BIL",
                  "SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
                  "VGLT", "SCHO", "SCHR", "SPTS", "GOVT"};</pre>
  <pre class="python">assets = ["SHY", "TLT", "SHV", "TLH", "EDV", "BIL",
          "SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
          "VGLT", "SCHO", "SCHR", "SPTS", "GOVT"]</pre>
 </div>
 <li>
  Call the
  <code>
   AddEquity
  </code>
  method with the tickers, and their corresponding resolution.
 </li>
 <div class="section-example-container">
  <pre class="csharp">foreach(var ticker in assets){
    qb.AddEquity(ticker, Resolution.Minute);
}</pre>
  <pre class="python">for i in range(len(assets)):
    qb.AddEquity(assets[i],Resolution.Minute)</pre>
 </div>
 <p>
  If you do not pass a resolution argument,
  <code>
   Resolution.Minute
  </code>
  is used by default.
 </p>
 <li>
  Call the
  <code>
   History
  </code>
  method with
  <code>
   qb.Securities.Keys
  </code>
  for all tickers, time argument(s), and resolution to request historical data for the symbol.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var history = qb.History(qb.Securities.Keys, new DateTime(2021, 1, 1), new DateTime(2021, 12, 31), Resolution.Daily);</pre>
  <pre class="python">history = qb.History(qb.Securities.Keys, datetime(2021, 1, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
 </div>
 <img alt="Historical data" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/uncorrelated-assets-2022-data.png"/>
</ol>

<h3>Prepare Data</h3>
<p>
 We'll have to process our data to get their correlation and select the least and most related ones.
</p>
<ol>
 <li class="csharp">
  Extract daily return for each
  <code>
   Symbol
  </code>
  from
  <code>
   Slice
  </code>
  data.
 </li>
 <li class="python">
  Select the close column and then call the
  <code>
   unstack
  </code>
  method, then call
  <code>
   pct_change
  </code>
  to compute the daily return.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var returns = new Dictionary&lt;string, List&lt;Double&gt;&gt;();
var last = new Dictionary&lt;string, Double&gt;();
foreach(var slice in history){
    foreach(var symbol in slice.Bars.Keys){
        if(!returns.ContainsKey(symbol)){
            returns.Add(symbol, new List&lt;Double&gt;());
            last.Add(symbol, (Double)slice.Bars[symbol].Close);
        }
        var change = (Double) ((Double)slice.Bars[symbol].Close - last[symbol])/last[symbol];
        last[symbol] = (Double)slice.Bars[symbol].Close;
        returns[symbol].Add(change);
    }    
}</pre>
  <pre class="python">returns = history['close'].unstack(level=0).pct_change().iloc[1:]</pre>
 </div>
 <li class="csharp">
  Extract daily return for each
  <code>
   Symbol
  </code>
  from
  <code>
   Slice
  </code>
  data.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">double[,] ret = new double[returns.Values.ElementAt(0).Count - 1, assets.Count];
int k = 0;
foreach(var kvp in returns)
{
    var symbol = kvp.Key;
    for(int i=0; i &lt; returns[symbol].Count - 1; i++)
    {
        ret[i, k] = returns[symbol][i + 1];
    }
    k++;
}</pre>
 </div>
 <li>
  Write a function to obtain the least and most correlated 5 assets.
 </li>
 <div class="section-example-container">
  <pre class="csharp">public Dictionary&lt;string, Double&gt; GetCorrelations(double[,] returns){
    // Get correlation matrix
    var corrMatrix = Measures.Correlation(ret);
    
    // Find the absolute sum correlation of the assets
    var correlations = new Dictionary&lt;string, Double&gt;();
    for(int i=0; i &lt; corrMatrix.GetLength(0); i++)
    {
        var symbol = assets[i];
        if(!correlations.ContainsKey(symbol)){
            correlations.Add(symbol, 0);
        }
        for (int j=0; j &lt; corrMatrix.GetLength(1); j++)
        {
            var value_ = corrMatrix[i, j];
            correlations[symbol] += value_ &gt;= 0 ? value_ : -value_;
        }
    }
    
    return correlations;
}

var corr = GetCorrelations(ret);
var selected = corr.OrderBy(x =&gt; x.Value).Take(5);
var benchmark = corr.OrderBy(x =&gt; x.Value).TakeLast(5);</pre>
  <pre class="python">def GetUncorrelatedAssets(returns, num_assets):
    # Get correlation
    correlation = returns.corr()
    
    # Find assets with lowest and highest absolute sum correlation
    selected = []
    for index, row in correlation.iteritems():
        corr_rank = row.abs().sum()
        selected.append((index, corr_rank))

    # Sort and take the top num_assets
    sort_ = sorted(selected, key = lambda x: x[1])
    uncorrelated = sort_[:num_assets]
    correlated = sort_[-num_assets:]
    
    return uncorrelated, correlated

selected, benchmark = GetUncorrelatedAssets(returns, 5)</pre>
 </div>
 <img alt="uncorrelated assets equity curve" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/uncorrelated-assets-2022-selection.png"/>
</ol>

<h3>Test Hypothesis</h3>
<p>
 To test the hypothesis: Our desired outcome would be a consistent and low fluctuation equity curve should be seen, as compared with benchmark.
</p>
<ol>
 <li>
  Construct a equal weighting portfolio for the 5-uncorrelated-asset-portfolio and the 5-correlated-asset-portfolio (benchmark).
 </li>
 <div class="section-example-container">
  <pre class="csharp">double[,] portRet = new double[returns.Values.ElementAt(0).Count, 5];
int j = 0;
foreach(var kvp in selected){
    var symbol = kvp.Key;
    for(int i=0; i &lt; returns[symbol].Count; i++)
    {
        portRet[i, j] = returns[symbol][i] / 5;
    }
    j++;
}

double[,] benchRet = new double[returns.Values.ElementAt(0).Count, 5];
j = 0;
foreach(var kvp in benchmark){
    var symbol = kvp.Key;
    for(int i=0; i &lt; returns[symbol].Count; i++)
    {
        benchRet[i, j] = returns[symbol][i] / 5;
    }
    j++;
}</pre>
  <pre class="python">port_ret = returns[[x[0] for x in selected]] / 5
bench_ret = returns[[x[0] for x in benchmark]] / 5</pre>
 </div>
 <li class="csharp">
  Get the Equity Return for both portfolios.
 </li>
 <li class="python">
  Call
  <code>
   cumprod
  </code>
  to get the cumulative return.
 </li>
 <div class="section-example-container">
  <pre class="csharp">var totalValue = new List&lt;double&gt;{1.0};
var dailySum = 0.0;
for(int i=0; i &lt; portRet.GetLength(0); i++)
{
    totalValue.Add(totalValue.Last() * (1 + dailySum));
    dailySum = 0.0;
    for (int j=0; j &lt; portRet.GetLength(1); j++)
    {
        if (double.IsFinite(portRet[i, j]))
        {
            dailySum += portRet[i, j];
        }
    }
}

var totalValueBench = new List&lt;double&gt;{1.0};
var dailySumBench = 0.0;
for(int i=0; i &lt; benchRet.GetLength(0); i++)
{
    totalValueBench.Add(totalValueBench.Last() * (1 + dailySumBench));
    dailySumBench = 0.0;
    for (int j=0; j &lt; benchRet.GetLength(1); j++)
    {
        if (double.IsFinite(benchRet[i, j]))
        {
            dailySumBench += benchRet[i, j];
        }
    }
}</pre>
  <pre class="python">total_ret = (np.sum(port_ret, axis=1) + 1).cumprod()
total_ret_bench = (np.sum(bench_ret, axis=1) + 1).cumprod()</pre>
 </div>
 <li class="csharp">
  Calculate the variance of the 2 portfolios.
 </li>
 <div class="csharp section-example-container">
  <pre class="csharp">var returnPort = new List&lt;double&gt;();
previous = 0.0;
for(int i=0; i &lt; totalValue.Count; i++)
{
    var current = totalValue[i];
    returnPort.Add((current - previous) / previous);
    previous = current;
}
var varPort = Math.Sqrt(returnPort.Skip(1).Average(v=&gt;Math.Pow(v-returnPort.Skip(1).Average(),2)));

var returnBench = new List&lt;double&gt;();
previous = 0.0;
for(int i=0; i &lt; totalValueBench.Count; i++)
{
    var current = totalValueBench[i];
    returnBench.Add((current - previous) / previous);
    previous = current;
}
var varBench = Math.Sqrt(returnBench.Skip(1).Average(v=&gt;Math.Pow(v-returnBench.Skip(1).Average(),2)));</pre>
 </div>
 <li class="csharp">
  Print the result.
 </li>
 <li class="python">
  Plot the result.
 </li>
 <div class="section-example-container">
  <pre class="csharp">Console.WriteLine("Portfolio Return: {0}, Variance: {1}", (totalValue.Last() - totalValue.First())/totalValue.First(), varPort);
Console.WriteLine("Benchmark Return: {0}, Variance: {1}", (totalValueBench.Last() - totalValueBench.First())/totalValueBench.First(), varBench);</pre>
  <pre class="python">plt.figure(figsize=(15, 10))
total_ret.plot(label='Proposed')
total_ret_bench.plot(label='Benchmark')
plt.title('Equity Curve')
plt.legend()
plt.show()</pre>
 </div>
 <img alt="Uncorrelated assets result" class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/uncorrelated-assets-2022-cs-result.png"/>
 <img alt="Uncorrelated assets equity curve" class="python docs-image" src="https://cdn.quantconnect.com/i/tu/uncorrelated-assets-2022-plot.png"/>
</ol>
-image
<p>
 We can clearly see from the results, the proposed uncorrelated-asset-portfolio has a lower variance/fluctuation, thus more consistent than the benchmark. This proven our hypothesis.
</p>

<h3>Set Up Algorithm</h3>
<p>
 Once we are confident in our hypothesis, we can export this code into backtesting. One way to accomodate this model into research is to create a scheduled event which uses our model to pick stocks and goes long.
</p>
<div class="section-example-container">
 <pre class="csharp">private List&lt;string&gt; _asset = new List&lt;string&gt;{"SHY", "TLT", "IEI", "SHV", "TLH", "EDV", "BIL",
        "SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
        "VGLT", "SCHO", "SCHR", "SPTS", "GOVT"};
        
public override void Initialize()
{
    // 1. Required: Five years of backtest history
    SetStartDate(2014, 1, 1);

    // 2. Required: Alpha Streams Models:
    SetBrokerageModel(BrokerageName.AlphaStreams);

    // 3. Required: Significant AUM Capacity
    SetCash(1000000);

    // 4. Required: Benchmark to SPY
    SetBenchmark("SPY");

    SetPortfolioConstruction(new EqualWeightingPortfolioConstructionModel());
    SetExecution(new ImmediateExecutionModel());

    // Add Equity ------------------------------------------------ 
    foreach(var ticker in _asset)
    {
    AddEquity(ticker, Resolution.Minute);
    }

    // Set Scheduled Event Method For Our Model. In this example, we'll rebalance every month.
    Schedule.On(DateRules.MonthStart(), 
        TimeRules.BeforeMarketClose("SHY", 5),
        EveryDayBeforeMarketClose);
}</pre>
 <pre class="python">def Initialize(self) -&gt; None:

    #1. Required: Five years of backtest history
    self.SetStartDate(2014, 1, 1)

    #2. Required: Alpha Streams Models:
    self.SetBrokerageModel(BrokerageName.AlphaStreams)

    #3. Required: Significant AUM Capacity
    self.SetCash(1000000)

    #4. Required: Benchmark to SPY
    self.SetBenchmark("SPY")
    
    self.SetPortfolioConstruction(EqualWeightingPortfolioConstructionModel())
    self.SetExecution(ImmediateExecutionModel())

    self.assets = ["SHY", "TLT", "IEI", "SHV", "TLH", "EDV", "BIL",
                    "SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
                    "VGLT", "SCHO", "SCHR", "SPTS", "GOVT"]
    
    # Add Equity ------------------------------------------------ 
    for i in range(len(self.assets)):
        self.AddEquity(self.assets[i], Resolution.Minute)
    
    # Set Scheduled Event Method For Our Model. In this example, we'll rebalance every month.
    self.Schedule.On(self.DateRules.MonthStart(), 
        self.TimeRules.BeforeMarketClose("SHY", 5), 
        self.EveryDayBeforeMarketClose)</pre>
</div>
<p class="csharp">
 Now we export our model into the scheduled event method. We will remove
 <code>
  qb
 </code>
 and replace methods with their
 <code>
  QCAlgorithm
 </code>
 counterparts as needed. In this example, this is not an issue because all the methods we used in research also exist in
 <code>
  QCAlgorithm
 </code>
 .
</p>
<p class="python">
 Now we export our model into the scheduled event method. We will switch
 <code>
  qb
 </code>
 with
 <code>
  self
 </code>
 and replace methods with their
 <code>
  QCAlgorithm
 </code>
 counterparts as needed. In this example, this is not an issue because all the methods we used in research also exist in
 <code>
  QCAlgorithm
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="csharp">private void EveryDayBeforeMarketClose()
{
    // Fetch history on our universe
    var history = History(Securities.Keys, 252*2, Resolution.Daily);
    if (history.Count() &lt; 0) return;
    
    // Extract daily return of close prices for each Symbol from Slice data
    var returns = new Dictionary&lt;string, List&lt;Double&gt;&gt;();
    var last = new Dictionary&lt;string, Double&gt;();
    foreach(var slice in history){
        foreach(var symbol in slice.Bars.Keys){
            if(!returns.ContainsKey(symbol)){
                returns.Add(symbol, new List&lt;Double&gt;());
                last.Add(symbol, (Double)slice.Bars[symbol].Close);
            }
            var change = (Double) ((Double)slice.Bars[symbol].Close - last[symbol])/last[symbol];
            last[symbol] = (Double)slice.Bars[symbol].Close;
            returns[symbol].Add(change);
        }    
    }
    
    // Convert returns into 2-d array
    double[,] ret = new double[returns.Values.ElementAt(0).Count - 1, _asset.Count];
    int k = 0;
    foreach(var kvp in returns)
    {
        var symbol = kvp.Key;
        for(int i=0; i &lt; returns[symbol].Count - 1; i++)
        {
            ret[i, k] = returns[symbol][i + 1];
        }
        k++;
    }
    
    // Get correlation matrix
    var corrMatrix = Measures.Correlation(ret);
    
    // Find 5 assets with the least absolute sum correlation
    var correlations = new Dictionary&lt;string, Double&gt;();
    for(int i=0; i &lt; corrMatrix.GetLength(0); i++)
    {
        var symbol = _asset[i];
        if(!correlations.ContainsKey(symbol)){
            correlations.Add(symbol, 0);
        }
        for (int j=0; j &lt; corrMatrix.GetLength(1); j++)
        {
            var value_ = corrMatrix[i, j];
            correlations[symbol] += value_ &gt;= 0 ? value_ : -value_;
        }
    }
    var selected = correlations.OrderBy(x =&gt; x.Value).Take(5).Select(x =&gt; x.Key).ToList();
    
    // Emit insights
    foreach(var symbol in selected)
    {
        var insight = new Insight(symbol, Expiry.EndOfMonth, InsightType.Price, InsightDirection.Up);
        EmitInsights(insight);
    }
}</pre>
 <pre class="python">def EveryDayBeforeMarketClose(self) -&gt; None:
    qb = self
    # Fetch history on our universe
    history = qb.History(qb.Securities.Keys, 252*2, Resolution.Daily)
    if history.empty: return

    # Select the close column and then call the unstack method, then call pct_change to compute the daily return.
    returns = history['close'].unstack(level=0).pct_change().iloc[1:]

    # Get correlation
    correlation = returns.corr()
    
    # Find 5 assets with lowest absolute sum correlation
    selected = []
    for index, row in correlation.iteritems():
        corr_rank = row.abs().sum()
        selected.append((index, corr_rank))

    sort_ = sorted(selected, key = lambda x: x[1])
    selected = [x[0] for x in sort_[:5]]

    # ==============================
    
    insights = []
    
    for symbol in selected:
        insights.append( Insight.Price(symbol, Expiry.EndOfMonth, InsightDirection.Up) )

    self.EmitInsights(insights)</pre>
</div>

<h3>Clone Example Project</h3>
<div class="python">
 <div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
  <div class="qc-embed-dummy" style="padding-top: 56.25%;">
  </div>
  <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
   <iframe class="qc-embed-backtest" height="100%" src="https://www.quantconnect.com/terminal/processCache/embedded_backtest_be9cae46fd96f085a703ca9b0d6ee8a1.html" style="border: 1px solid #ccc; padding: 0; margin: 0;" width="100%">
   </iframe>
  </div>
 </div>
</div>
<div class="csharp">
 <div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
  <div class="qc-embed-dummy" style="padding-top: 56.25%;">
  </div>
  <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
   <iframe class="qc-embed-backtest" height="100%" src="https://www.quantconnect.com/terminal/processCache/embedded_backtest_66c280b48ca8c6c7b21f9892982ed496.html" style="border: 1px solid #ccc; padding: 0; margin: 0;" width="100%">
   </iframe>
  </div>
 </div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="10.5"><h3>10.5 Kalman Filters and Stat Arb</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to you can use the Research Environment to develop and test a Kalman Filters and Statistical Arbitrage hypothesis, then put the hypothesis in production.
</p>

<h3>Create Hypothesis</h3>
<p>
 In finance, we can often observe that 2 stocks with similar background and fundamentals (e.g. AAPL vs MSFT, SPY vs QQQ) move in similar manner. They could be correlated, although not necessary, but their price difference/sum (spread) is stationary. We call this cointegration. Thus, we could hypothesize that extreme spread could provide chance for arbitrage, just like a mean reversion of spread. This is known as pairs trading. Likewise, this could also be applied to more than 2 assets, this is known as statistical arbitrage.
 <br/>
 <br/>
 However, although the fluctuation of the spread is stationary, the mean of the spread could be changing by time due to different reasons. Thus, it is important to update our expectation on the spread in order to go in and out of the market in time, as the profit margin of this type of short-window trading is tight. Kalman Filter could come in handy in this situation. We can consider it as an updater of the underlying return Markov Chain's expectation, while we're assuming the price series is a Random Process.
 <br/>
 <br/>
 In this example, we're making a hypothesis on trading the spread on cointegrated assets is profitable. We'll be using forex pairs EURUSD, GBPUSD, USDCAD, USDHKD and USDJPY for this example, skipping the normalized price difference selection.
</p>

<h3>Import Libraries</h3>
<p>
 We'll need to import libraries to help with data processing, model building, validation and visualization. Import
 <code>
  arch
 </code>
 ,
 <code>
  pykalman
 </code>
 ,
 <code>
  scipy
 </code>
 ,
 <code>
  statsmodels
 </code>
 ,
 <code>
  numpy
 </code>
 ,
 <code>
  matplotlib
 </code>
 and
 <code>
  pandas
 </code>
 libraries by the following:
</p>
<div class="section-example-container">
 <pre class="python">from arch.unitroot.cointegration import engle_granger
from pykalman import KalmanFilter
from scipy.optimize import minimize
from statsmodels.tsa.vector_ar.vecm import VECM

import numpy as np
from matplotlib import pyplot as plt
from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 To begin, we retrieve historical data for researching.
</p>
<ol>
 <li>
  Instantiate a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Select the desired tickers for research.
 </li>
 <div class="section-example-container">
  <pre class="python">assets = ["EURUSD", "GBPUSD", "USDCAD", "USDHKD", "USDJPY"]</pre>
 </div>
 <li>
  Call the
  <code>
   AddForex
  </code>
  method with the tickers, and their corresponding resolution. Then store their
  <code>
   Symbol
  </code>
  s.
 </li>
 <div class="section-example-container">
  <pre class="python">for i in range(len(assets)):
    qb.AddForex(assets[i],Resolution.Minute)</pre>
 </div>
 <p>
  If you do not pass a resolution argument,
  <code>
   Resolution.Minute
  </code>
  is used by default.
 </p>
 <li>
  Call the
  <code>
   History
  </code>
  method with
  <code>
   qb.Securities.Keys
  </code>
  for all tickers, time argument(s), and resolution to request historical data for the symbol.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(qb.Securities.Keys, datetime(2021, 1, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
 </div>
 <img alt="Historical data" class="docs-image" src="https://cdn.quantconnect.com/i/tu/kalman-filter-stat-arb-2022-data.png"/>
</ol>

<h3>Cointegration</h3>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<p>
 We'll have to test if the assets are cointegrated. If so, we'll have to obtain the cointegration vector(s).
</p>
<h4>
 Cointegration Testing
</h4>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">df = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call
  <code>
   np.log
  </code>
  to convert the close price into log-price series to eliminate compounding effect.
 </li>
 <div class="section-example-container">
  <pre class="python">log_price = np.log(data)</pre>
 </div>
 <li>
  Apply Engle Granger Test to check if the series are cointegrated.
 </li>
 <div class="section-example-container">
  <pre class="python">coint_result = engle_granger(log_price.iloc[:, 0], log_price.iloc[:, 1:], trend='n', method='bic')</pre>
 </div>
 <img alt="Cointegration test result" class="docs-image" src="https://cdn.quantconnect.com/i/tu/kalman-filter-stat-arb-2022-egt.png"/>
 <p>
  It shows a p-value &lt; 0.05 for the unit test, with lag-level 0. This proven the log price series are cointegrated in realtime. The spread of the 5 forex pairs are stationary.
 </p>
</ol>
<h4>
 Get Cointegration Vectors
</h4>
<p>
 We would use a VECM model to obtain the cointegrated vectors.
</p>
<ol>
 <li>
  Initialize a
  <code>
   VECM
  </code>
  model by following the unit test parameters, then fit to our data.
 </li>
 <div class="section-example-container">
  <pre class="python">vecm_result = VECM(log_price, k_ar_diff=0, coint_rank=len(assets)-1, deterministic='n').fit()</pre>
 </div>
 <li>
  Obtain the
  <code>
   Beta
  </code>
  attribute. This is the cointegration subspaces' unit vectors.
 </li>
 <div class="section-example-container">
  <pre class="python">beta = vecm_result.beta</pre>
 </div>
 <li>
  Check the spread of different cointegration subspaces.
 </li>
 <div class="section-example-container">
  <pre class="python">spread = log_price @ beta</pre>
 </div>
 <li>
  Plot the results.
 </li>
 <div class="section-example-container">
  <pre class="python">fig, axs = plt.subplots(beta.shape[1], figsize=(15, 15))
fig.suptitle('Spread for various cointegrating vectors')
for i in range(beta.shape[1]):
    axs[i].plot(spread.iloc[:, i])
    axs[i].set_title(f"The {i+1}th normalized cointegrating subspace")
plt.show()</pre>
 </div>
 <img alt="Each cointegration subspace spread series" class="docs-image" src="https://cdn.quantconnect.com/i/tu/kalman-filter-stat-arb-2022-coint-subspaces.png"/>
</ol>
<h4>
 Optimization of Cointegration Subspaces
</h4>
<p>
 Although the 4 cointegratoin subspaces are not looking stationarym, we can optimize for a mean-reverting portfolio by putting various weights in different subspaces. We use the Portmanteau statistics as a proxy for the mean reversion. So we formulate:
</p>
$$\begin{equation*}
\begin{aligned}
&amp; \underset{w}{\text{minimize}}
&amp; &amp; \mathrm (\frac {w^{T}M_{1}w} {w^{T}M_{0}w}) ^{2} \\
&amp; \text{subject to}
&amp; &amp; w^{T}M_{0}w = \nu\\
&amp;&amp;&amp; 1^Tw = 0\\
&amp; \text{where}
&amp; &amp; M_i \triangleq Cov(s_t, s_{t+i}) = E[(s_t - E[s_t]) (s_{t+i} - E[s_{t+i}])^T] \\
\end{aligned}
\end{equation*}$$
<p>
 with s is spread, v is predetermined desirable variance level (the larger the higher the profit, but lower the trading frequency)
</p>
<ol>
 <li>
  We set the weight on each vector is between -1 and 1. While overall sum is 0.
 </li>
 <div class="section-example-container">
  <pre class="python">x0 = np.array([-1**i/beta.shape[1] for i in range(beta.shape[1])])
bounds = tuple((-1, 1) for i in range(beta.shape[1]))
constraints = [{'type':'eq', 'fun':lambda x: np.sum(x)}]</pre>
 </div>
 <li>
  Optimize the Portmanteau statistics.
 </li>
 <div class="section-example-container">
  <pre class="python">opt = minimize(lambda w: ((w.T @ np.cov(spread.T, spread.shift(1).fillna(0).T)[spread.shape[1]:, :spread.shape[1]] @ w)/(w.T @ np.cov(spread.T) @ w))**2,
               x0=x0,
               bounds=bounds,
               constraints=constraints,
               method="SLSQP")</pre>
 </div>
 <li>
  Normalize the result.
 </li>
 <div class="section-example-container">
  <pre class="python">opt.x = opt.x/np.sum(abs(opt.x))
for i in range(len(opt.x)):
    print(f"The weight put on {i+1}th normalized cointegrating subspace: {opt.x[i]}")</pre>
 </div>
 <li>
  Plot the weighted spread.
 </li>
 <div class="section-example-container">
  <pre class="python">new_spread = spread @ opt.x
new_spread.plot(title="Weighted spread", figsize=(15, 10))
plt.ylabel("Spread")
plt.show()</pre>
 </div>
 <img alt="Spread series from optimized cointegration subspaces weighting" class="docs-image" src="https://cdn.quantconnect.com/i/tu/kalman-filter-stat-arb-2022-weighted-spread.png"/>
</ol>

<h3>Kalman Filter</h3>
<p>
 The weighted spread looks more stationary. However, the fluctuation half-life is very long accrossing zero. We aim to trade as much as we can to maximize the profit of this strategy. Kalman Filter then comes into the play. It could modify the expectation of the next step based on smoothening the prediction and actual probability distribution of return.
</p>
<img alt="Kalman filter" class="docs-image" src="https://cdn.quantconnect.com/i/tu/kalman-filter-explained.jpg"/>
<p>
 <i>
  Image Source: Understanding Kalman Filters, Part 3: An Optimal State Estimator. Melda Ulusoy (2017). MathWorks. Retreived from: https://www.mathworks.com/videos/understanding-kalman-filters-part-3-optimal-state-estimator--1490710645421.html
 </i>
</p>
<ol>
 <li>
  Initialize a
  <code>
   KalmanFilter
  </code>
  .
 </li>
 <p>
  In this example, we use the first 20 data points to optimize its initial state. We assume the market has no regime change so that the transitional matrix and observation matrix is [1].
 </p>
 <div class="section-example-container">
  <pre class="python">kalmanFilter = KalmanFilter(transition_matrices = [1],
                  observation_matrices = [1],
                  initial_state_mean = new_spread.iloc[:20].mean(),
                  observation_covariance = new_spread.iloc[:20].var(),
                  em_vars=['transition_covariance', 'initial_state_covariance'])
kalmanFilter = kalmanFilter.em(new_spread.iloc[:20], n_iter=5)
(filtered_state_means, filtered_state_covariances) = kalmanFilter.filter(new_spread.iloc[:20])</pre>
 </div>
 <li>
  Obtain the current Mean and Covariance Matrix expectations.
 </li>
 <div class="section-example-container">
  <pre class="python">currentMean = filtered_state_means[-1, :]
currentCov = filtered_state_covariances[-1, :]</pre>
 </div>
 <li>
  Initialize a mean series for spread normalization using the
  <code>
   KalmanFilter
  </code>
  's results.
 </li>
 <div class="section-example-container">
  <pre class="python">mean_series = np.array([None]*(new_spread.shape[0]-100))</pre>
 </div>
 <li>
  Roll over the Kalman Filter to obtain the mean series.
 </li>
 <div class="section-example-container">
  <pre class="python">for i in range(100, new_spread.shape[0]):
    (currentMean, currentCov) = kalmanFilter.filter_update(filtered_state_mean = currentMean,
                                                           filtered_state_covariance = currentCov,
                                                           observation = new_spread.iloc[i])
    mean_series[i-100] = float(currentMean)</pre>
 </div>
 <li>
  Obtain the normalized spread series.
 </li>
 <div class="section-example-container">
  <pre class="python">normalized_spread = (new_spread.iloc[100:] - mean_series)</pre>
 </div>
 <li>
  Plot the normalized spread series.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.figure(figsize=(15, 10))
plt.plot(normalized_spread, label="Processed spread")
plt.title("Normalized spread series")
plt.ylabel("Spread - Expectation")
plt.legend()
plt.show()</pre>
 </div>
 <img alt="Kalman filter normalized spread" class="docs-image" src="https://cdn.quantconnect.com/i/tu/kalman-filter-stat-arb-2022-normalized-spread.png"/>
</ol>

<h3>Determine Trading Threshold</h3>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<p>
 Now we need to determine the threshold of entry. We want to maximize profit from each trade (variance of spread) x frequency of entry. To do so, we formulate:
</p>
$$\begin{equation*}
\begin{aligned}
&amp; \underset{f}{\text{minimize}}
&amp; &amp; \begin{Vmatrix}
\bar{f} - f
\end{Vmatrix}_{2}^{2} + \lambda\ \begin{Vmatrix}Df\end{Vmatrix}_{2}^{2} \\
&amp; \text{where}
&amp; &amp; \bar{f_j} = \frac{\sum_{t=1}^T 1_{\{spread_t\ &gt;\ set\ level_j\}}}{T}\\
&amp;&amp;&amp; D = \begin{bmatrix}
1 &amp; -1 &amp; &amp; &amp;\\
&amp; 1 &amp; -1 &amp; &amp;\\
&amp;  &amp; \ddots &amp; \ddots &amp; \\
&amp;  &amp;  &amp; 1 &amp; -1
\end{bmatrix} 
\in \mathbb{R}^{(j - 1) \times j}\\
\end{aligned}
\end{equation*}$$
<p>
 so $f^* = (I+\lambda D^TD)^{-1}\bar{f}$
</p>
<ol>
 <li>
  Initialize 50 set levels for testing.
 </li>
 <div class="section-example-container">
  <pre class="python">s0 = np.linspace(0, max(normalized_spread), 50)</pre>
 </div>
 <li>
  Calculate the profit levels using the 50 set levels.
 </li>
 <div class="section-example-container">
  <pre class="python">f_bar = np.array([None]*50)
for i in range(50):
    f_bar[i] = len(normalized_spread.values[normalized_spread.values &gt; s0[i]]) / normalized_spread.shape[0]</pre>
 </div>
 <li>
  Set trading frequency matrix.
 </li>
 <div class="section-example-container">
  <pre class="python">D = np.zeros((49, 50))
for i in range(D.shape[0]):
    D[i, i] = 1
    D[i, i+1] = -1</pre>
 </div>
 <li>
  Set level of lambda.
 </li>
 <div class="section-example-container">
  <pre class="python">l = 1.0</pre>
 </div>
 <li>
  Obtain the normalized profit level.
 </li>
 <div class="section-example-container">
  <pre class="python">f_star = np.linalg.inv(np.eye(50) + l * D.T@D) @ f_bar.reshape(-1, 1)
s_star = [f_star[i]*s0[i] for i in range(50)]</pre>
 </div>
 <li>
  Get the maximum profit level as threshold.
 </li>
 <div class="section-example-container">
  <pre class="python">threshold = s0[s_star.index(max(s_star))]
print(f"The optimal threshold is {threshold}")</pre>
 </div>
 <li>
  Plot the result.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.figure(figsize=(15, 10))
plt.plot(s0, s_star)
plt.title("Profit of mean-revertion trading")
plt.xlabel("Threshold")
plt.ylabel("Profit")
plt.show()</pre>
 </div>
 <img alt="Optimized trading entry threshold" class="docs-image" src="https://cdn.quantconnect.com/i/tu/kalman-filter-stat-arb-2022-threshold.png"/>
</ol>

<h3>Test Hypothesis</h3>
<p>
 To test the hypothesis. We wish to obtain a profiting strategy.
</p>
<ol>
 <li>
  Set the trading weight. We would like the portfolio absolute total weight is 1 when trading.
 </li>
 <div class="section-example-container">
  <pre class="python">trading_weight = beta @ opt.x
trading_weight /= np.sum(abs(trading_weight))</pre>
 </div>
 <li>
  Set up the trading data.
 </li>
 <div class="section-example-container">
  <pre class="python">testing_ret = data.pct_change().iloc[1:].shift(-1)   # Shift 1 step backward as forward return result
equity = pd.DataFrame(np.ones((testing_ret.shape[0], 1)), index=testing_ret.index, columns=["Daily value"])</pre>
 </div>
 <li>
  Set the buy and sell preiod when the spread exceeds the threshold.
 </li>
 <div class="section-example-container">
  <pre class="python">buy_period = normalized_spread[normalized_spread &lt; -threshold].index
sell_period = normalized_spread[normalized_spread &gt; threshold].index</pre>
 </div>
 <li>
  Trade the portfolio.
 </li>
 <div class="section-example-container">
  <pre class="python">equity.loc[buy_period, "Daily value"] = testing_ret.loc[buy_period] @ trading_weight + 1
equity.loc[sell_period, "Daily value"] = testing_ret.loc[sell_period] @ -trading_weight + 1</pre>
 </div>
 <li>
  Get the total portfolio value.
 </li>
 <div class="section-example-container">
  <pre class="python">value = equity.cumprod()</pre>
 </div>
 <li>
  Plot the result.
 </li>
 <div class="section-example-container">
  <pre class="python">value.plot(title="Equity Curve", figsize=(15, 10))
plt.ylabel("Portfolio Value")
plt.show()</pre>
 </div>
 <img alt="Kalman filter stat arb equity curve" class="docs-image" src="https://cdn.quantconnect.com/i/tu/kalman-filter-stat-arb-2022-plot.png"/>
</ol>

<h3>Set Up Algorithm</h3>
<p>
 Once we are confident in our hypothesis, we can export this code into backtesting. One way to accomodate this model into backtest is to create a scheduled event which uses our model to predict the expected return.
</p>
<div class="section-example-container">
 <pre class="python">def Initialize(self) -&gt; None:

    #1. Required: Five years of backtest history
    self.SetStartDate(2014, 1, 1)

    #2. Required: Alpha Streams Models:
    self.SetBrokerageModel(BrokerageName.AlphaStreams)

    #3. Required: Significant AUM Capacity
    self.SetCash(1000000)

    #4. Required: Benchmark to SPY
    self.SetBenchmark("SPY")

    self.assets = ["EURUSD", "GBPUSD", "USDCAD", "USDHKD", "USDJPY"]
    
    # Add Equity ------------------------------------------------ 
    for i in range(len(self.assets)):
        self.AddForex(self.assets[i], Resolution.Minute)
        
    # Instantiate our model
    self.Recalibrate()
    
    # Set a variable to indicate the trading bias of the portfolio
    self.state = 0
    
    # Set Scheduled Event Method For Recalibrate Our Model Every Week.
    self.Schedule.On(self.DateRules.WeekStart(), 
        self.TimeRules.At(0, 0), 
        self.Recalibrate)
    
    # Set Scheduled Event Method For Kalman Filter updating.
    self.Schedule.On(self.DateRules.EveryDay(), 
        self.TimeRules.BeforeMarketClose("EURUSD"), 
        self.EveryDayBeforeMarketClose)</pre>
</div>
<p>
 We'll also need to create a function to train and update our model from time to time. We will switch
 <code>
  qb
 </code>
 with
 <code>
  self
 </code>
 and replace methods with their
 <code>
  QCAlgorithm
 </code>
 counterparts as needed. In this example, this is not an issue because all the methods we used in research also exist in
 <code>
  QCAlgorithm
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">def Recalibrate(self) -&gt; None:
    qb = self
    history = qb.History(self.assets, 252*2, Resolution.Daily)
    if history.empty: return
    
    # Select the close column and then call the unstack method
    data = history['close'].unstack(level=0)
    
    # Convert into log-price series to eliminate compounding effect
    log_price = np.log(data)
    
    ### Get Cointegration Vectors
    # Initialize a VECM model following the unit test parameters, then fit to our data.
    vecm_result = VECM(log_price, k_ar_diff=0, coint_rank=len(self.assets)-1, deterministic='n').fit()
    
    # Obtain the Beta attribute. This is the cointegration subspaces' unit vectors.
    beta = vecm_result.beta
    
    # Check the spread of different cointegration subspaces.
    spread = log_price @ beta
    
    ### Optimization of Cointegration Subspaces
    # We set the weight on each vector is between -1 and 1. While overall sum is 0.
    x0 = np.array([-1**i/beta.shape[1] for i in range(beta.shape[1])])
    bounds = tuple((-1, 1) for i in range(beta.shape[1]))
    constraints = [{'type':'eq', 'fun':lambda x: np.sum(x)}]
    
    # Optimize the Portmanteau statistics
    opt = minimize(lambda w: ((w.T @ np.cov(spread.T, spread.shift(1).fillna(0).T)[spread.shape[1]:, :spread.shape[1]] @ w)/(w.T @ np.cov(spread.T) @ w))**2,
                    x0=x0,
                    bounds=bounds,
                    constraints=constraints,
                    method="SLSQP")
    
    # Normalize the result
    opt.x = opt.x/np.sum(abs(opt.x))
    new_spread = spread @ opt.x
    
    ### Kalman Filter
    # Initialize a Kalman Filter. Using the first 20 data points to optimize its initial state. We assume the market has no regime change so that the transitional matrix and observation matrix is [1].
    self.kalmanFilter = KalmanFilter(transition_matrices = [1],
                        observation_matrices = [1],
                        initial_state_mean = new_spread.iloc[:20].mean(),
                        observation_covariance = new_spread.iloc[:20].var(),
                        em_vars=['transition_covariance', 'initial_state_covariance'])
    self.kalmanFilter = self.kalmanFilter.em(new_spread.iloc[:20], n_iter=5)
    (filtered_state_means, filtered_state_covariances) = self.kalmanFilter.filter(new_spread.iloc[:20])
    
    # Obtain the current Mean and Covariance Matrix expectations.
    self.currentMean = filtered_state_means[-1, :]
    self.currentCov = filtered_state_covariances[-1, :]
    
    # Initialize a mean series for spread normalization using the Kalman Filter's results.
    mean_series = np.array([None]*(new_spread.shape[0]-20))
    
    # Roll over the Kalman Filter to obtain the mean series.
    for i in range(20, new_spread.shape[0]):
        (self.currentMean, self.currentCov) = self.kalmanFilter.filter_update(filtered_state_mean = self.currentMean,
                                                                filtered_state_covariance = self.currentCov,
                                                                observation = new_spread.iloc[i])
        mean_series[i-20] = float(self.currentMean)
    
    # Obtain the normalized spread series.
    normalized_spread = (new_spread.iloc[20:] - mean_series)
    
    ### Determine Trading Threshold
    # Initialize 50 set levels for testing.
    s0 = np.linspace(0, max(normalized_spread), 50)
    
    # Calculate the profit levels using the 50 set levels.
    f_bar = np.array([None]*50)
    for i in range(50):
        f_bar[i] = len(normalized_spread.values[normalized_spread.values &gt; s0[i]]) \
            / normalized_spread.shape[0]
        
    # Set trading frequency matrix.
    D = np.zeros((49, 50))
    for i in range(D.shape[0]):
        D[i, i] = 1
        D[i, i+1] = -1
        
    # Set level of lambda.
    l = 1.0
    
    # Obtain the normalized profit level.
    f_star = np.linalg.inv(np.eye(50) + l * D.T@D) @ f_bar.reshape(-1, 1)
    s_star = [f_star[i]*s0[i] for i in range(50)]
    self.threshold = s0[s_star.index(max(s_star))]
    
    # Set the trading weight. We would like the portfolio absolute total weight is 1 when trading.
    trading_weight = beta @ opt.x
    self.trading_weight = trading_weight / np.sum(abs(trading_weight))</pre>
</div>
<p>
 Now we export our model into the scheduled event method for trading. We will switch
 <code>
  qb
 </code>
 with
 <code>
  self
 </code>
 and replace methods with their
 <code>
  QCAlgorithm
 </code>
 counterparts as needed. In this example, this is not an issue because all the methods we used in research also exist in
 <code>
  QCAlgorithm
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">def EveryDayBeforeMarketClose(self) -&gt; None:
    qb = self
    
    # Get the real-time log close price for all assets and store in a Series
    series = pd.Series()
    for symbol in qb.Securities.Keys:
        series[symbol] = np.log(qb.Securities[symbol].Close)
        
    # Get the spread
    spread = series @ self.trading_weight
    
    # Update the Kalman Filter with the Series
    (self.currentMean, self.currentCov) = self.kalmanFilter.filter_update(filtered_state_mean = self.currentMean,
                                                                        filtered_state_covariance = self.currentCov,
                                                                        observation = spread)
        
    # Obtain the normalized spread.
    normalized_spread = spread - self.currentMean

    # ==============================
    
    # Mean-reversion
    if normalized_spread &lt; -self.threshold:
        orders = []
        for i in range(len(self.assets)):
            orders.append(PortfolioTarget(self.assets[i], self.trading_weight[i]))
            self.SetHoldings(orders)
            
        self.state = 1
            
    elif normalized_spread &gt; self.threshold:
        orders = []
        for i in range(len(self.assets)):
            orders.append(PortfolioTarget(self.assets[i], -1 * self.trading_weight[i]))
            self.SetHoldings(orders)
            
        self.state = -1
            
    # Out of position if spread recovered
    elif self.state == 1 and normalized_spread &gt; -self.threshold or self.state == -1 and normalized_spread &lt; self.threshold:
        self.Liquidate()
        
        self.state = 0</pre>
</div>

<h3>Reference</h3>
<ol>
 <li>
  A Signal Processing Perspective on Financial Engineering. Y. Feng, D. P. Palomer (2016).
  <i>
   Foundations and Trends in Signal Processing. 9(1-2). p173-200.
  </i>
 </li>
</ol>

<h3>Clone Example Project</h3>
<div class="python">
 <div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
  <div class="qc-embed-dummy" style="padding-top: 56.25%;">
  </div>
  <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
   <iframe class="qc-embed-backtest" height="100%" src="https://www.quantconnect.com/terminal/processCache/embedded_backtest_d79d6e5b4485d6c66d15fa757bb133b6.html" style="border: 1px solid #ccc; padding: 0; margin: 0;" width="100%">
   </iframe>
  </div>
 </div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="10.6"><h3>10.6 PCA and Pairs Trading</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to you can use the Research Environment to develop and test a Principle Component Analysis hypothesis, then put the hypothesis in production.
</p>

<h3>Create Hypothesis</h3>
<p>
 Principal Component Analysis (PCA) a way of mapping the existing dataset into a new "space", where the dimensions of the new data are linearly-independent, orthogonal vectors. PCA eliminates the problem of multicollinearity. In another way of thought, can we actually make use of the collinearity it implied, to find the collinear assets to perform pairs trading?
</p>

<h3>Import Libraries</h3>
<p>
 We'll need to import libraries to help with data processing, validation and visualization. Import
 <code>
  sklearn
 </code>
 ,
 <code>
  arch
 </code>
 ,
 <code>
  statsmodels
 </code>
 ,
 <code>
  numpy
 </code>
 and
 <code>
  matplotlib
 </code>
 libraries by the following:
</p>
<div class="section-example-container">
 <pre class="python">from sklearn.decomposition import PCA
from arch.unitroot.cointegration import engle_granger
from statsmodels.tsa.stattools import adfuller
import numpy as np
from matplotlib import pyplot as plt</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 To begin, we retrieve historical data for researching.
</p>
<ol>
 <li>
  Instantiate a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Select the desired tickers for research.
 </li>
 <div class="section-example-container">
  <pre class="python">symbols = {}
assets = ["SHY", "TLT", "SHV", "TLH", "EDV", "BIL",
          "SPTL", "TBT", "TMF", "TMV", "TBF", "VGSH", "VGIT",
          "VGLT", "SCHO", "SCHR", "SPTS", "GOVT"]</pre>
 </div>
 <li>
  Call the
  <code>
   AddEquity
  </code>
  method with the tickers, and their corresponding resolution. Then store their
  <code>
   Symbol
  </code>
  s.
 </li>
 <div class="section-example-container">
  <pre class="python">for i in range(len(assets)):
    symbols[assets[i]] = qb.AddEquity(assets[i],Resolution.Minute).Symbol</pre>
 </div>
 <p>
  If you do not pass a resolution argument,
  <code>
   Resolution.Minute
  </code>
  is used by default.
 </p>
 <li>
  Call the
  <code>
   History
  </code>
  method with
  <code>
   qb.Securities.Keys
  </code>
  for all tickers, time argument(s), and resolution to request historical data for the symbol.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(qb.Securities.Keys, datetime(2021, 1, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
 </div>
 <img alt="Historical data" class="docs-image" src="https://cdn.quantconnect.com/i/tu/pca-2022-data.png"/>
</ol>

<h3>Prepare Data</h3>
<p>
 We'll have to process our data to get the principle component unit vector that explains the most variance, then find the highest- and lowest-absolute-weighing assets as the pair, since the lowest one's variance is mostly explained by the highest.
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_price = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call
  <code>
   pct_change
  </code>
  to compute the daily return.
 </li>
 <div class="section-example-container">
  <pre class="python">returns = close_price.pct_change().iloc[1:]</pre>
 </div>
 <li>
  Initialize a
  <code>
   PCA
  </code>
  model, then get the principle components by the maximum likelihood.
 </li>
 <div class="section-example-container">
  <pre class="python">pca = PCA()
pca.fit(returns)</pre>
 </div>
 <li>
  Get the number of principle component in a list, and their corresponding explained variance ratio.
 </li>
 <div class="section-example-container">
  <pre class="python">components = [str(x + 1) for x in range(pca.n_components_)]
explained_variance_pct = pca.explained_variance_ratio_ * 100</pre>
 </div>
 <li>
  Plot the principle components' explained variance ratio.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.figure(figsize=(15, 10))
plt.bar(components, explained_variance_pct)
plt.title("Ratio of Explained Variance")
plt.xlabel("Principle Component #")
plt.ylabel("%")
plt.show()</pre>
 </div>
 <img alt="Explained variance of each PCA component" class="docs-image" src="https://cdn.quantconnect.com/i/tu/pca-2022-explained-var.png"/>
 <p>
  We can see over 95% of the variance is explained by the first principle. We could conclude that collinearity exists and most assets' return are correlated. Now, we can extract the 2 most correlated pairs.
 </p>
 <li>
  Get the weighting of each asset in the first principle component.
 </li>
 <div class="section-example-container">
  <pre class="python">first_component = pca.components_[0, :]</pre>
 </div>
 <li>
  Select the highest- and lowest-absolute-weighing asset.
 </li>
 <div class="section-example-container">
  <pre class="python">highest = assets[abs(first_component).argmax()]
lowest = assets[abs(first_component).argmin()]
print(f'The highest-absolute-weighing asset: {highest}\nThe lowest-absolute-weighing asset: {lowest}')</pre>
 </div>
 <li>
  Plot their weighings.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.figure(figsize=(15, 10))
plt.bar(assets, first_component)
plt.title("Weightings of each asset in the first component")
plt.xlabel("Assets")
plt.ylabel("Weighting")
plt.xticks(rotation=30)
plt.show()</pre>
 </div>
 <img alt="Weighting of assets in the first PCA component" class="docs-image" src="https://cdn.quantconnect.com/i/tu/pca-2022-weightings.png"/>
</ol>

<h3>Test Hypothesis</h3>
<p>
 We now selected 2 assets as candidate for pair-trading. Hence, we're going to test if they are cointegrated and their spread is stationary to do so.
</p>
<ol>
 <li>
  Call
  <code>
   np.log
  </code>
  to get the log price of the pair.
 </li>
 <div class="section-example-container">
  <pre class="python">log_price = np.log(close_price[[highest, lowest]])</pre>
 </div>
 <li>
  Test cointegration by Engle Granger Test.
 </li>
 <div class="section-example-container">
  <pre class="python">coint_result = engle_granger(log_price.iloc[:, 0], log_price.iloc[:, 1], trend="c", lags=0)
display(coint_result)</pre>
  <img alt="Cointegration test result" class="docs-image" src="https://cdn.quantconnect.com/i/tu/pca-2022-egt.png"/>
 </div>
 <li>
  Get their cointegrating vector.
 </li>
 <div class="section-example-container">
  <pre class="python">coint_vector = coint_result.cointegrating_vector[:2]</pre>
 </div>
 <li>
  Calculate the spread.
 </li>
 <div class="section-example-container">
  <pre class="python">spread = log_price @ coint_vector</pre>
 </div>
 <li>
  Use Augmented Dickey Fuller test to test its stationarity.
 </li>
 <div class="section-example-container">
  <pre class="python">pvalue = adfuller(spread, maxlag=0)[1]
print(f"The ADF test p-value is {pvalue}, so it is {'' if pvalue &lt; 0.05 else 'not '}stationary.")</pre>
 </div>
 <li>
  Plot the spread.
 </li>
 <div class="section-example-container">
  <pre class="python">spread.plot(figsize=(15, 10), title=f"Spread of {highest} and {lowest}")
plt.ylabel("Spread")
plt.show()</pre>
 </div>
 <img alt="Spread series of SCHO &amp; SHY" class="docs-image" src="https://cdn.quantconnect.com/i/tu/pca-2022-spread.png"/>
 <p>
  Result shown that the pair is cointegrated and their spread is stationary, so they are potential pair for pair-trading.
 </p>
</ol>

<h3>Set Up Algorithm</h3>
<p>
 Pairs trading is exactly a 2-asset version of statistical arbitrage. Thus, we can just modify the algorithm from
 <a href="/https://www.quantconnect.com/docs/v2/docs/v2/research-environment/applying-research/kalman-filters-and-stat-arb#10-Set-Up-Algorithm">
  the Kalman Filter and Statistical Arbitrage tutorial
 </a>
 , except we're using only a single cointegrating unit vector so no optimization of cointegration subspace is needed.
</p>
<div class="section-example-container">
 <pre class="python">def Initialize(self) -&gt; None:

    #1. Required: Five years of backtest history
    self.SetStartDate(2014, 1, 1)

    #2. Required: Alpha Streams Models:
    self.SetBrokerageModel(BrokerageName.AlphaStreams)

    #3. Required: Significant AUM Capacity
    self.SetCash(1000000)

    #4. Required: Benchmark to SPY
    self.SetBenchmark("SPY")

    self.assets = ["SCHO", "SHY"]
    
    # Add Equity ------------------------------------------------ 
    for i in range(len(self.assets)):
        self.AddEquity(self.assets[i], Resolution.Minute)
        
    # Instantiate our model
    self.Recalibrate()
    
    # Set a variable to indicate the trading bias of the portfolio
    self.state = 0
    
    # Set Scheduled Event Method For Kalman Filter updating.
    self.Schedule.On(self.DateRules.WeekStart(), 
        self.TimeRules.At(0, 0), 
        self.Recalibrate)
    
    # Set Scheduled Event Method For Kalman Filter updating.
    self.Schedule.On(self.DateRules.EveryDay(), 
        self.TimeRules.BeforeMarketClose("SHY"), 
        self.EveryDayBeforeMarketClose)
        
        
def Recalibrate(self) -&gt; None:
    qb = self
    history = qb.History(self.assets, 252*2, Resolution.Daily)
    if history.empty: return
    
    # Select the close column and then call the unstack method
    data = history['close'].unstack(level=0)
    
    # Convert into log-price series to eliminate compounding effect
    log_price = np.log(data)
    
    ### Get Cointegration Vectors
    # Get the cointegration vector
    coint_result = engle_granger(log_price.iloc[:, 0], log_price.iloc[:, 1], trend="c", lags=0)
    coint_vector = coint_result.cointegrating_vector[:2]
    
    # Get the spread
    spread = log_price @ coint_vector
    
    ### Kalman Filter
    # Initialize a Kalman Filter. Using the first 20 data points to optimize its initial state. We assume the market has no regime change so that the transitional matrix and observation matrix is [1].
    self.kalmanFilter = KalmanFilter(transition_matrices = [1],
                        observation_matrices = [1],
                        initial_state_mean = spread.iloc[:20].mean(),
                        observation_covariance = spread.iloc[:20].var(),
                        em_vars=['transition_covariance', 'initial_state_covariance'])
    self.kalmanFilter = self.kalmanFilter.em(spread.iloc[:20], n_iter=5)
    (filtered_state_means, filtered_state_covariances) = self.kalmanFilter.filter(spread.iloc[:20])
    
    # Obtain the current Mean and Covariance Matrix expectations.
    self.currentMean = filtered_state_means[-1, :]
    self.currentCov = filtered_state_covariances[-1, :]
    
    # Initialize a mean series for spread normalization using the Kalman Filter's results.
    mean_series = np.array([None]*(spread.shape[0]-20))
    
    # Roll over the Kalman Filter to obtain the mean series.
    for i in range(20, spread.shape[0]):
        (self.currentMean, self.currentCov) = self.kalmanFilter.filter_update(filtered_state_mean = self.currentMean,
                                                                filtered_state_covariance = self.currentCov,
                                                                observation = spread.iloc[i])
        mean_series[i-20] = float(self.currentMean)
    
    # Obtain the normalized spread series.
    normalized_spread = (spread.iloc[20:] - mean_series)
    
    ### Determine Trading Threshold
    # Initialize 50 set levels for testing.
    s0 = np.linspace(0, max(normalized_spread), 50)
    
    # Calculate the profit levels using the 50 set levels.
    f_bar = np.array([None]*50)
    for i in range(50):
        f_bar[i] = len(normalized_spread.values[normalized_spread.values &gt; s0[i]]) \
            / normalized_spread.shape[0]
        
    # Set trading frequency matrix.
    D = np.zeros((49, 50))
    for i in range(D.shape[0]):
        D[i, i] = 1
        D[i, i+1] = -1
        
    # Set level of lambda.
    l = 1.0
    
    # Obtain the normalized profit level.
    f_star = np.linalg.inv(np.eye(50) + l * D.T@D) @ f_bar.reshape(-1, 1)
    s_star = [f_star[i]*s0[i] for i in range(50)]
    self.threshold = s0[s_star.index(max(s_star))]
    
    # Set the trading weight. We would like the portfolio absolute total weight is 1 when trading.
    self.trading_weight = coint_vector / np.sum(abs(coint_vector))
    
        
def EveryDayBeforeMarketClose(self) -&gt; None:
    qb = self
    
    # Get the real-time log close price for all assets and store in a Series
    series = pd.Series()
    for symbol in qb.Securities.Keys:
        series[symbol] = np.log(qb.Securities[symbol].Close)
        
    # Get the spread
    spread = np.sum(series * self.trading_weight)
    
    # Update the Kalman Filter with the Series
    (self.currentMean, self.currentCov) = self.kalmanFilter.filter_update(filtered_state_mean = self.currentMean,
                                                                        filtered_state_covariance = self.currentCov,
                                                                        observation = spread)
        
    # Obtain the normalized spread.
    normalized_spread = spread - self.currentMean

    # ==============================
    
    # Mean-reversion
    if normalized_spread &lt; -self.threshold:
        orders = []
        for i in range(len(self.assets)):
            orders.append(PortfolioTarget(self.assets[i], self.trading_weight[i]))
            self.SetHoldings(orders)
            
        self.state = 1
            
    elif normalized_spread &gt; self.threshold:
        orders = []
        for i in range(len(self.assets)):
            orders.append(PortfolioTarget(self.assets[i], -1 * self.trading_weight[i]))
            self.SetHoldings(orders)
            
        self.state = -1
            
    # Out of position if spread recovered
    elif self.state == 1 and normalized_spread &gt; -self.threshold or self.state == -1 and normalized_spread &lt; self.threshold:
        self.Liquidate()
        
        self.state = 0</pre>
</div>

<h3>Clone Example Project</h3>
<div class="python">
 <div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
  <div class="qc-embed-dummy" style="padding-top: 56.25%;">
  </div>
  <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
   <iframe class="qc-embed-backtest" height="100%" src="https://www.quantconnect.com/terminal/processCache/embedded_backtest_88bd27ce67b6e02ef0efa84a649d15ea.html" style="border: 1px solid #ccc; padding: 0; margin: 0;" width="100%">
   </iframe>
  </div>
 </div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="10.7"><h3>10.7 Hidden Markov Models</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to you can use the Research Environment to develop and test a Hidden Markov Model hypothesis, then put the hypothesis in production.
</p>

<h3>Create Hypothesis</h3>
<p>
 A Markov process is a stochastic process where the possibility of switching to another state depends only on the current state of the model by the current state's probability distribution (it is usually represented by a state transition matrix). It is history-independent, or memoryless. While often a Markov process's state is observable, the states of a Hidden Markov Model (HMM) is not observable. This means the input(s) and output(s) are observable, but their intermediate, the state, is non-observable/hidden.
</p>
<img alt="Hidden markov model" class="docs-image" src="https://cdn.quantconnect.com/i/tu/hmm-model.png"/>
<p>
 <b>
  A 3-state HMM example, where S are the hidden states, O are the observable states and a are the probabilities of state transition.
 </b>
 <br/>
 <font font-size="2px">
  <i>
   Image source: Modeling Strategic Use of Human Computer Interfaces with Novel Hidden Markov Models. L. J. Mariano, et. al. (2015). Frontiers in Psychology 6:919. DOI:10.3389/fpsyg.2015.00919
  </i>
 </font>
</p>
<p>
 In finance, HMM is particularly useful in determining the market regime, usually classified into "Bull" and "Bear" markets. Another popular classification is "Volatile" vs "Involatile" market, such that we can avoid entering the market when it is too risky. We hypothesis a HMM could be able to do the later, so we can produce a SPY-out-performing portfolio (positive alpha).
</p>

<h3>Import Libraries</h3>
<p>
 We'll need to import libraries to help with data processing, validation and visualization. Import
 <code>
  statsmodels
 </code>
 ,
 <code>
  scipy
 </code>
 ,
 <code>
  numpy
 </code>
 ,
 <code>
  matplotlib
 </code>
 and
 <code>
  pandas
 </code>
 libraries by the following:
</p>
<div class="section-example-container">
 <pre class="python">from statsmodels.tsa.regime_switching.markov_regression import MarkovRegression
from scipy.stats import multivariate_normal
import numpy as np

from matplotlib import pyplot as plt
from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 To begin, we retrieve historical data for researching.
</p>
<ol>
 <li>
  Instantiate a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Select the desired index for research.
 </li>
 <div class="section-example-container">
  <pre class="python">asset = "SPX"</pre>
 </div>
 <li>
  Call the
  <code>
   AddIndex
  </code>
  method with the tickers, and their corresponding resolution.
 </li>
 <div class="section-example-container">
  <pre class="python">qb.AddIndex(asset, Resolution.Minute)</pre>
 </div>
 <p>
  If you do not pass a resolution argument,
  <code>
   Resolution.Minute
  </code>
  is used by default.
 </p>
 <li>
  Call the
  <code>
   History
  </code>
  method with
  <code>
   qb.Securities.Keys
  </code>
  for all tickers, time argument(s), and resolution to request historical data for the symbol.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(qb.Securities.Keys, datetime(2019, 1, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
 </div>
 <img alt="Historical data" class="docs-image" src="https://cdn.quantconnect.com/i/tu/hmm-2022-data.png"/>
</ol>

<h3>Prepare Data</h3>
<p>
 We'll have to process our data to get the volatility of the market for classification.
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_price = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call
  <code>
   pct_change
  </code>
  to compute the daily return.
 </li>
 <div class="section-example-container">
  <pre class="python">returns = close_price.pct_change().iloc[1:]</pre>
 </div>
 <li>
  Initialize the HMM, then fit by the daily return data. Note that we're using varinace as switching regime, so
  <code>
   switching_variance
  </code>
  argument is set as
  <code>
   True
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">model = MarkovRegression(returns, k_regimes=2, switching_variance=True).fit()
display(model.summary())</pre>
 </div>
 <img alt="Markov switching model summary" class="docs-image" src="https://cdn.quantconnect.com/i/tu/hmm-2022-hmm.png"/>
 <p>
  All p-values of the regime self-transition coefficients and the regime transition probability matrix's coefficient is smaller than 0.05, indicating the model should be able to classify the data into 2 different volatility regimes.
 </p>
</ol>

<h3>Test Hypothesis</h3>
<p>
 We now verify if the model can detect high and low volatility period effectively.
</p>
<ol>
 <li>
  Get the regime as a column, 1 as Low Variance Regime, 2 as High Variance Regime.
 </li>
 <div class="section-example-container">
  <pre class="python">regime = pd.Series(model.smoothed_marginal_probabilities.values.argmax(axis=1)+1, 
                      index=returns.index, name='regime')
df_1 = close.loc[returns.index][regime == 1]
df_2 = close.loc[returns.index][regime == 2]</pre>
 </div>
 <li>
  Get the mean and covariance matrix of the 2 regimes, assume 0 covariance between the two.
 </li>
 <div class="section-example-container">
  <pre class="python">mean = np.array([returns.loc[df_1.index].mean(), returns.loc[df_2.index].mean()])
cov = np.array([[returns.loc[df_1.index].var(), 0], [0, returns.loc[df_2.index].var()]])</pre>
 </div>
 <li>
  Fit a 2-dimensional multivariate normal distribution by the 2 means and covriance matrix.
 </li>
 <div class="section-example-container">
  <pre class="python">dist = multivariate_normal(mean=mean.flatten(), cov=cov)
mean_1, mean_2 = mean[0], mean[1]
sigma_1, sigma_2 = cov[0,0], cov[1,1]</pre>
 </div>
 <li>
  Get the normal distribution of each of the distribution.
 </li>
 <div class="section-example-container">
  <pre class="python">x = np.linspace(-0.05, 0.05, num=100)
y = np.linspace(-0.05, 0.05, num=100)
X, Y = np.meshgrid(x,y)
pdf = np.zeros(X.shape)
for i in range(X.shape[0]):
    for j in range(X.shape[1]):
        pdf[i,j] = dist.pdf([X[i,j], Y[i,j]])</pre>
 </div>
 <li>
  Plot the probability of data in different regimes.
 </li>
 <div class="section-example-container">
  <pre class="python">fig, axes = plt.subplots(2, figsize=(15, 10))
ax = axes[0]
ax.plot(model.smoothed_marginal_probabilities[0])
ax.set(title='Smoothed probability of Low Variance Regime')
ax = axes[1]
ax.plot(model.smoothed_marginal_probabilities[1])
ax.set(title='Smoothed probability of High Variance Regime')
fig.tight_layout()
plt.show()</pre>
 </div>
 <img alt="Probability of being in a regime" class="docs-image" src="https://cdn.quantconnect.com/i/tu/hmm-2022-prob.png"/>
 <li>
  Plot the series into regime-wise.
 </li>
 <div class="section-example-container">
  <pre class="python">df_1.index = pd.to_datetime(df_1.index)
df_1 = df_1.sort_index()
df_2.index = pd.to_datetime(df_2.index)
df_2 = df_2.sort_index()
plt.figure(figsize=(15, 10))
plt.scatter(df_1.index, df_1, color='blue', label="Low Variance Regime")
plt.scatter(df_2.index, df_2, color='red', label="High Variance Regime")
plt.title("Price series")
plt.ylabel("Price ($)")
plt.xlabel("Date")
plt.legend()
plt.show()</pre>
 </div>
 <img alt="Scatter plot of datapoints' regime" class="docs-image" src="https://cdn.quantconnect.com/i/tu/hmm-2022-curve.png"/>
 <li>
  Plot the distribution surface.
 </li>
 <div class="section-example-container">
  <pre class="python">fig = plt.figure(figsize=(20, 10))
ax = fig.add_subplot(122, projection = '3d')
ax.plot_surface(X, Y, pdf, cmap = 'viridis')
ax.axes.zaxis.set_ticks([])
plt.xlabel("Low Volatility Regime")
plt.ylabel("High Volatility Regime")
plt.title('Bivariate normal distribution of the Regimes')
plt.tight_layout()
plt.show()</pre>
 </div>
 <img alt="Surface plot %return distribution of regimes" class="docs-image" src="https://cdn.quantconnect.com/i/tu/hmm-2022-surface.png"/>
 <li>
  Plot the contour.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.figure(figsize=(12, 8))
plt.contourf(X, Y, pdf, cmap = 'viridis')
plt.xlabel("Low Volatility Regime")
plt.ylabel("High Volatility Regime")
plt.title('Bivariate normal distribution of the Regimes')
plt.tight_layout()
plt.show()</pre>
 </div>
 <img alt="Contour plot %return distribution of regimes" class="docs-image" src="https://cdn.quantconnect.com/i/tu/hmm-2022-contour.png"/>
</ol>
<p>
 We can clearly seen from the results, the Low Volatility Regime has much lower variance than the High Volatility Regime, proven the model works.
</p>

<h3>Set Up Algorithm</h3>
<p>
 Once we are confident in our hypothesis, we can export this code into backtesting. One way to accomodate this model into backtest is to create a scheduled event which uses our model to predict the expected return. Since we could calculate the expected return, we'd use Mean-Variance Optimization for portfolio construction.
</p>
<div class="section-example-container">
 <pre class="python">def Initialize(self) -&gt; None:

    #1. Required: Five years of backtest history
    self.SetStartDate(2008, 1, 1)
    self.SetEndDate(2021, 1, 1)

    #2. Required: Alpha Streams Models:
    self.SetBrokerageModel(BrokerageName.AlphaStreams)

    #3. Required: Significant AUM Capacity
    self.SetCash(1000000)

    #4. Required: Benchmark to SPY
    self.SetBenchmark("SPY")

    self.assets = ["SPY", "TLT"]    # "TLT" as fix income in out-of-market period (high volatility)
    
    # Add Equity ------------------------------------------------ 
    for ticker in self.assets:
        self.AddEquity(ticker, Resolution.Minute)
    
    # Set Scheduled Event Method For Kalman Filter updating.
    self.Schedule.On(self.DateRules.EveryDay(), 
        self.TimeRules.BeforeMarketClose("SPY", 5), 
        self.EveryDayBeforeMarketClose)</pre>
</div>
<p>
 Now we export our model into the scheduled event method. We will switch
 <code>
  qb
 </code>
 with
 <code>
  self
 </code>
 and replace methods with their
 <code>
  QCAlgorithm
 </code>
 counterparts as needed. In this example, this is not an issue because all the methods we used in research also exist in
 <code>
  QCAlgorithm
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">def EveryDayBeforeMarketClose(self) -&gt; None:
    qb = self
    
    # Get history
    history = qb.History(["SPY"], datetime(2010, 1, 1), datetime.now(), Resolution.Daily)
        
    # Get the close price daily return.
    close = history['close'].unstack(level=0)
    
    # Call pct_change to obtain the daily return
    returns = close.pct_change().iloc[1:]
            
    # Initialize the HMM, then fit by the standard deviation data.
    model = MarkovRegression(returns, k_regimes=2, switching_variance=True).fit()
        
    # Obtain the market regime
    regime = model.smoothed_marginal_probabilities.values.argmax(axis=1)[-1]

    # ==============================
    
    if regime == 0:
        self.SetHoldings([PortfolioTarget("TLT", 0.), PortfolioTarget("SPY", 1.)])
    else:
        self.SetHoldings([PortfolioTarget("TLT", 1.), PortfolioTarget("SPY", 0.)])</pre>
</div>

<h3>Clone Example Project</h3>
<div class="python">
 <div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
  <div class="qc-embed-dummy" style="padding-top: 56.25%;">
  </div>
  <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
   <iframe class="qc-embed-backtest" height="100%" src="https://www.quantconnect.com/terminal/processCache/embedded_backtest_1b9263ecabf64a0a4daf6b4d286fbe3f.html" style="border: 1px solid #ccc; padding: 0; margin: 0;" width="100%">
   </iframe>
  </div>
 </div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="10.8"><h3>10.8 Long Short-Term Memory</h3></section>

<h3>Introduction</h3>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<p>
 This page explains how to you can use the Research Environment to develop and test a Long Short Term Memory hypothesis, then put the hypothesis in production.
</p>
<p>
 Recurrent neural networks (RNN) are a powerful tool in deep learning. These models quite accurately mimic how humans process sequencial information and learn. Unlike traditional feedforward neural networks, RNNs have memory. That is, information fed into them persists and the network is able to draw on this to make inferences.
 <br/>
 <br/>
 Long Short-term Memory (LSTM) is a type of RNN. Instead of one layer, LSTM cells generally have four, three of which are part of "gates" -- ways to optionally let information through. The three gates are commonly referred to as the forget, input, and output gates. The forget gate layer is where the model decides what information to keep from prior states. At the input gate layer, the model decides which values to update. Finally, the output gate layer is where the final output of the cell state is decided. Essentially, LSTM separately decides what to remember and the rate at which it should update.
</p>
<img alt="Long-short term memory cell" class="docs-image" src="https://cdn.quantconnect.com/i/tu/lstm-cell-2.png"/>
<p>
 <b>
  An exmaple of a LSTM cell: x is the input data, c is the long-term memory, h is the current state and serve as short-term memory, $\sigma$ and $tanh$ is the non-linear activation function of the gates.
 </b>
 <br/>
 <i>
  <font font-size="2px">
   Image source: https://en.wikipedia.org/wiki/Long_short-term_memory#/media/File:LSTM_Cell.svg
  </font>
 </i>
</p>

<h3>Create Hypothesis</h3>
<p>
 LSTM models have produced some great results when applied to time-series prediction. One of the central challenges with conventional time-series models is that, despite trying to account for trends or other non-stationary elements, it is almost impossible to truly predict an outlier like a recession, flash crash, liquidity crisis, etc. By having a long memory, LSTM models are better able to capture these difficult trends in the data without suffering from the level of overfitting a conventional model would need in order to capture the same data.
 <br/>
 <br/>
 For a very basic application, we're hypothesizing LSTM can offer an accurate prediction in future price.
</p>

<h3>Import Libraries</h3>
<p>
 We'll need to import libraries to help with data processing, validation and visualization. Import
 <code>
  keras
 </code>
 ,
 <code>
  sklearn
 </code>
 ,
 <code>
  numpy
 </code>
 and
 <code>
  matplotlib
 </code>
 libraries by the following:
</p>
<div class="section-example-container">
 <pre class="python">from keras.layers import LSTM, Dense, Dropout
from keras.models import Sequential
from keras.callbacks import EarlyStopping
from sklearn.preprocessing import MinMaxScaler

import numpy as np
from matplotlib import pyplot as plt</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 To begin, we retrieve historical data for researching.
</p>
<ol>
 <li>
  Instantiate a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Select the desired index for research.
 </li>
 <div class="section-example-container">
  <pre class="python">asset = "SPY"</pre>
 </div>
 <li>
  Call the
  <code>
   AddEquity
  </code>
  method with the tickers, and their corresponding resolution.
 </li>
 <div class="section-example-container">
  <pre class="python">qb.AddEquity(asset, Resolution.Minute)</pre>
 </div>
 <p>
  If you do not pass a resolution argument,
  <code>
   Resolution.Minute
  </code>
  is used by default.
 </p>
 <li>
  Call the
  <code>
   History
  </code>
  method with
  <code>
   qb.Securities.Keys
  </code>
  for all tickers, time argument(s), and resolution to request historical data for the symbol.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(qb.Securities.Keys, datetime(2019, 1, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
 </div>
 <img alt="Historical data" class="docs-image" src="https://cdn.quantconnect.com/i/tu/lstm-2022-data.png"/>
</ol>

<h3>Prepare Data</h3>
<p>
 We'll have to process our data as well as build the LSTM model before testing the hypothesis. We would scale our data to for better covergence.
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">close_price = history['close'].unstack(level=0)</pre>
 </div>
 <li>
  Initialize
  <code>
   MinMaxScaler
  </code>
  to scale the data onto [0,1].
 </li>
 <div class="section-example-container">
  <pre class="python">scaler = MinMaxScaler(feature_range = (0, 1))</pre>
 </div>
 <li>
  Transform our data.
 </li>
 <div class="section-example-container">
  <pre class="python">df = pd.DataFrame(scaler.fit_transform(close), index=close.index)</pre>
 </div>
 <li>
  Select input data
 </li>
 <div class="section-example-container">
  <pre class="python">scaler = MinMaxScaler(feature_range = (0, 1))</pre>
 </div>
 <li>
  Shift the data for 1-step backward as training output result.
 </li>
 <div class="section-example-container">
  <pre class="python">output = df.shift(-1).iloc[:-1]</pre>
 </div>
 <li>
  Split the data into training and testing sets.
 </li>
 <p>
  In this example, we use the first 80% data for trianing, and the last 20% for testing.
 </p>
 <div class="section-example-container">
  <pre class="python">splitter = int(input_.shape[0] * 0.8)
X_train = input_.iloc[:splitter]
X_test = input_.iloc[splitter:]
y_train = output.iloc[:splitter]
y_test = output.iloc[splitter:]</pre>
 </div>
 <li>
  Build feauture and label sets (using number of steps 60, and feature rank 1).
 </li>
 <div class="section-example-container">
  <pre class="python">features_set = []
labels = []
for i in range(60, X_train.shape[0]):
    features_set.append(X_train.iloc[i-60:i].values.reshape(-1, 1))
    labels.append(y_train.iloc[i])
features_set, labels = np.array(features_set), np.array(labels)
features_set = np.reshape(features_set, (features_set.shape[0], features_set.shape[1], 1))</pre>
 </div>
</ol>

<h3>Build Model</h3>
<p>
 We construct the LSTM model.
</p>
<ol>
 <li>
  Build a
  <code>
   Sequential
  </code>
  keras model.
 </li>
 <div class="section-example-container">
  <pre class="python">model = Sequential()</pre>
 </div>
 <li>
  Create the model infrastructure.
 </li>
 <div class="section-example-container">
  <pre class="python"># Add our first LSTM layer - 50 nodes.
model.add(LSTM(units = 50, return_sequences=True, input_shape=(features_set.shape[1], 1)))
# Add Dropout layer to avoid overfitting
model.add(Dropout(0.2))
# Add additional layers
model.add(LSTM(units=50, return_sequences=True))
model.add(Dropout(0.2))
model.add(LSTM(units=50))
model.add(Dropout(0.2))
model.add(Dense(units = 5))
model.add(Dense(units = 1))</pre>
 </div>
 <li>
  Compile the model.
 </li>
 <p>
  We use Adam as optimizer for adpative step size and MSE as loss function since it is continuous data.
 </p>
 <div class="section-example-container">
  <pre class="python">model.compile(optimizer = 'adam', loss = 'mean_squared_error', metrics=['mae', 'acc'])</pre>
 </div>
 <li>
  Set early stopping callback method.
 </li>
 <div class="section-example-container">
  <pre class="python">callback = EarlyStopping(monitor='loss', patience=3, verbose=1, restore_best_weights=True)</pre>
 </div>
 <li>
  Display the model structure.
 </li>
 <div class="section-example-container">
  <pre class="python">model.summary()</pre>
 </div>
 <img alt="LSTM model summary" class="docs-image" src="https://cdn.quantconnect.com/i/tu/lstm-2022-model.png"/>
 <li>
  Fit the model to our data, running 20 training epochs.
 </li>
 <p>
  Note that different training session's results will not be the same since the batch is randomly selected.
 </p>
 <div class="section-example-container">
  <pre class="python">model.fit(features_set, labels, epochs = 20, batch_size = 100, callbacks=[callback])</pre>
 </div>
 <img alt="LSTM model training output" class="docs-image" src="https://cdn.quantconnect.com/i/tu/lstm-2022-training.png"/>
</ol>

<h3>Test Hypothesis</h3>
<p>
 We would test the performance of this ML model to see if it could predict 1-step forward price precisely. To do so, we would compare the predicted and actual prices.
</p>
<ol>
 <li>
  Get testing set features for input.
 </li>
 <div class="section-example-container">
  <pre class="python">test_features = []
for i in range(60, X_test.shape[0]):
    test_features.append(X_test.iloc[i-60:i].values.reshape(-1, 1))
test_features = np.array(test_features)
test_features = np.reshape(test_features, (test_features.shape[0], test_features.shape[1], 1))</pre>
 </div>
 <li>
  Make predictions.
 </li>
 <div class="section-example-container">
  <pre class="python">predictions = model.predict(test_features)</pre>
 </div>
 <li>
  Transform predictions back to original data-scale.
 </li>
 <div class="section-example-container">
  <pre class="python">predictions = scaler.inverse_transform(predictions)
actual = scaler.inverse_transform(y_test.values)</pre>
 </div>
 <li>
  Plot the results.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.figure(figsize=(15, 10))
plt.plot(actual[60:], color='blue', label='Actual')
plt.plot(predictions , color='red', label='Prediction')
plt.title('Price vs Predicted Price ')
plt.legend()
plt.show()</pre>
 </div>
 <img alt="LSTM model performance" class="docs-image" src="https://cdn.quantconnect.com/i/tu/lstm-2022-plot.png"/>
</ol>

<h3>Set Up Algorithm</h3>
<p>
 Once we are confident in our hypothesis, we can export this code into backtesting. One way to accomodate this model into backtest is to create a scheduled event which uses our model to predict the expected return. If we predict the price will go up, we long SPY, else, we short it.
</p>
<div class="section-example-container">
 <pre class="python">def Initialize(self) -&gt; None:

    #1. Required: Five years of backtest history
    self.SetStartDate(2016, 1, 1)

    #2. Required: Alpha Streams Models:
    self.SetBrokerageModel(BrokerageName.AlphaStreams)

    #3. Required: Significant AUM Capacity
    self.SetCash(1000000)

    #4. Required: Benchmark to SPY
    self.SetBenchmark("SPY")

    self.asset = "SPY"
    
    # Add Equity ------------------------------------------------ 
    self.AddEquity(self.asset, Resolution.Minute)
        
    # Initialize the LSTM model
    self.BuildModel()
    
    # Set Scheduled Event Method For Our Model
    self.Schedule.On(self.DateRules.EveryDay(), 
        self.TimeRules.BeforeMarketClose("SPY", 5), 
        self.EveryDayBeforeMarketClose)
    
    # Set Scheduled Event Method For Our Model Retraining every month
    self.Schedule.On(self.DateRules.MonthStart(), 
        self.TimeRules.At(0, 0), 
        self.BuildModel)</pre>
</div>
<p>
 We'll also need to create a function to train and update our model from time to time.
</p>
<div class="section-example-container">
 <pre class="python">def BuildModel(self) -&gt; None:
    qb = self
    
    ### Preparing Data
    # Get historical data
    history = qb.History(qb.Securities.Keys, 252*2, Resolution.Daily)
    
    # Select the close column and then call the unstack method.
    close = history['close'].unstack(level=0)
    
    # Scale data onto [0,1]
    self.scaler = MinMaxScaler(feature_range = (0, 1))
    
    # Transform our data
    df = pd.DataFrame(self.scaler.fit_transform(close), index=close.index)
    
    # Feature engineer the data for input.
    input_ = df.iloc[1:]
    
    # Shift the data for 1-step backward as training output result.
    output = df.shift(-1).iloc[:-1]
    
    # Build feauture and label sets (using number of steps 60, and feature rank 1)
    features_set = []
    labels = []
    for i in range(60, input_.shape[0]):
        features_set.append(input_.iloc[i-60:i].values.reshape(-1, 1))
        labels.append(output.iloc[i])
    features_set, labels = np.array(features_set), np.array(labels)
    features_set = np.reshape(features_set, (features_set.shape[0], features_set.shape[1], 1))
    
    ### Build Model
    # Build a Sequential keras model
    self.model = Sequential()
    
    # Add our first LSTM layer - 50 nodes
    self.model.add(LSTM(units = 50, return_sequences=True, input_shape=(features_set.shape[1], 1)))
    # Add Dropout layer to avoid overfitting
    self.model.add(Dropout(0.2))
    # Add additional layers
    self.model.add(LSTM(units=50, return_sequences=True))
    self.model.add(Dropout(0.2))
    self.model.add(LSTM(units=50))
    self.model.add(Dropout(0.2))
    self.model.add(Dense(units = 5))
    self.model.add(Dense(units = 1))
    
    # Compile the model. We use Adam as optimizer for adpative step size and MSE as loss function since it is continuous data.
    self.model.compile(optimizer = 'adam', loss = 'mean_squared_error', metrics=['mae', 'acc'])

    # Set early stopping callback method
    callback = EarlyStopping(monitor='loss', patience=3, restore_best_weights=True)
    
    # Fit the model to our data, running 20 training epochs
    self.model.fit(features_set, labels, epochs = 20, batch_size = 1000, callbacks=[callback])</pre>
</div>
<p>
 Now we export our model into the scheduled event method. We will switch
 <code>
  qb
 </code>
 with
 <code>
  self
 </code>
 and replace methods with their
 <code>
  QCAlgorithm
 </code>
 counterparts as needed. In this example, this is not an issue because all the methods we used in research also exist in
 <code>
  QCAlgorithm
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">def EveryDayBeforeMarketClose(self) -&gt; None:
    qb = self
    # Fetch history on our universe
    history = qb.History(qb.Securities.Keys, 60, Resolution.Daily)
    if history.empty: return

    # Make all of them into a single time index.
    close = history.close.unstack(level=0)
    
    # Scale our data
    df = pd.DataFrame(self.scaler.transform(close), index=close.index)

    # Feature engineer the data for input
    input_ = []
    input_.append(df.values.reshape(-1, 1))
    input_ = np.array(input_)
    input_ = np.reshape(input_, (input_.shape[0], input_.shape[1], 1))
    
    # Prediction
    prediction = self.model.predict(input_)
    
    # Revert the scaling into price
    prediction = self.scaler.inverse_transform(prediction)

    # ==============================
    
    if prediction &gt; qb.Securities[self.asset].Price:
        self.SetHoldings(self.asset, 1.)
    else:
        self.SetHoldings(self.asset, -1.)</pre>
</div>

<h3>Clone Example Project</h3>
<div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="10.9"><h3>10.9 Airline Buybacks</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to you can use the Research Environment to develop and test a Airline Buybacks hypothesis, then put the hypothesis in production.
</p>

<h3>Create Hypothesis</h3>
<p>
 Buyback represents a company buy back its own stocks in the market, as (1) management is confident on its own future, and (2) wants more control over its development. Since usually buyback is in large scale on a schedule, the price of repurchasing often causes price fluctuation.
 <br/>
 <br/>
 Airlines is one of the largest buyback sectors. Major US Airlines use over 90% of their free cashflow to buy back their own stocks in the recent years.
 <sup>
  <a href="https://www.bloomberg.com/news/articles/2020-03-16/u-s-airlines-spent-96-of-free-cash-flow-on-buybacks-chart">
   [1]
  </a>
 </sup>
 Therefore, we can use airline companies to test the hypothesis of buybacks would cause price action. In this particular exmaple, we're hypothesizing that difference in buyback price and close price would suggest price change in certain direction. (we don't know forward return would be in momentum or mean-reversion in this case!)
</p>

<h3>Import Libraries</h3>
<p>
 We'll need to import libraries to help with data processing, validation and visualization. Import
 <code>
  SmartInsiderTransaction
 </code>
 class,
 <code>
  statsmodels
 </code>
 ,
 <code>
  sklearn
 </code>
 ,
 <code>
  numpy
 </code>
 ,
 <code>
  pandas
 </code>
 and
 <code>
  seaborn
 </code>
 libraries by the following:
</p>
<div class="section-example-container">
 <pre class="python">from QuantConnect.DataSource import SmartInsiderTransaction

from statsmodels.discrete.discrete_model import Logit
from sklearn.metrics import confusion_matrix
import numpy as np
import pandas as pd
import seaborn as sns</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 To begin, we retrieve historical data for researching.
</p>
<ol>
 <li>
  Instantiate a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Select the airline tickers for research.
 </li>
 <div class="section-example-container">
  <pre class="python">assets = ["LUV",   # Southwest Airlines
          "DAL",   # Delta Airlines
          "UAL",   # United Airlines Holdings
          "AAL",   # American Airlines Group
          "SKYW",  # SkyWest Inc. 
          "ALGT",  # Allegiant Travel Co.
          "ALK"    # Alaska Air Group Inc.
         ]</pre>
 </div>
 <li>
  Call the
  <code>
   AddEquity
  </code>
  method with the tickers, and its corresponding resolution. Then call
  <code>
   AddData
  </code>
  with
  <code>
   SmartInsiderTransaction
  </code>
  to subscribe to their buyback transaction data. Save the
  <code>
   Symbol
  </code>
  s into a dictionary.
 </li>
 <div class="section-example-container">
  <pre class="python">symbols = {}
for ticker in assets:
    symbol = qb.AddEquity(ticker, Resolution.Minute).Symbol
    symbols[symbol] = qb.AddData(SmartInsiderTransaction, symbol).Symbol</pre>
 </div>
 <p>
  If you do not pass a resolution argument,
  <code>
   Resolution.Minute
  </code>
  is used by default.
 </p>
 <li>
  Call the
  <code>
   History
  </code>
  method with a list of
  <code>
   Symbol
  </code>
  s for all tickers, time argument(s), and resolution to request historical data for the symbols.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(list(symbols.keys()), datetime(2019, 1, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
 </div>
 <li>
  Call SPY history as reference.
 </li>
 <div class="section-example-container">
  <pre class="python">spy = qb.History(qb.AddEquity("SPY").Symbol, datetime(2019, 1, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
 </div>
 <li>
  Call the
  <code>
   History
  </code>
  method with a list of
  <code>
   SmartInsiderTransaction
  </code>
  <code>
   Symbol
  </code>
  s for all tickers, time argument(s), and resolution to request historical data for the symbols.
 </li>
 <div class="section-example-container">
  <pre class="python">history_buybacks = qb.History(list(symbols.values()), datetime(2019, 1, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
 </div>
 <img alt="Historical data" class="docs-image" src="https://cdn.quantconnect.com/i/tu/airline-buybacks-2022-buybacks.png"/>
</ol>

<h3>Prepare Data</h3>
<p>
 We'll have to process our data to get the buyback premium/discount% vs forward return data.
</p>
<ol>
 <li>
  Select the close column and then call the
  <code>
   unstack
  </code>
  method.
 </li>
 <div class="section-example-container">
  <pre class="python">df = history['close'].unstack(level=0)
spy_close = spy['close'].unstack(level=0)</pre>
 </div>
 <li>
  Call
  <code>
   pct_change
  </code>
  to get the daily return of close price, then shift 1-step backward as prediction.
 </li>
 <div class="section-example-container">
  <pre class="python">ret = df.pct_change().shift(-1).iloc[:-1]
ret_spy = spy_close.pct_change().shift(-1).iloc[:-1]</pre>
 </div>
 <li>
  Get the active forward return.
 </li>
 <div class="section-example-container">
  <pre class="python">active_ret = ret.sub(ret_spy.values, axis=0)</pre>
 </div>
 <li>
  Select the ExecutionPrice column and then call the
  <code>
   unstack
  </code>
  method to get the buyback dataframe.
 </li>
 <div class="section-example-container">
  <pre class="python">df_buybacks = history_buybacks['executionprice'].unstack(level=0)</pre>
 </div>
 <li>
  Convert buyback history into daily mean data.
 </li>
 <div class="section-example-container">
  <pre class="python">df_buybacks = df_buybacks.groupby(df_buybacks.index.date).mean()
df_buybacks.columns = df.columns</pre>
 </div>
 <li>
  Get the buyback premium/discount %.
 </li>
 <div class="section-example-container">
  <pre class="python">df_close = df.reindex(df_buybacks.index)[~df_buybacks.isna()]
df_buybacks = (df_buybacks - df_close)/df_close</pre>
 </div>
 <li>
  Create a
  <code>
   Dataframe
  </code>
  to hold the buyback and 1-day forward return data.
 </li>
 <div class="section-example-container">
  <pre class="python">data = pd.DataFrame(columns=["Buybacks", "Return"])</pre>
 </div>
 <li>
  Append the data into the
  <code>
   Dataframe
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">for row, row_buyback in zip(active_ret.reindex(df_buybacks.index).itertuples(), df_buybacks.itertuples()):
    index = row[0]
    for i in range(1, df_buybacks.shape[1]+1):
        if row_buyback[i] != 0:
            data = pd.concat([data, pd.DataFrame({"Buybacks": row_buyback[i], "Return":row[i]}, index=[index])])</pre>
 </div>
 <li>
  Call
  <code>
   dropna
  </code>
  to drop NaNs.
 </li>
 <div class="section-example-container">
  <pre class="python">data.dropna(inplace=True)</pre>
 </div>
 <img alt="Processed data" class="docs-image" src="https://cdn.quantconnect.com/i/tu/airline-buybacks-2022-data.png"/>
</ol>

<h3>Test Hypothesis</h3>
<p>
 We would test (1) if buyback has statistically significant effect on return direction, and (2) buyback could be a return predictor.
</p>
<ol>
 <li>
  Get binary return (+/-).
 </li>
 <div class="section-example-container">
  <pre class="python">binary_ret = data["Return"].copy()
binary_ret[binary_ret &lt; 0] = 0
binary_ret[binary_ret &gt; 0] = 1</pre>
 </div>
 <li>
  Construct a logistic regression model.
 </li>
 <div class="section-example-container">
  <pre class="python">model = Logit(binary_ret.values, data["Buybacks"].values).fit()</pre>
 </div>
 <li>
  Display logistic regression results.
 </li>
 <div class="section-example-container">
  <pre class="python">display(model.summary())</pre>
 </div>
 <img alt="Logistic regression model summary" class="docs-image" src="https://cdn.quantconnect.com/i/tu/airline-buybacks-2022-logit.png"/>
 <p>
  We can see a p-value of &lt; 0.05 in the logistic regression model, meaning the separation of positive and negative using buyback premium/discount% is statistically significant.
 </p>
 <li>
  Plot the results.
 </li>
 <div class="section-example-container">
  <pre class="python">plt.figure(figsize=(10, 6))
sns.regplot(x=data["Buybacks"]*100, y=binary_ret, logistic=True, ci=None, line_kws={'label': " Logistic Regression Line"})
plt.plot([-50, 50], [0.5, 0.5], "r--", label="Selection Cutoff Line")
plt.title("Buyback premium vs Profit/Loss")
plt.xlabel("Buyback premium %")
plt.xlim([-50, 50])
plt.ylabel("Profit/Loss")
plt.legend()
plt.show()</pre>
 </div>
 <img alt="Logistic regression model result visualization" class="docs-image" src="https://cdn.quantconnect.com/i/tu/airline-buybacks-2022-plot.png"/>
 <p>
  Interesting, from the logistic regression line, we observe that when the airlines brought their stock in premium price, the price tended to go down, while the opposite for buying back in discount.
 </p>
 <br/>
 <p>
  Let's also study how good is the logistic regression.
 </p>
 <li>
  Get in-sample prediction result.
 </li>
 <div class="section-example-container">
  <pre class="python">predictions = model.predict(data["Buybacks"].values)
for i in range(len(predictions)):
    predictions[i] = 1 if predictions[i] &gt; 0.5 else 0</pre>
 </div>
 <li>
  Call
  <code>
   confusion_matrix
  </code>
  to contrast the results.
 </li>
 <div class="section-example-container">
  <pre class="python">cm = confusion_matrix(binary_ret, predictions)</pre>
 </div>
 <li>
  Display the result.
 </li>
 <div class="section-example-container">
  <pre class="python">df_result = pd.DataFrame(cm, 
                        index=pd.MultiIndex.from_tuples([("Prediction", "Positive"), ("Prediction", "Negative")]),
                        columns=pd.MultiIndex.from_tuples([("Actual", "Positive"), ("Actual", "Negative")]))</pre>
 </div>
 <img alt="Logistic regression model confusion matrix" class="docs-image" src="https://cdn.quantconnect.com/i/tu/airline-buybacks-2022-cm.png"/>
 <p>
  The logistic regression is having a 55.8% accuracy (55% sensitivity and 56.3% specificity), this can suggest a &gt; 50% win rate before friction costs, proven our hypothesis.
 </p>
</ol>

<h3>Set Up Algorithm</h3>
<p>
 Once we are confident in our hypothesis, we can export this code into backtesting. One way to accomodate this model into backtest is to create a scheduled event which uses our model to predict the expected return.
</p>
<div class="section-example-container">
 <pre class="python">def Initialize(self) -&gt; None:

    #1. Required: Five years of backtest history
    self.SetStartDate(2017, 1, 1)

    #2. Required: Alpha Streams Models:
    self.SetBrokerageModel(BrokerageName.AlphaStreams)

    #3. Required: Significant AUM Capacity
    self.SetCash(1000000)

    #4. Required: Benchmark to SPY
    self.SetBenchmark("SPY")
    
    self.SetPortfolioConstruction(EqualWeightingPortfolioConstructionModel())
    self.SetExecution(ImmediateExecutionModel())
    
    # Set our strategy to be take 5% profit and 5% stop loss.
    self.AddRiskManagement(MaximumUnrealizedProfitPercentPerSecurity(0.05))
    self.AddRiskManagement(MaximumDrawdownPercentPerSecurity(0.05))

    # Select the airline tickers for research.
    self.symbols = {}
    assets = ["LUV",   # Southwest Airlines
                "DAL",   # Delta Airlines
                "UAL",   # United Airlines Holdings
                "AAL",   # American Airlines Group
                "SKYW",  # SkyWest Inc. 
                "ALGT",  # Allegiant Travel Co.
                "ALK"    # Alaska Air Group Inc.
                ]
                
    # Call the AddEquity method with the tickers, and its corresponding resolution. Then call AddData with SmartInsiderTransaction to subscribe to their buyback transaction data.
    for ticker in assets:
        symbol = self.AddEquity(ticker, Resolution.Minute).Symbol
        self.symbols[symbol] = self.AddData(SmartInsiderTransaction, symbol).Symbol
        
    self.AddEquity("SPY")
    
    # Initialize the model
    self.BuildModel()
    
    # Set Scheduled Event Method For Our Model Recalibration every month
    self.Schedule.On(self.DateRules.MonthStart(), self.TimeRules.At(0, 0), self.BuildModel)
    
    # Set Scheduled Event Method For Trading
    self.Schedule.On(self.DateRules.EveryDay(), self.TimeRules.BeforeMarketClose("SPY", 5), self.EveryDayBeforeMarketClose)</pre>
</div>
<p>
 We'll also need to create a function to train and update the logistic regression model from time to time.
</p>
<div class="section-example-container">
 <pre class="python">def BuildModel(self) -&gt; None:
    qb = self
    # Call the History method with list of tickers, time argument(s), and resolution to request historical data for the symbol.
    history = qb.History(list(self.symbols.keys()), datetime(2015, 1, 1), datetime.now(), Resolution.Daily)
    
    # Call SPY history as reference
    spy = qb.History(["SPY"], datetime(2015, 1, 1), datetime.now(), Resolution.Daily)
    
    # Call the History method with list of buyback tickers, time argument(s), and resolution to request buyback data for the symbol.
    history_buybacks = qb.History(list(self.symbols.values()), datetime(2015, 1, 1), datetime.now(), Resolution.Daily)
    
    # Select the close column and then call the unstack method to get the close price dataframe.
    df = history['close'].unstack(level=0)
    spy_close = spy['close'].unstack(level=0)
    
    # Call pct_change to get the daily return of close price, then shift 1-step backward as prediction.
    ret = df.pct_change().shift(-1).iloc[:-1]
    ret_spy = spy_close.pct_change().shift(-1).iloc[:-1]
    
    # Get the active return
    active_ret = ret.sub(ret_spy.values, axis=0)
    
    # Select the ExecutionPrice column and then call the unstack method to get the dataframe.
    df_buybacks = history_buybacks['executionprice'].unstack(level=0)
    
    # Convert buyback history into daily mean data
    df_buybacks = df_buybacks.groupby(df_buybacks.index.date).mean()
    df_buybacks.columns = df.columns
    
    # Get the buyback premium/discount
    df_close = df.reindex(df_buybacks.index)[~df_buybacks.isna()]
    df_buybacks = (df_buybacks - df_close)/df_close
    
    # Create a dataframe to hold the buyback and 1-day forward return data
    data = pd.DataFrame(columns=["Buybacks", "Return"])
    
    # Append the data into the dataframe
    for row, row_buyback in zip(active_ret.reindex(df_buybacks.index).itertuples(), df_buybacks.itertuples()):
        index = row[0]
        for i in range(1, df_buybacks.shape[1]+1):
            if row_buyback[i] != 0:
                data = pd.concat([data, pd.DataFrame({"Buybacks": row_buyback[i], "Return":row[i]}, index=[index])])
    
    # Call dropna to drop NaNs
    data.dropna(inplace=True)
    
    # Get binary return (+/-)
    binary_ret = data["Return"].copy()
    binary_ret[binary_ret &lt; 0] = 0
    binary_ret[binary_ret &gt; 0] = 1
    
    # Construct a logistic regression model
    self.model = Logit(binary_ret.values, data["Buybacks"].values).fit()</pre>
</div>
<p>
 Now we export our model into the scheduled event method. We will switch
 <code>
  qb
 </code>
 with
 <code>
  self
 </code>
 and replace methods with their
 <code>
  QCAlgorithm
 </code>
 counterparts as needed. In this example, this is not an issue because all the methods we used in research also exist in
 <code>
  QCAlgorithm
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">def EveryDayBeforeMarketClose(self) -&gt; None:
    qb = self
    # Get any buyback event today
    history_buybacks = qb.History(list(self.symbols.values()), timedelta(days=1), Resolution.Daily)
    if history_buybacks.empty or "executionprice" not in history_buybacks.columns: return

    # Select the ExecutionPrice column and then call the unstack method to get the dataframe.
    df_buybacks = history_buybacks['executionprice'].unstack(level=0)
    
    # Convert buyback history into daily mean data
    df_buybacks = df_buybacks.groupby(df_buybacks.index.date).mean()
    
    # ==============================
    
    insights = []
    
    # Iterate the buyback data, thne pass to the model for prediction
    row = df_buybacks.iloc[-1]
    for i in range(len(row)):
        prediction = self.model.predict(row[i])
        
        # Long if the prediction predict price goes up, short otherwise. Do opposite for SPY (active return)
        if prediction &gt; 0.5:
            insights.append( Insight.Price(row.index[i].split(".")[0], timedelta(days=1), InsightDirection.Up) )
            insights.append( Insight.Price("SPY", timedelta(days=1), InsightDirection.Down) )
        else:
            insights.append( Insight.Price(row.index[i].split(".")[0], timedelta(days=1), InsightDirection.Down) )
            insights.append( Insight.Price("SPY", timedelta(days=1), InsightDirection.Up) )

    self.EmitInsights(insights)</pre>
</div>

<h3>Reference</h3>
<ul>
 <li>
  US Airlines Spent 96% of Free Cash Flow on Buybacks: Chart. B. Kochkodin (17 March 2020).
  <i>
   Bloomberg. Retrieve from: https://www.bloomberg.com/news/articles/2020-03-16/u-s-airlines-spent-96-of-free-cash-flow-on-buybacks-chart.
  </i>
 </li>
</ul>

<h3>Clone Example Project</h3>
<div class="python">
 <div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
  <div class="qc-embed-dummy" style="padding-top: 56.25%;">
  </div>
  <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
   <iframe class="qc-embed-backtest" height="100%" src="https://www.quantconnect.com/terminal/processCache/embedded_backtest_5e99765931b07e4bef1044672b2e2239.html" style="border: 1px solid #ccc; padding: 0; margin: 0;" width="100%">
   </iframe>
  </div>
 </div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
<section id="10.10"><h3>10.10 Sparse Optimization</h3></section>

<h3>Introduction</h3>
<p>
 This page explains how to you can use the Research Environment to develop and test a Sparse Optimization Index Tracking hypothesis, then put the hypothesis in production.
</p>

<h3>Create Hypothesis</h3>
<p>
 Passive index fund portfolio managers will buy in corresponding weighting of stocks from an index's constituents. The main idea is allowing market participants to trade an index in a smaller cost. Their performance is measured by Tracking Error (TE), which is the standard deviation of the active return of the portfolio versus its benchmark index. The lower the TE means that the portfolio tracks the index very accurately and consistently.
</p>
<p>
 A technique called Sparse Optimization comes into the screen as the portfolio managers want to cut their cost even lower by trading less frequently and with more liquid stocks. They select a desired group/all constituents from an index and try to strike a balance between the number of stocks in the portfolio and the TE, like the idea of L1/L2-normalization.
</p>
<p>
 On the other hand, long-only active fund aimed to beat the benchmark index. Their performance are measured by the mean-adjusted tracking error, which also take the mean active return into account, so the better fund can be identified as consisitently beating the index by n%.
</p>
<p>
 We can combine the 2 ideas. In this tutorial, we are about to generate our own active fund and try to use Sparse Optimization to beat QQQ. However, we need a new measure on active fund for this technique -- Downward Risk (DR). This is a measure just like the tracking error, but taking out the downward period of the index, i.e. we only want to model the index's upward return, but not downward loss. We would also, for a more robust regression, combining Huber function as our loss function. This is known as Huber Downward Risk (HDR). Please refer to
 <a href="https://palomar.home.ece.ust.hk/papers/2018/BenidisFengPalomar-FnT2018.pdf">
  Optimization Methods for Financial Index Tracking: From Theory to Practice.
  <i>
   K. Benidis, Y. Feng, D. P. Palomer (2018)
  </i>
 </a>
 for technical details.
</p>

<h3>Import Libraries</h3>
<p>
 We'll need to import libraries to help with data processing and visualization. Import
 <code>
  numpy
 </code>
 ,
 <code>
  matplotlib
 </code>
 and
 <code>
  pandas
 </code>
 libraries by the following:
</p>
<div class="section-example-container">
 <pre class="python">import numpy as np
from matplotlib import pyplot as plt
from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()</pre>
</div>

<h3>Get Historical Data</h3>
<p>
 To begin, we retrieve historical data for researching.
</p>
<ol>
 <li>
  Create a class to get the index/ETF constituents on a particular date.
 </li>
 <div class="section-example-container">
  <pre class="python">class ETFUniverse:
    """
    A class to create a universe of equities from the constituents of an ETF
    """
    def __init__(self, etf_ticker, universe_date):
        """
        Input:
         - etf_ticker
            Ticker of the ETF
         - universe_date
            The date to gather the constituents of the ETF
        """
        self.etf_ticker = etf_ticker
        self.universe_date = universe_date
    
    
    def get_symbols(self, qb):
        """
        Subscribes to the universe constituents and returns a list of symbols and their timezone
        
        Input:
         - qb
            The QuantBook instance inside the DatasetAnalyzer
        
        Returns a list of symbols and their timezone
        """
        etf_symbols = self._get_etf_constituents(qb, self.etf_ticker, self.universe_date)
        security_timezone = None
        security_symbols = []
        
        # Subscribe to the universe price data
        for symbol in etf_symbols:
            security = qb.AddSecurity(symbol, Resolution.Daily)
            security_timezone = security.Exchange.TimeZone
            security_symbols.append(symbol)
        
        return security_symbols, security_timezone
    
    
    def _get_etf_constituents(self, qb, etf_ticker, date):
        """
        A helper method to retreive the ETF constituents on a given date
        
        Input:
         - qb
            The QuantBook instance inside the DatasetAnalyzer
         - etf_ticker
             Ticker of the ETF
         - universe_date
            The date to gather the constituents of the ETF
        
        Returns a list of symbols
        """
        date_str = date.strftime("%Y%m%d")
        filename = f"/data/equity/usa/universes/etf/{etf_ticker.lower()}/{date_str}.csv"
        try:
            df = pd.read_csv(filename)
        except:
            print(f'Error: The ETF universe file does not exist')
            return
        security_ids = df[df.columns[1]].values
        symbols = [qb.Symbol(security_id) for security_id in security_ids]
        return symbols</pre>
 </div>
 <li>
  Instantiate a
  <code>
   QuantBook
  </code>
  .
 </li>
 <div class="section-example-container">
  <pre class="python">qb = QuantBook()</pre>
 </div>
 <li>
  Subscribe to the index/ETF.
 </li>
 <p>
  In this tutorial, we'll be using QQQ.
 </p>
 <div class="section-example-container">
  <pre class="python">qqq = qb.AddEquity("QQQ").Symbol</pre>
 </div>
 <li>
  Select all the constituents for research.
 </li>
 <p>
  In this tutorial, we select the constituents of QQQ on 2020-12-31.
 </p>
 <div class="section-example-container">
  <pre class="python">assets, _ = ETFUniverse("QQQ", datetime(2020, 12, 31)).get_symbols(qb)</pre>
 </div>
 <li>
  Prepare the historical return data of the constituents and the benchmark index to track.
 </li>
 <div class="section-example-container">
  <pre class="python">spy = qb.History(qb.AddEquity("SPY").Symbol, datetime(2019, 1, 1), datetime(2021, 12, 31), Resolution.Daily)</pre>
 </div>
 <li>
  Call the
  <code>
   History
  </code>
  method with a list of
  <code>
   SmartInsiderTransaction
  </code>
  <code>
   Symbol
  </code>
  s for all tickers, time argument(s), and resolution to request historical data for the symbols.
 </li>
 <div class="section-example-container">
  <pre class="python">history = qb.History(assets, datetime(2020, 1, 1), datetime(2021, 3, 31), Resolution.Daily)
historyPortfolio = history.close.unstack(0).loc[:"2021-01-01"]
pctChangePortfolio = np.log(historyPortfolio/historyPortfolio.shift(1)).dropna()

historyQQQ_ = qb.History(qqq, datetime(2020, 1, 1), datetime(2021, 3, 31), Resolution.Daily)
historyQQQ = historyQQQ_.close.unstack(0).loc[:"2021-01-01"]
pctChangeQQQ = np.log(historyQQQ/historyQQQ.shift(1)).loc[pctChangePortfolio.index]</pre>
 </div>
</ol>

<h3>Prepare Data</h3>
<p>
 We'll have to process our data and construct the proposed sparse index tracking portfolio.
</p>
<ol>
 <li>
  Get the dimensional sizes.
 </li>
 <div class="section-example-container">
  <pre class="python">m = pctChangePortfolio.shape[0]; n = pctChangePortfolio.shape[1]</pre>
 </div>
 <li>
  Set up optimization parameters (penalty of exceeding bounds, Huber statistics M-value, penalty weight).
 </li>
 <div class="section-example-container">
  <pre class="python">p = 0.5
M = 0.0001
l = 0.01</pre>
 </div>
 <li>
  Set up convergence tolerance, maximum iteration of optimization, iteration counter and HDR as minimization indicator.
 </li>
 <div class="section-example-container">
  <pre class="python">tol = 0.001
maxIter = 20
iters = 1
hdr = 10000</pre>
 </div>
 <li>
  Initial weightings and placeholders.
 </li>
 <div class="section-example-container">
  <pre class="python">w_ = np.array([1/n] * n).reshape(n, 1)
weights = pd.Series()
a = np.array([None] * m).reshape(m, 1)
c = np.array([None] * m).reshape(m, 1)
d = np.array([None] * n).reshape(n, 1)</pre>
 </div>
 <li>
  Iterate minimization algorithm to minimize the HDR.
 </li>
 <div class="section-example-container">
  <pre class="python">while iters &lt; maxIter:
    x_k = (pctChangeQQQ.values - pctChangePortfolio.values @ w_)
    for i in range(n):
        w = w_[i]
        d[i] = d_ = 1/(np.log(1+l/p)*(p+w))
    for i in range(m):
        xk = float(x_k[i])
        if xk &lt; 0:
            a[i] = M / (M - 2*xk)
            c[i] = xk
        else:
            c[i] = 0
            if 0 &lt;= xk &lt;= M:
                a[i] = 1
            else:
                a[i] = M/abs(xk)

    L3 = 1/m * pctChangePortfolio.T.values @ np.diagflat(a.T) @ pctChangePortfolio.values
    eigVal, eigVec = np.linalg.eig(L3.astype(float))
    eigVal = np.real(eigVal); eigVec = np.real(eigVec)
    q3 = 1/max(eigVal) * (2 * (L3 - max(eigVal) * np.eye(n)) @ w_ + eigVec @ d - 2/m * pctChangePortfolio.T.values @ np.diagflat(a.T) @ (c - pctChangeQQQ.values))
    
    # We want to keep the upper bound of each asset to be 0.1
    u = 0.1
    mu = float(-(np.sum(q3) + 2)/n); mu_ = 0
    while mu &gt; mu_:
        mu = mu_
        index1 = [i for i, q in enumerate(q3) if mu + q &lt; -u*2]
        index2 = [i for i, q in enumerate(q3) if -u*2 &lt; mu + q &lt; 0]
        mu_ = float(-(np.sum([q3[i] for i in index2]) + 2 - len(index1)*u*2)/len(index2))

    # Obtain the weights and HDR of this iteration.
    w_ = np.amax(np.concatenate((-(mu + q3)/2, u*np.ones((n, 1))), axis=1), axis=1).reshape(-1, 1)
    w_ = w_/np.sum(abs(w_))
    hdr_ = float(w_.T @ w_ + q3.T @ w_)

    # If the HDR converges, we take the current weights
    if abs(hdr - hdr_) &lt; tol:
        break

    # Else, we would increase the iteration count and use the current weights for the next iteration.
    iters += 1
    hdr = hdr_</pre>
 </div>
 <li>
  Save the final weights.
 </li>
 <div class="section-example-container">
  <pre class="python">for i in range(n):
    weights[pctChangePortfolio.columns[i]] = w_[i]</pre>
 </div>
 <li>
  Get the historical return of the proposed portfolio.
 </li>
 <div class="section-example-container">
  <pre class="python">histPort = historyPortfolio.dropna() @ np.array([weights[pctChangePortfolio.columns[i]] for i in range(pctChangePortfolio.shape[1])])</pre>
 </div>
 <img alt="Constructed index values" class="docs-image" src="https://cdn.quantconnect.com/i/tu/sparse-optimization-index-tracking-proposed-history.png"/>
</ol>

<h3>Test Hypothesis</h3>
<p>
 To test the hypothesis. We wish to (1) outcompete the benchmark and (2) the active return is consistent in the in- and out-of-sample period.
</p>
<ol>
 <li>
  Obtain the equity curve of our portfolio and normalized benchmark for comparison.
 </li>
 <div class="section-example-container">
  <pre class="python">proposed = history.close.unstack(0).dropna() @ np.array([weights[pctChangePortfolio.columns[i]] for i in range(pctChangePortfolio.shape[1])])
benchmark = historyQQQ_.close.unstack(0).loc[proposed.index]
normalized_benchmark = benchmark / (float(benchmark.iloc[0])/float(proposed.iloc[0]))</pre>
 </div>
 <li>
  Obtain the active return.
 </li>
 <div class="section-example-container">
  <pre class="python">proposed_ret = proposed.pct_change().iloc[1:]
benchmark_ret = benchmark.pct_change().iloc[1:]
active_ret = proposed_ret - benchmark_ret.values</pre>
 </div>
 <li>
  Plot the result.
 </li>
 <div class="section-example-container">
  <pre class="python">fig = plt.figure(figsize=(15, 10))
plt.plot(proposed, label="Proposed Portfolio")
plt.plot(normalized_benchmark, label="Normalized Benchmark")
min_ = min(min(proposed.values), min(normalized_benchmark.values))
max_ = max(max(proposed.values), max(normalized_benchmark.values))
plt.plot([pd.to_datetime("2021-01-01")]*100, np.linspace(min_, max_, 100), "r--", label="in- and out- of sample separation")
plt.title("Equity Curve")
plt.legend()
plt.show()
plt.clf()

fig, ax = plt.subplots(1, 1)
active_ret["Mean"] = float(active_ret.mean())
active_ret.plot(figsize=(15, 5), title="Active Return", ax=ax)
plt.show()</pre>
 </div>
 <img alt="Equity curve of constructed index and benchmark index" class="docs-image" src="https://cdn.quantconnect.com/i/tu/sparse-optimization-index-tracking-equity-curve.png"/>
 <img alt="Active return of constructed index" class="docs-image" src="https://cdn.quantconnect.com/i/tu/sparse-optimization-index-tracking-active-return.png"/>
</ol>
<p>
 We can see from the plots, both in- and out-of-sample period the proposed portfolio out preform the benchmark while remaining a high correlation with it. Although the active return might not be very consistent, but it is a stationary series above zero. So, in a long run, it does consistently outcompete the QQQ benchmark!
</p>

<h3>Set Up Algorithm</h3>
<p>
 Once we are confident in our hypothesis, we can export this code into backtesting.
</p>
<div class="section-example-container">
 <pre class="python">def Initialize(self) -&gt; None:
    self.SetStartDate(2017, 1, 1)
    self.SetBrokerageModel(BrokerageName.AlphaStreams)
    self.SetCash(1000000)
    
    # Add our ETF constituents of the index that we would like to track.
    self.QQQ = self.AddEquity("QQQ", Resolution.Minute).Symbol
    self.UniverseSettings.Resolution = Resolution.Minute
    self.AddUniverse(self.Universe.ETF(self.QQQ, self.UniverseSettings, self.ETFSelection))
    
    self.SetBenchmark("QQQ")
    
    # Set up varaibles to flag the time to recalibrate and hold the constituents.
    self.time = datetime.min
    self.assets = []</pre>
</div>
<p>
 We'll also need to create a function for getting the ETF constituents.
</p>
<div class="section-example-container">
 <pre class="python">def ETFSelection(self, constituents: ETFConstituentData) -&gt; List[Symbol]:
    # We want all constituents to be considered.
    self.assets = [x.Symbol for x in constituents]
    return self.assets</pre>
</div>
<p>
 Now we export our model into the
 <code>
  OnData
 </code>
 method. We will switch
 <code>
  qb
 </code>
 with
 <code>
  self
 </code>
 and replace methods with their
 <code>
  QCAlgorithm
 </code>
 counterparts as needed. In this example, this is not an issue because all the methods we used in research also exist in
 <code>
  QCAlgorithm
 </code>
 .
</p>
<div class="section-example-container">
 <pre class="python">def OnData(self, slice: Slice) -&gt; None:
    qb = self
    if self.time &gt; self.Time:
        return
    
    # Prepare the historical return data of the constituents and the ETF (as index to track).
    history = qb.History(self.assets, 252, Resolution.Daily)
    if history.empty: return

    historyPortfolio = history.close.unstack(0)
    pctChangePortfolio = np.log(historyPortfolio/historyPortfolio.shift(1)).dropna()
    
    historyQQQ = qb.History(self.AddEquity("QQQ").Symbol, 252, Resolution.Daily)
    historyQQQ = historyQQQ.close.unstack(0)
    pctChangeQQQ = np.log(historyQQQ/historyQQQ.shift(1)).loc[pctChangePortfolio.index]
    
    m = pctChangePortfolio.shape[0]; n = pctChangePortfolio.shape[1]
    
    # Set up optimization parameters.
    p = 0.5; M = 0.0001; l = 0.01
    
    # Set up convergence tolerance, maximum iteration of optimization, iteration counter and Huber downward risk as minimization indicator.
    tol = 0.001; maxIter = 20; iters = 1; hdr = 10000
    
    # Initial weightings and placeholders.
    w_ = np.array([1/n] * n).reshape(n, 1)
    self.weights = pd.Series()
    a = np.array([None] * m).reshape(m, 1)
    c = np.array([None] * m).reshape(m, 1)
    d = np.array([None] * n).reshape(n, 1)
    
    # Iterate to minimize the HDR.
    while iters &lt; maxIter:
        x_k = (pctChangeQQQ.values - pctChangePortfolio.values @ w_)
        for i in range(n):
            w = w_[i]
            d[i] = d_ = 1/(np.log(1+l/p)*(p+w))
        for i in range(m):
            xk = float(x_k[i])
            if xk &lt; 0:
                a[i] = M / (M - 2*xk)
                c[i] = xk
            else:
                c[i] = 0
                if 0 &lt;= xk &lt;= M:
                    a[i] = 1
                else:
                    a[i] = M/abs(xk)
                    
        L3 = 1/m * pctChangePortfolio.T.values @ np.diagflat(a.T) @ pctChangePortfolio.values
        eigVal, eigVec = np.linalg.eig(L3.astype(float))
        eigVal = np.real(eigVal); eigVec = np.real(eigVec)
        q3 = 1/max(eigVal) * (2 * (L3 - max(eigVal) * np.eye(n)) @ w_ + eigVec @ d - 2/m * pctChangePortfolio.T.values @ np.diagflat(a.T) @ (c - pctChangeQQQ.values))
        
        # We want to keep the upper bound of each asset to be 0.1
        u = 0.1
        mu = float(-(np.sum(q3) + 2)/n); mu_ = 0
        while mu &gt; mu_:
            mu = mu_
            index1 = [i for i, q in enumerate(q3) if mu + q &lt; -u*2]
            index2 = [i for i, q in enumerate(q3) if -u*2 &lt; mu + q &lt; 0]
            mu_ = float(-(np.sum([q3[i] for i in index2]) + 2 - len(index1)*u*2)/len(index2))
    
        # Obtain the weights and HDR of this iteration.
        w_ = np.amax(np.concatenate((-(mu + q3)/2, u*np.ones((n, 1))), axis=1), axis=1).reshape(-1, 1)
        w_ = w_/np.sum(abs(w_))
        hdr_ = float(w_.T @ w_ + q3.T @ w_)
        
        # If the HDR converges, we take the current weights
        if abs(hdr - hdr_) &lt; tol:
            break
        
        # Else, we would increase the iteration count and use the current weights for the next iteration.
        iters += 1
        hdr = hdr_
    
    # -----------------------------------------------------------------------------------------
    orders = []
    for i in range(n):
        orders.append(PortfolioTarget(pctChangePortfolio.columns[i], float(w_[i])))
    self.SetHoldings(orders)
    
    # Recalibrate on quarter end.
    self.time = Expiry.EndOfQuarter(self.Time)</pre>
</div>

<h3>Reference</h3>
<ul>
 <li>
  Optimization Methods for Financial Index Tracking: From Theory to Practice. K. Benidis, Y. Feng, D. P. Palomer (2018).
  <i>
   Foundations and Trends in Signal Processing. 3-3. p171-279.
  </i>
 </li>
</ul>

<h3>Clone Example Project</h3>
<div class="python">
 <div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
  <div class="qc-embed-dummy" style="padding-top: 56.25%;">
  </div>
  <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
   <iframe class="qc-embed-backtest" height="100%" src="https://www.quantconnect.com/terminal/processCache/embedded_backtest_d69e9890623206f5f1e2f4095de3a806.html" style="border: 1px solid #ccc; padding: 0; margin: 0;" width="100%">
   </iframe>
  </div>
 </div>
</div>

<p style="page-break-after: always;">&nbsp;</p>
