<p>The ObjectStore allows you to store and retrieve regular strings, JSON encoded strings, XML encoded strings, and bytes. When deploying a live algorithm, your state is loaded from the object store on deployment. Currently, it is not "refreshed", so you will need to redeploy the live algorithm when you wish to reload your data. The sections below demonstrate the following:</p>

<ul>
	<li>Gathering keys from the ObjectStore.</li>
	<li>Storing data in the ObjectStore.</li>
	<li>Reading data from the ObjectStore.</li>
	<li>Deleting data from the ObjectStore.</li>
</ul>

<h4>Gathering keys</h4>
<p>The ObjectStore keys can be gathered by using the <code>GetEnumerator</code> method.</p>

<div class="section-example-container">
<pre><code class="language-python">keys = [str(j).split(',')[0][1:] for _, j in enumerate(self.ObjectStore.GetEnumerator())]</code></pre>
<pre><code class="language-cs"></code></pre>
</div>

<p>A <code>Keys</code> attribute will be added to the ObjectStore class to enable easier key gathering. Subscribe to <a href="https://github.com/QuantConnect/Lean/issues/5507">GitHub Issue #5507</a> to track our progress in adding this functionality.</p>


<h4>Storing data</h4>
<p>Data can be saved to the ObjectStore using the <code>Save</code>, <code>SaveBytes</code>, <code>SaveJson</code>, and <code>SaveXml</code> methods. The method you use depends on the type of data being stored. You just need to provide the key and value.</p>

<div class="section-example-container">
<pre><code class="language-python">self.ObjectStore.Save("key", "value")                        # Save data as a string
self.ObjectStore.SaveBytes("key", bytearray(objectValue))    # Save data as a bytes
self.ObjectStore.SaveJson("key", objectValue)                # Save object as JSON encoded string
self.ObjectStore.SaveXml("key", objectValue)                 # Save object as XML encoded string
</code></pre>
<pre><code class="language-cs"></code></pre>
</div>


<h4>Reading data</h4>

<p>Data can be read from the ObjectStore using the <code>Read</code>, <code>ReadBytes</code>, <code>ReadJson</code>, and <code>ReadXml</code> methods. The method you use depends on the type of data being read. You just need to provide the key.</p>

<div class="section-example-container">
<pre><code class="language-python">val = self.ObjectStore.Read("key")            # Read data as string
bytes = self.ObjectStore.ReadBytes("key")     # Read data as bytes
jsonObj = self.ObjectStore.ReadJson("key")    # Deserialize a JSON object from storage
xmlObj = self.ObjectStore.ReadXml("key")      # Deserialize a XML object from storage
</code></pre>
<pre><code class="language-cs"></code></pre>
</div>



<h4>Deleting data</h4>

<p>Data can be deleted from the ObjectStore using the <code>Delete</code> method. The <code>Delete</code> method works with all types of data stored in the ObjectStore. You just need to provide the key.</p>

<div class="section-example-container">
<pre><code class="language-python">self.ObjectStore.Delete("key")            # Delete the data from the store</code></pre>
<pre><code class="language-cs"></code></pre>
</div>


<h4>Example</h4>
<p>The example below demonstrates gathering keys, saving, loading, and deleting from the ObjectStore. The data can be managed from both the code files and the research notebook. This example can easily be extended to fit most use cases of transporting data between the research and backtesting environments.</p>
<div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;"><div class="qc-embed-dummy" style="padding-top: 56.25%;"></div><div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;"><iframe class="qc-embed-backtest" src="https://www.quantconnect.com/terminal/processCache?request=embedded_backtest_ac805e730ab57b51bc494db0a8842e9b.html" style="max-width: calc(100vw - 30px); max-height: 100vw; overflow: hidden;" scrolling="no" width="100%" height="100%"></iframe></div></div>